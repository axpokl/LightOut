我在优化一个点灯游戏的算法，想把算法的时间复杂度提高比O(n^3)更快。
我将灯和按钮描述为了只有0或者1元素的矩阵，并且只存在一种运算xor。
我需要找到一个比O(n^3)更快的矩阵求逆算法。
注意矩阵本身可能是不可逆的，此时需要对其进行充分的高斯消元并保持时间复杂度低。 

1.不是很确定这个是否GF（2），但是矩阵元素只有xor一种运算，并且矩阵元素只有0和1。
2.如果找到一种更快算法，那么其结果必须和高斯约当法必须完全相同。
3. 这个矩阵秩是3，因此右边的伪逆会有两个行无法消去，左边则会有两个空行。你可以先试着用这个方法求解，再去寻找更快算法。
4.不要用位压缩来加速，因为这理论上无法使时间复杂度降低。
5.这个逆和实数域矩阵逆求法可能不完全相同，实数域结论不能直接套用。例如，这个矩阵的秩是3，但是如果是实数域，根据计算相同矩阵的秩是4.
6.矩阵是不可逆的，也未必是moore-penrose逆，这个需要论证。

这里，我提供了一个程序包含一些算法。我需要你基于这些算法进行修改。首先要做的是理解这些算法并预测结果。

现在，帮我算出矩阵A。要注意数组的范围是-1到5。开始吧。

--------------------------------------------------------------------------------------------------------------

A是正确的。现在，你需要注意以下内容并完成优化高斯消元计算的后续任务：

现在，你先根据一般高斯消元，将A尽可能转为E并输出E，然后同时操作另一个E转为R=A^-1并输出。
设A(j,i)表示矩阵A的第j行第i列，高斯消元的步骤为：

1. 从上往下遍历行j
2. 如果A(j,j)=0，向下查找j'行，直到A(j',j)=1，交换j和j'行
3. 此时A(j,j)=1，向下查找j'行，如果A(j',j)=1，将j行异或到j'行上
4. 继续遍历下一行j=j+1，直到j>n。此时矩阵为右上三角矩阵
5. 从下往上遍历j
6. 如果A(j,j)=1，向上查找j'行，如果A(j',j)=1，将j行异或到j'行上
7. 继续遍历上一行j=j-1，直到j<1。

--------------------------------------------------------------------------------------------------------------

这个结果是正确的。我就是需要获得这样的R。现在我需要找到一个更快的算法（比O(n^3)快），通过A计算出R=A^-1'。

现在，帮我寻找并实现这样的算法。你可以参考Strassen 演算法和递归分块法。
我暂时不需要你帮我写代码。你只需要自己写代码并实现你的算法，并且通过你的算法进行计算验证你算法是可以正确计算的。
请测试n=5和n=8的情况。还是首先计算出矩阵A，然后用一般高斯消元和你的优化版消元分别计算E和R，把n=5和n=8的情况（矩阵A,E,R=A^-1）的结果都告诉我。

--------------------------------------------------------------------------------------------------------------

现在，参考并修改我下面的pascal代码，增加一个函数CalcMat2()，实现优化的高斯消元，并加上注释，主程序将CalcMat()改为CalcMat2()。如果可以，测试你写的pascal代码。


{$define disp}
program diandeng;

{$ifdef disp}
uses display;
{$endif}

const m=1000;

type TMat=array[-1..m,-1..m]of Boolean;

var n:longword;
var a,l,r,t:TMat;
var i,j,k:longint;

{$ifdef disp}
var bb:pbitbuf;
var s:longword=0;
var b:pbitmap;
{$endif}

procedure PrintMat(mat:TMat);
var i,j:longint;
begin
writeln();
for j:=0 to n-1 do
  begin
//  if mat[j,-1] then write('#') else write('.');
  for i:=0 to n-1 do
    if mat[j,i] then write('#') else write('.');
  writeln();
  end;
writeln();
end;

{$ifdef disp}
procedure DrawMat(mat:TMat);
begin
while IsNextMsg() do ;
for j:=0 to n-1 do
  for i:=0 to n-1 do
    if mat[j,i] then SetBBPixel(bb,i,j,black) else SetBBPixel(bb,i,j,white);
SetBB(bb);
FreshWin();
end;

procedure PrintMat(s:ansistring;mat:TMAT);
begin
DrawMat(mat);
b:=CreateBMP(n,n);
DrawBMP(_pmain,b,0,0,n,n,0,0,n,n);
SaveBMP(b,'png'+s+'/'+i2s(n)+'.png');
ReleaseBMP(b);
end;
{$endif}

procedure MakeMat();
begin
for i:=0 to n-1 do l[0,i]:=False;
l[-1,0]:=False;
for j:=1 to n do
  for i:=0 to n-1 do
    begin
    l[j,i]:=not(l[j-1,i-1] xor l[j-1,i] xor l[j-1,i+1] xor l[j-2,i]);
    l[j,i]:=l[j,i] xor a[j-1,i];
    end;
for i:=0 to n-1 do l[-1,i]:=False;
l[-1,0]:=True;
for j:=0 to n-1 do
  for i:=0 to n-1 do
    begin
    l[j,i]:=(l[j-1,i-1] xor l[j-1,i] xor l[j-1,i+1]);
    if j>0 then l[j,i]:=l[j,i] xor l[j-2,i];
    end;
for i:=0 to n-1 do l[0,i]:=l[n-1,i];
for j:=1 to n-1 do
  for i:=0 to n-1 do
    begin
    l[j,i]:=(l[j-1,i-1] xor l[j-1,i+1]);
    if j>1 then l[j,i]:=l[j,i] xor l[j-2,i];
    end;
for i:=0 to n-1 do begin l[i,-1]:=l[n,i];l[n,i]:=False;end;
for i:=0 to n-1 do for j:=0 to n-1 do r[i,j]:=(i=j);
end;

procedure CalcMat();
var j0:longint;
begin
for k:=0 to n-1 do
  begin
  j0:=-1;
  for j:=n-1 downto k do
    if l[j,k] then j0:=j;
  j:=j0;
  if j>=0 then
    begin
    if j<>k then
      for i:=-1 to n-1 do
        begin
        l[j,i]:=l[j,i] xor l[k,i];
        l[k,i]:=l[j,i] xor l[k,i];
        l[j,i]:=l[j,i] xor l[k,i];
        r[j,i]:=r[j,i] xor r[k,i];
        r[k,i]:=r[j,i] xor r[k,i];
        r[j,i]:=r[j,i] xor r[k,i];
        end;
    for j:=k+1 to n-1 do
      if l[j,k] then
        begin
        for i:=0 to n-1 do //for a-1
          begin
          l[j,i]:=l[j,i] xor l[k,i];
          r[j,i]:=r[j,i] xor r[k,i];
          end;
        l[j,-1]:=l[j,-1] xor l[k,-1];
        r[j,-1]:=r[j,-1] xor r[k,-1];
        end;
    end;
  end;
for i:=n-1 downto 0 do
  if l[i,i] then
    for j:=i-1 downto 0 do
      if l[j,i] then
        begin
        for k:=j to n-1 do
          begin
          l[j,k]:=l[j,k] xor l[i,k];
          r[j,k]:=r[j,k] xor r[i,k];
          end;
        l[j,-1]:=l[j,-1] xor l[i,-1];
        r[j,-1]:=r[j,-1] xor r[i,-1];
        end;
end;

procedure GeneMat();
begin
for i:=0 to n-1 do
  begin
  t[0,i]:=l[i,-1];
  l[i,-1]:=false;
  end;
for j:=1 to n-1 do
  for i:=0 to n-1 do
    t[j,i]:=not(t[j-1,i-1] xor t[j-1,i] xor t[j-1,i+1] xor t[j-2,i]) xor a[j-1,i];
end;

begin
{$ifdef disp}
CreateWin(m,m);
bb:=CreateBB(GetWin());
b:=CreateBMP(m,m);
{$endif}
for n:=1 to m do
  begin
  write(n,#9);
  write('m');MakeMat();{$ifdef disp}write('%');PrintMat('_A',l);{$endif}
  write('c');CalcMat();{$ifdef disp}write('%');PrintMat('_E',l);write('%');PrintMat('_R',r);{$endif}
  write('g');GeneMat();{$ifdef disp}write('%');PrintMat('_T',t);{$endif}
  write(#9,s,#9,n*n,#9,s/n/n:0:5);
  {$ifdef disp}if not(iswin()) then halt;{$endif}
  writeln();
  end;
end.

--------------------------------------------------------------------------------------------------------------

我的最终目标其实是解方程，也就是有一个矩阵A和增广向量X，对A做高斯消元的同时对X进行相同操作得到Y。
在操作A的同时，操作单位矩阵E计算逆矩阵R=A^-1'的过程其实不是必要的，因为最终只是为了得到Y。
但是，考虑到Strassen算法只是加快矩阵乘法，以及加快矩阵逆的求法，并不一定能立即适用于计算Y的过程。
然而，因为Y=RX，这里正好用到了矩阵求逆和乘法，因此可以适用Strassen算法来加快计算速度。
唯一难点就是矩阵的元素是0和1并且只有xor运算，不易能用Strassen算法。

现在，我需要你帮我论证是否可行

.##.#		#
###..		.
##.##		.
..###		.
#.##.		#
