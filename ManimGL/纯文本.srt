1
00:00:00,120 --> 00:00:03,880
规则在n乘n的格子内点击一个按钮，

2
00:00:03,880 --> 00:00:06,800
该格及周围的灯会被同时翻转。

3
00:00:06,880 --> 00:00:12,480
目标从全按状态打开所有灯或者全亮状态关闭所有灯，

4
00:00:12,600 --> 00:00:16,040
对同一按钮点击两次等同于没有按。

5
00:00:16,120 --> 00:00:18,160
用不同顺序点击按钮，

6
00:00:18,160 --> 00:00:20,360
灯的最终状态是一样的。

7
00:00:20,520 --> 00:00:21,040
因此，

8
00:00:21,160 --> 00:00:22,440
对格子内的按钮，

9
00:00:22,480 --> 00:00:24,440
我们只需考虑按或不按，

10
00:00:24,480 --> 00:00:26,520
并且不用关心顺序。

11
00:00:26,600 --> 00:00:28,800
我们可以将按钮和灯分开表示。

12
00:00:29,000 --> 00:00:30,720
所有按钮的状态为一组，

13
00:00:30,720 --> 00:00:32,960
对应灯的状态为一组。

14
00:00:32,960 --> 00:00:35,440
我们的目标是找到一个按钮组，

15
00:00:35,440 --> 00:00:37,920
其对应灯的状态为全亮。

16
00:00:37,920 --> 00:00:41,120
那么我们如何找到这样一个组按钮呢？

17
00:00:41,200 --> 00:00:44,960
n乘n个按钮共有二的n乘n次方种组合，

18
00:00:44,960 --> 00:00:47,720
每种组合对应唯一的灯状态。

19
00:00:47,760 --> 00:00:49,640
只要所有情况都是一遍，

20
00:00:49,680 --> 00:00:52,200
看看灯的状态如何即可，

21
00:00:52,280 --> 00:00:54,320
例如当n等于二时。

22
00:00:54,400 --> 00:00:59,480
对应的状态为2的2乘2次方等于2的4次方等于16。

23
00:00:59,560 --> 00:01:03,640
很快我们就能列举出所有的情况并得出结论。

24
00:01:03,640 --> 00:01:04,480
又例如，

25
00:01:04,480 --> 00:01:05,760
当n等于3时，

26
00:01:05,880 --> 00:01:10,240
对应的状态为2的3乘3次方等于2的9次方等于512。

27
00:01:10,240 --> 00:01:14,480
我们也可以穷举所有情况得出结论。

28
00:01:14,600 --> 00:01:15,600
对于n等于5，

29
00:01:15,880 --> 00:01:17,840
也就是一开始的经典问题。

30
00:01:18,040 --> 00:01:24,120
其状态数为2的5乘5次方等于2的25次方等于3355万4432

31
00:01:24,360 --> 00:01:24,400
，

32
00:01:24,760 --> 00:01:26,840
需要计算机来求解。

33
00:01:26,920 --> 00:01:34,960
当n等于60状态数为2的36次方等于687亿1947万6736

34
00:01:34,960 --> 00:01:35,000
。

35
00:01:35,120 --> 00:01:36,640
复杂度增长的太快，

36
00:01:36,640 --> 00:01:38,880
计算机也难以求解。

37
00:01:38,880 --> 00:01:40,880
那么我们该怎么办呢？

38
00:01:40,960 --> 00:01:43,520
有没有更快更巧妙的解法呢？

39
00:01:43,560 --> 00:01:45,240
细心的小伙伴会发现，

40
00:01:45,240 --> 00:01:46,240
无论什么局面。

41
00:01:46,440 --> 00:01:48,680
我们都能一行一行点击按钮，

42
00:01:48,680 --> 00:01:50,600
点亮尽可能多的灯，

43
00:01:50,680 --> 00:01:54,360
例如我们在第一行随机点击了几个按钮，

44
00:01:54,480 --> 00:01:56,960
此时第一行的灯有些是亮的，

45
00:01:56,960 --> 00:01:58,280
有些是暗的，

46
00:01:58,360 --> 00:02:00,200
为了让第一行的灯全亮，

47
00:02:00,200 --> 00:02:04,200
我们可以去按按的灯下方的第二行的对应按钮，

48
00:02:04,280 --> 00:02:07,120
这时候第二行的某些灯是暗的，

49
00:02:07,200 --> 00:02:10,280
因为按第二行的按钮会熄灭第一行的灯，

50
00:02:10,280 --> 00:02:12,360
我们要按第三行的按钮，

51
00:02:12,480 --> 00:02:13,720
重复这一步骤，

52
00:02:13,720 --> 00:02:16,080
直到按完最后一行的按钮。

53
00:02:16,240 --> 00:02:18,560
如果最后一行的灯恰好全亮了，

54
00:02:18,560 --> 00:02:21,000
那我们就找到了一种解法。

55
00:02:21,080 --> 00:02:22,880
这里仍有灯是暗的，

56
00:02:22,880 --> 00:02:25,000
因此不是正确解法。

57
00:02:25,040 --> 00:02:26,880
让我们换一种解法。

58
00:02:26,960 --> 00:02:30,400
这次让我们点击第一行的前两个按钮，

59
00:02:30,520 --> 00:02:31,360
经过递推，

60
00:02:31,440 --> 00:02:33,480
最后一行灯都被点亮了。

61
00:02:33,480 --> 00:02:34,040
因此，

62
00:02:34,080 --> 00:02:36,160
这就是一种正确解法。

63
00:02:36,280 --> 00:02:37,880
由于从第二行开始，

64
00:02:37,880 --> 00:02:40,760
每一行的按法都由上一行的灯确定，

65
00:02:40,760 --> 00:02:43,960
因此我们只需遍历第一行的所有按法，

66
00:02:43,960 --> 00:02:45,840
递推最后一行灯即可。

67
00:02:46,360 --> 00:02:48,160
通过这种行之间的关系，

68
00:02:48,160 --> 00:02:50,600
我们把随机性限制在第一行，

69
00:02:50,600 --> 00:02:53,520
使穷举量降到了2的n次方。

70
00:02:53,640 --> 00:02:57,440
这里我们在32种按法中找到了4种解法，

71
00:02:57,520 --> 00:03:00,600
这个方法的复杂度仍是指数级别的。

72
00:03:00,680 --> 00:03:03,680
那么有没有更快更精妙的解法呢？

73
00:03:03,840 --> 00:03:05,520
对于n乘n的格子来说，

74
00:03:05,640 --> 00:03:08,040
我们的基本操作只有n乘n种，

75
00:03:08,200 --> 00:03:10,880
也就是按或者不按某个按钮。

76
00:03:11,000 --> 00:03:12,320
对于某一特定的灯，

77
00:03:12,360 --> 00:03:15,360
只有周围几个按钮可以改变其状态。

78
00:03:15,520 --> 00:03:16,080
例如，

79
00:03:16,080 --> 00:03:20,360
位于左上角的灯只会被左上角的三个按钮影响，

80
00:03:20,440 --> 00:03:24,280
按多个按钮相当于把多种操作叠加起来。

81
00:03:24,320 --> 00:03:26,480
我们把这三个操作叠加起来，

82
00:03:26,480 --> 00:03:28,480
得到第一个灯的状态。

83
00:03:28,480 --> 00:03:30,800
有没有办法叠加多种操作后，

84
00:03:30,840 --> 00:03:32,320
只亮一个灯呢？

85
00:03:32,360 --> 00:03:34,760
如果每一个灯都可以单独点亮，

86
00:03:34,760 --> 00:03:37,520
那我们就能把这些操作都叠加起来，

87
00:03:37,520 --> 00:03:39,240
让所有灯全亮。

88
00:03:39,400 --> 00:03:42,280
现在让我们重新观察三乘三的格子，

89
00:03:42,360 --> 00:03:43,480
共有九种操作。

90
00:03:43,800 --> 00:03:46,080
标记为操作一到九，

91
00:03:46,160 --> 00:03:48,080
让我们观察第一个灯。

92
00:03:48,120 --> 00:03:49,600
这里操作一、

93
00:03:49,600 --> 00:03:52,160
操作二都翻转了第一个灯。

94
00:03:52,280 --> 00:03:55,320
现在我们把操作一叠加到操作二上，

95
00:03:55,440 --> 00:03:58,240
操作二就不会翻转第一个灯了。

96
00:03:58,320 --> 00:03:58,840
同样，

97
00:03:59,000 --> 00:04:01,080
操作四也会翻转第一个灯。

98
00:04:01,200 --> 00:04:04,360
我们也把操作一叠加到操作四上。

99
00:04:04,400 --> 00:04:05,240
如此一来，

100
00:04:05,240 --> 00:04:07,960
只有操作一能够翻转第一个灯。

101
00:04:08,040 --> 00:04:09,880
接着我们看第二个灯。

102
00:04:10,080 --> 00:04:10,800
同样的，

103
00:04:10,800 --> 00:04:14,560
在操作二到九中找到会翻转第二个灯的操作，

104
00:04:14,600 --> 00:04:16,640
把操作二叠加上去。

105
00:04:16,680 --> 00:04:19,520
这里由于操作二没有翻转第二个灯，

106
00:04:19,680 --> 00:04:22,800
我们就交换操作二和操作三的位置。

107
00:04:22,920 --> 00:04:26,880
然后我们把操作二叠加到操作四和操作五上，

108
00:04:26,960 --> 00:04:32,520
重复以上步骤就能确保操作n只能翻转第n到九个灯。

109
00:04:32,640 --> 00:04:35,400
由于操作九不能翻转第一到八个灯，

110
00:04:35,520 --> 00:04:36,960
只能翻转第九个灯。

111
00:04:37,240 --> 00:04:41,280
于是我们便发现了单独翻转第九个灯的操作，

112
00:04:41,280 --> 00:04:44,000
然后我们再回过来考察操作八。

113
00:04:44,000 --> 00:04:44,880
幸运的是，

114
00:04:44,880 --> 00:04:47,800
操作八可以单独翻转第八个灯。

115
00:04:47,880 --> 00:04:50,040
我们在观察操作七，

116
00:04:50,080 --> 00:04:54,120
操作七会同时翻转第七个灯和第九个灯。

117
00:04:54,160 --> 00:04:56,360
我们可以把操作九叠加上去，

118
00:04:56,360 --> 00:04:59,520
使操作七可以单独翻转第七个灯，

119
00:04:59,600 --> 00:05:02,440
让我们继续去叠加剩余的操作。

120
00:05:02,560 --> 00:05:03,120
最终，

121
00:05:03,120 --> 00:05:06,800
我们得到了全部单独翻转第一到第九个灯的操作。

122
00:05:07,400 --> 00:05:12,120
现在我们把这九个操作叠加起来就得到了游戏的解法，

123
00:05:12,200 --> 00:05:15,960
让我们再次重新观察这些三乘三的格子。

124
00:05:16,040 --> 00:05:16,680
事实上，

125
00:05:16,720 --> 00:05:20,120
我们可以将所有按钮和灯排列成一行。

126
00:05:20,240 --> 00:05:24,440
现在所有按钮和灯排列成九乘九的大矩阵，

127
00:05:24,520 --> 00:05:29,760
不难发现我们刚才的操作就是对这个矩阵进行高斯消元，

128
00:05:29,840 --> 00:05:32,960
通过把一行加到另一行或者交换两行，

129
00:05:33,040 --> 00:05:35,640
让矩阵变为上三角矩阵。

130
00:05:35,800 --> 00:05:39,320
然后再把形意推回去变为单位矩阵，

131
00:05:39,400 --> 00:05:43,640
最后再把所有行加起来就得到一组完整的解法。

132
00:05:43,720 --> 00:05:45,120
对于五乘五的格子，

133
00:05:45,160 --> 00:05:46,920
我们也可以这样操作。

134
00:05:47,000 --> 00:05:48,840
我们生成按钮和灯矩阵，

135
00:05:48,840 --> 00:05:51,120
然后对其进行消元。

136
00:05:51,160 --> 00:05:53,560
我们把25种操作叠加起来，

137
00:05:53,560 --> 00:05:55,960
这就是五乘五的一种解法。

138
00:05:56,040 --> 00:06:01,160
可以注意到消元后的矩阵最后两行灯矩阵的部分为空白。

139
00:06:01,320 --> 00:06:02,120
也就是说，

140
00:06:02,120 --> 00:06:04,560
这两组操作没有翻动任何灯，

141
00:06:04,560 --> 00:06:06,800
我们称之为静默操作。

142
00:06:06,800 --> 00:06:10,400
我们将其两两组合形成四种静默操作。

143
00:06:10,520 --> 00:06:12,640
由于静默操作不会改变灯，

144
00:06:12,800 --> 00:06:16,560
我们也可以把它们分别和刚才的解法叠加。

145
00:06:16,640 --> 00:06:20,560
这也就是刚才首行穷举法得到的四种解法。

146
00:06:20,680 --> 00:06:22,400
由于存在静默操作，

147
00:06:22,400 --> 00:06:25,800
至少有两种按法对应同一种灯的状态。

148
00:06:25,920 --> 00:06:26,560
因此，

149
00:06:26,560 --> 00:06:29,160
总会有一种灯的状态没法按出来，

150
00:06:29,160 --> 00:06:31,120
例如仅翻转第一个灯。

151
00:06:31,600 --> 00:06:33,360
按钮会影响周围的灯，

152
00:06:33,360 --> 00:06:36,680
同样灯也只会被附近的按钮翻转，

153
00:06:36,680 --> 00:06:40,800
因此灯的最终状态可以表示为若干个按钮的叠加，

154
00:06:40,800 --> 00:06:42,800
也就是全亮前者。

155
00:06:42,880 --> 00:06:45,360
我们对按钮和灯矩阵进行消元，

156
00:06:45,400 --> 00:06:48,120
相当于同时乘以逆矩阵。

157
00:06:48,240 --> 00:06:51,040
现在我们对灯向量做相同的操作，

158
00:06:51,080 --> 00:06:52,840
便获得了按钮的状态，

159
00:06:52,840 --> 00:06:54,320
也就是解法。

160
00:06:54,400 --> 00:06:57,760
由于灯向量是全亮矩阵和向量相乘，

161
00:06:57,760 --> 00:07:00,200
等同于把所有按法叠加。

162
00:07:00,360 --> 00:07:01,480
通过这个方法，

163
00:07:01,480 --> 00:07:03,240
我们无需求出逆矩阵，

164
00:07:03,240 --> 00:07:06,000
直接通过消元获得了解法，

165
00:07:06,000 --> 00:07:08,360
因为灯和按钮各有n乘n个，

166
00:07:08,360 --> 00:07:11,160
每一行都有n乘n个按钮叠加，

167
00:07:11,200 --> 00:07:16,560
因此该方法的复杂度为n乘n的三次方等于n的六次方，

168
00:07:16,600 --> 00:07:19,360
这个方法的复杂度是多项式级别的，

169
00:07:19,360 --> 00:07:22,040
但n乘n的矩阵仍然很大，

170
00:07:22,160 --> 00:07:22,480
那么。

171
00:07:22,620 --> 00:07:26,180
我们是否还能找到更快更巧妙的解法呢？

172
00:07:26,300 --> 00:07:30,740
刚才我们把按钮和灯当做整体叠加并为分行，

173
00:07:30,820 --> 00:07:33,020
然而从首行穷举法可知，

174
00:07:33,180 --> 00:07:36,860
只要确定第一行按钮就能推的最后一行灯，

175
00:07:37,020 --> 00:07:40,100
是否可以将叠加法和首行穷举法结合，

176
00:07:40,180 --> 00:07:43,540
用第一行按钮直接表示最后一行的灯呢？

177
00:07:43,660 --> 00:07:45,620
从首行穷举法可知，

178
00:07:45,620 --> 00:07:47,140
灯由周围的按钮确定，

179
00:07:47,300 --> 00:07:49,940
下一行的按钮则是灯的翻转。

180
00:07:50,100 --> 00:07:52,060
我们把一行的灯单独列出来，

181
00:07:52,060 --> 00:07:54,140
用按钮表示状态。

182
00:07:54,180 --> 00:07:58,620
例如这里左边第一行代表第一个灯由第二个按钮决定，

183
00:07:58,620 --> 00:08:02,060
旁边的蓝色方格代表按钮是灯的翻转。

184
00:08:02,140 --> 00:08:02,780
注意，

185
00:08:02,780 --> 00:08:04,980
两个状态先叠加再翻转，

186
00:08:04,980 --> 00:08:08,060
等价于先翻转其中一个再叠加。

187
00:08:08,060 --> 00:08:08,700
因此，

188
00:08:08,700 --> 00:08:11,740
我们可以将翻转的情况单独列出来。

189
00:08:11,780 --> 00:08:12,220
另外，

190
00:08:12,340 --> 00:08:14,500
如果某个按钮被叠加了两次，

191
00:08:14,500 --> 00:08:16,660
那就等同于没有叠加。

192
00:08:16,820 --> 00:08:17,340
同样，

193
00:08:17,340 --> 00:08:21,140
如果灯被翻转两次也等同于没有翻转，

194
00:08:21,140 --> 00:08:25,220
接着推倒第二行可由上一行按钮状态叠加确定，

195
00:08:25,220 --> 00:08:27,380
因为灯的翻转可以单独列出，

196
00:08:27,420 --> 00:08:30,180
也由灯的翻转状态叠加确定。

197
00:08:30,220 --> 00:08:35,940
这里分别表示第二行第一个按钮和灯分别为上一行的按钮或灯的叠加

198
00:08:35,940 --> 00:08:37,140
或翻转，

199
00:08:37,260 --> 00:08:39,380
接着推倒剩余的部分，

200
00:08:39,500 --> 00:08:43,140
于是我们可以由第一行按钮的状态开始不断推倒。

201
00:08:43,500 --> 00:08:47,420
得到最后一行灯是由第一行哪几个按钮叠加的？

202
00:08:47,500 --> 00:08:51,620
最后我们便得到了一种与叠加法类似的矩阵，

203
00:08:51,700 --> 00:08:55,100
只不过这一次灯和按钮都只有n个。

204
00:08:55,220 --> 00:08:57,940
由于在推导的过程中灯进行了翻转，

205
00:08:57,980 --> 00:09:01,460
因此最终灯向量也是翻转过的状态。

206
00:09:01,540 --> 00:09:05,100
现在我们对矩阵消元同时操作灯向量，

207
00:09:05,300 --> 00:09:07,860
最终得到第一行按钮的状态。

208
00:09:07,940 --> 00:09:12,380
可以注意到消元后的矩阵和之前25乘25的情况一样。

209
00:09:12,700 --> 00:09:14,660
最后两行为静默操作，

210
00:09:14,700 --> 00:09:18,540
而右边的灯向量就是解法求出静默操作，

211
00:09:18,540 --> 00:09:19,860
需要获得逆矩阵。

212
00:09:19,900 --> 00:09:22,900
有兴趣的小伙伴可以自己试一下。

213
00:09:22,900 --> 00:09:23,660
实际上，

214
00:09:23,660 --> 00:09:25,700
由于矩阵的高度对称性，

215
00:09:25,700 --> 00:09:29,220
这里的列向量和静默操作是相同的。

216
00:09:29,340 --> 00:09:30,220
不难看出，

217
00:09:30,220 --> 00:09:32,020
和刚才的叠加法一样，

218
00:09:32,020 --> 00:09:35,100
这次矩阵规模从n乘n变为了n，

219
00:09:35,420 --> 00:09:38,580
因此复杂度就是n的三次方。

220
00:09:38,740 --> 00:09:40,180
在首行叠加法中。

221
00:09:40,220 --> 00:09:43,660
需要得到第一按钮和最后一行灯关系矩阵。

222
00:09:43,660 --> 00:09:45,940
这个矩阵是需要推导生成的，

223
00:09:45,940 --> 00:09:49,820
并且不难看出其复杂度是n的三次方。

224
00:09:49,860 --> 00:09:52,020
我们将每一个灯都分开来推导，

225
00:09:52,260 --> 00:09:55,340
但实际上这些灯之间是有关联的。

226
00:09:55,460 --> 00:10:00,380
将矩阵重排后可以观察到这些矩阵有着高度的对称性。

227
00:10:00,500 --> 00:10:02,660
仔细观察这些矩阵可以发现，

228
00:10:02,660 --> 00:10:07,420
每个格子的上下左右四个格子的状态数量恰好是偶数个。

229
00:10:07,540 --> 00:10:09,980
由于最后一个矩阵才是我们需要的。

230
00:10:10,220 --> 00:10:10,780
因此，

231
00:10:10,780 --> 00:10:15,580
我们只需要知道最后一个矩阵的第一行就可以推得余下的。

232
00:10:15,620 --> 00:10:16,220
因此，

233
00:10:16,220 --> 00:10:20,300
我们只需要推到第一个灯的状态就可以得到所有灯的状态，

234
00:10:20,300 --> 00:10:22,220
从而减少复杂度。

235
00:10:22,260 --> 00:10:23,180
刚才我们发现，

236
00:10:23,300 --> 00:10:24,820
对于五乘五的格子，

237
00:10:24,820 --> 00:10:30,020
因为有两组静默操作和前面的解共同构成了四种解法。

238
00:10:30,020 --> 00:10:31,820
而对于三乘三的格子来说，

239
00:10:31,900 --> 00:10:33,460
由于没有静默操作，

240
00:10:33,460 --> 00:10:35,660
因此解法是唯一的。

241
00:10:35,820 --> 00:10:36,220
那么，

242
00:10:36,340 --> 00:10:38,180
对于n乘n的格子来说。

243
00:10:38,300 --> 00:10:41,380
最多可能有多少组静默操作呢？

244
00:10:41,460 --> 00:10:43,820
现在我们观察四乘四的格子，

245
00:10:43,860 --> 00:10:46,060
并用首行叠加法求解。

246
00:10:46,140 --> 00:10:47,700
这次我们意外的发现，

247
00:10:47,700 --> 00:10:49,500
所有的按钮都被抵消了。

248
00:10:49,500 --> 00:10:51,180
我们得到了一个零矩阵，

249
00:10:51,180 --> 00:10:55,420
也就是说四乘四的格子有四组独立的静默操作，

250
00:10:55,420 --> 00:10:57,380
叠加后就是十六种。

251
00:10:57,500 --> 00:11:00,100
由于第一行按钮的状态只有十六种，

252
00:11:00,100 --> 00:11:03,300
因此所有十六种都是静默操作。

253
00:11:03,380 --> 00:11:07,940
这里任意一种第一行按钮都能通过后三行消除所有灯。

254
00:11:08,460 --> 00:11:09,380
同时，

255
00:11:09,380 --> 00:11:12,620
16种静默操作也对应着16种解法。

256
00:11:12,660 --> 00:11:18,340
这里同样从任意一种第一行按钮也能通过后面三行点亮所有灯，

257
00:11:18,460 --> 00:11:22,460
因为n乘n格子第一行最多有2的n次方种状态，

258
00:11:22,500 --> 00:11:26,820
因此n乘n格子的解法最多为2的n次方种。

259
00:11:26,900 --> 00:11:30,700
这里列出了n等于1到n等于16的情况。

260
00:11:30,780 --> 00:11:35,100
这个序列被oeis收录到了a159257。

261
00:11:35,300 --> 00:11:39,260
关于这个矩阵的秩可以使用上述公式进行计算。

262
00:11:39,260 --> 00:11:41,180
刚才我们探讨了解的数量，

263
00:11:41,300 --> 00:11:44,260
但是没有证明解一定存在。

264
00:11:44,260 --> 00:11:48,420
那么对于普通的点灯游戏解是否一定存在呢？

265
00:11:48,500 --> 00:11:49,260
事实上，

266
00:11:49,260 --> 00:11:51,700
只要点灯游戏满足两个要求，

267
00:11:51,780 --> 00:11:53,580
那它就是可解的。

268
00:11:53,620 --> 00:11:56,300
这里的结论并不局限于方阵。

269
00:11:56,380 --> 00:11:57,180
事实上，

270
00:11:57,180 --> 00:12:01,220
任何形状和空间布局的点灯游戏都是可解的。

271
00:12:01,380 --> 00:12:03,300
如果格子没有连成整体，

272
00:12:03,300 --> 00:12:05,980
则分开的部分不会互相影响，

273
00:12:06,100 --> 00:12:09,580
因此我们只需要分别求解连起来的部分。

274
00:12:09,700 --> 00:12:15,540
下面让我用简单的方式使用数学归纳法来证明所有的点灯游戏都是可

275
00:12:15,540 --> 00:12:16,420
解的。

276
00:12:16,420 --> 00:12:20,860
首先让我们考虑只有一二三个按钮的情况，

277
00:12:20,980 --> 00:12:23,380
这里列举出了所有可能的布局，

278
00:12:23,380 --> 00:12:26,020
这些布局显然都是可解的。

279
00:12:26,140 --> 00:12:29,780
现在让我们把二乘二的格子分别去掉一个格子。

280
00:12:30,100 --> 00:12:32,500
得到四个三个按钮的格子，

281
00:12:32,580 --> 00:12:34,860
让我们求解这些三个按钮的格子，

282
00:12:34,860 --> 00:12:37,460
然后再将去除的格子补回来。

283
00:12:37,460 --> 00:12:41,020
如果任意一个补回来的格子周围的按钮数是奇数，

284
00:12:41,060 --> 00:12:42,780
它就会被点亮。

285
00:12:42,940 --> 00:12:46,340
那么这个解法就是四个按钮的解法。

286
00:12:46,460 --> 00:12:47,260
不幸的是，

287
00:12:47,260 --> 00:12:50,540
所有补回来的格子周围的按钮数都是偶数，

288
00:12:50,540 --> 00:12:53,900
因此所有这些格子都没有被点亮。

289
00:12:53,980 --> 00:12:57,820
现在让我们尝试把这四种状态叠加起来，

290
00:12:57,900 --> 00:12:58,620
可以看到。

291
00:12:58,660 --> 00:13:01,140
这次所有灯都被点亮了，

292
00:13:01,180 --> 00:13:04,420
这是因为有四种情况各翻转了三个灯，

293
00:13:04,500 --> 00:13:07,660
叠加后的四个灯就各翻转了三次。

294
00:13:07,740 --> 00:13:09,620
由于翻转次数是奇数，

295
00:13:09,660 --> 00:13:11,940
所有灯就都翻转了过来。

296
00:13:12,020 --> 00:13:14,460
这也就是二乘二的格子的解法。

297
00:13:14,460 --> 00:13:18,180
这个方法可以推广到任意偶数个按钮的游戏中。

298
00:13:18,260 --> 00:13:19,820
对于奇数个按钮的游戏，

299
00:13:19,940 --> 00:13:21,580
我们又该怎么办呢？

300
00:13:21,660 --> 00:13:23,620
让我们考虑三乘三的格子，

301
00:13:23,660 --> 00:13:28,380
并假定我们知道所有八个按钮游戏的解法和刚才一样。

302
00:13:28,500 --> 00:13:30,660
我们分别去掉了一个格子求解，

303
00:13:30,660 --> 00:13:31,900
再补回来。

304
00:13:32,020 --> 00:13:35,940
这里的九种情况恰好补回来的格子也都没有亮。

305
00:13:36,020 --> 00:13:37,980
我们把它们叠加起来，

306
00:13:38,100 --> 00:13:40,060
由于每个灯翻转了偶数次，

307
00:13:40,060 --> 00:13:42,500
因此所有灯都是暗的。

308
00:13:42,500 --> 00:13:43,820
为了解决这个问题，

309
00:13:43,860 --> 00:13:45,860
我们可以先点击中间的按钮，

310
00:13:45,860 --> 00:13:47,420
翻转五个灯，

311
00:13:47,500 --> 00:13:50,660
然后我们再依次叠加四个角的按法。

312
00:13:50,780 --> 00:13:53,260
现在所有灯都被翻转了。

313
00:13:53,420 --> 00:13:59,020
这是因为四个小答案法相当于先翻转所有灯再翻转单个灯，

314
00:13:59,060 --> 00:14:00,500
由于翻转了偶数次，

315
00:14:00,500 --> 00:14:03,460
因此相当于单独翻转了四个灯。

316
00:14:03,540 --> 00:14:04,380
如此一来，

317
00:14:04,380 --> 00:14:07,260
我们恰好补足了刚才没有翻的偶数个灯，

318
00:14:07,260 --> 00:14:09,260
也就把所有灯点亮了。

319
00:14:09,340 --> 00:14:10,300
不难证明，

320
00:14:10,300 --> 00:14:14,220
所有的点灯游戏总有一种操作可以翻转奇数个灯，

321
00:14:14,460 --> 00:14:19,260
因此我们可以用这种办法求解奇数个按钮的点灯游戏。

322
00:14:19,420 --> 00:14:20,060
由此，

323
00:14:20,060 --> 00:14:21,180
我们便证明了。

324
00:14:21,260 --> 00:14:23,500
对于任意按钮数量的点灯游戏，

325
00:14:23,540 --> 00:14:25,380
我们总能找到解法。

326
00:14:25,460 --> 00:14:26,140
事实上，

327
00:14:26,140 --> 00:14:28,780
这个证明可以用形式语言表达。

328
00:14:28,900 --> 00:14:29,540
同时，

329
00:14:29,540 --> 00:14:32,060
这个证明和图论息息相关。

330
00:14:32,180 --> 00:14:33,860
为了寻找更快的解法，

331
00:14:33,900 --> 00:14:36,980
我们可以尝试从这些方向思考问题。

332
00:14:37,060 --> 00:14:38,860
由于UP主能力有限，

333
00:14:38,900 --> 00:14:41,380
有更好的想法或实现思路的朋友，

334
00:14:41,500 --> 00:14:43,700
欢迎在评论区留言交流。

