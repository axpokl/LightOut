00:00:00.000 1.004625 0.538915 反向消元法
00:00:01.400 0.721050 0.408269 在刚才的《首行求逆法》中，我们有这些公式。
00:00:02.000 0.715350 0.408269 现在，我们定义多项式q'(x)，满足q'(x)*p(x)=g(x) mod f(x)。
00:00:02.000 0.684000 0.408269 现在，我们定义多项式q'(x)，满足q'(x)*p(x)=g(x) mod f(x)。
00:00:02.600 0.709650 0.408269 其中，g(x)也就是刚才提到的最大公因子，q'(x)就是刚才求得的q(x)。
00:00:02.600 0.689700 0.408269 其中，g(x)也就是刚才提到的最大公因子，q'(x)就是刚才求得的q(x)。
00:00:03.200 0.715350 0.408269 由于原本求得的x已不是最终解而是部分解，我们将其重命名为z，即z=q'(H)*y。
00:00:03.200 0.715350 0.408269 由于原本求得的x已不是最终解而是部分解，我们将其重命名为z，即z=q'(H)*y。
00:00:03.800 0.715350 0.408269 同时，我们定义q'(x)的逆多项式p'(x)，即q'(x)*p'(x)=1 mod f(x)。
00:00:03.800 0.661200 0.408269 同时，我们定义q'(x)的逆多项式p'(x)，即q'(x)*p'(x)=1 mod f(x)。
00:00:04.400 0.678300 0.408269 我们不难推出以下结论。为了方便表示，我将mod f(x)的部分省去。
00:00:04.400 0.712500 0.408269 我们不难推出以下结论。为了方便表示，我将mod f(x)的部分省去。
00:00:05.000 0.709650 0.408269 整理后，我们可以得到这些式子。
00:00:05.600 0.712500 0.408269 这里，如果g(x)=1，则会有以上式子。
00:00:06.200 0.709650 0.408269 刚才使用的扩展欧几里得法中，我们已求得q'(x)和g(x)。因此，接下来只需要使用g(x)和z求得x即可。
00:00:06.200 0.712500 0.408269 刚才使用的扩展欧几里得法中，我们已求得q'(x)和g(x)。因此，接下来只需要使用g(x)和z求得x即可。
00:00:06.800 0.715350 0.408269 前者，我们有公式z=q'(H)y。我们不断把y和H叠加，然后利用向量乘以矩阵的方式求得z。
00:00:06.800 0.712500 0.408269 前者，我们有公式z=q'(H)y。我们不断把y和H叠加，然后利用向量乘以矩阵的方式求得z。
00:00:07.400 0.709650 0.408269 现在，我们有公式z=g(H)x。由于需要求得的是x，需要用反向叠加的方式来求得。
00:00:07.400 0.712500 0.408269 现在，我们有公式z=g(H)x。由于需要求得的是x，需要用反向叠加的方式来求得。
00:00:08.000 0.712500 0.408269 以n=5为例，我们首先需要使用类似生成B矩阵的方法，生成g(H)，记为矩阵D。
00:00:08.000 0.709650 0.408269 以n=5为例，我们首先需要使用类似生成B矩阵的方法，生成g(H)，记为矩阵D。
00:00:08.600 0.715350 0.408269 1. 创建n个单位向量，也就是D矩阵的第一行。这里和B矩阵相同，一共有n个向量。
00:00:08.600 0.712500 0.408269 1. 创建n个单位向量，也就是D矩阵的第一行。这里和B矩阵相同，一共有n个向量。
00:00:09.200 0.715350 0.408269 2. 使用H矩阵，将每个D矩阵第一行扩散到下面的行。
00:00:09.800 0.715350 0.408269 3. 根据多项式g(x)，将每个D矩阵的对应行叠加起来，叠加完的行共同构成一个新的D矩阵。
00:00:09.800 0.684000 0.408269 3. 根据多项式g(x)，将每个D矩阵的对应行叠加起来，叠加完的行共同构成一个新的D矩阵。
00:00:10.400 0.715350 0.408269 可以发现，这里的步骤和首行叠加法类似，共有n个矩阵要生成，时间复杂度是O(n^3)。
00:00:10.400 0.715350 0.408269 可以发现，这里的步骤和首行叠加法类似，共有n个矩阵要生成，时间复杂度是O(n^3)。
00:00:11.000 0.715350 0.408269 不过，聪明的你一定能猜到，通过《生成矩阵法》调换矩阵的行以后，这些矩阵也都满足十字偶校验约束。
00:00:11.000 0.721050 0.408269 不过，聪明的你一定能猜到，通过《生成矩阵法》调换矩阵的行以后，这些矩阵也都满足十字偶校验约束。
00:00:11.600 0.715350 0.408269 因此。我们同样只需要生成第一个矩阵，然后递推就行。
00:00:12.200 0.712500 0.408269 生成第一个矩阵的过程中，每行乘以H矩阵的结果，就是刚才的K矩阵。
00:00:12.200 0.715350 0.408269 生成第一个矩阵的过程中，每行乘以H矩阵的结果，就是刚才的K矩阵。
00:00:12.800 0.712500 0.408269 因此，只需要将g(x)和K直接相乘，即可得到第一个矩阵的最后一行，即D矩阵的第一行。
00:00:12.800 0.715350 0.408269 因此，只需要将g(x)和K直接相乘，即可得到第一个矩阵的最后一行，即D矩阵的第一行。
00:00:13.400 0.712500 0.408269 然后，我们就可以使用十字偶校验约束的递推关系，求得之后的行。
00:00:13.400 0.681150 0.408269 然后，我们就可以使用十字偶校验约束的递推关系，求得之后的行。
00:00:14.000 0.709650 0.408269 由于D矩阵是由H矩阵生成的，D矩阵有这些性质。这里，r'=n-r=deg(g(x))。
00:00:14.000 0.706800 0.408269 由于D矩阵是由H矩阵生成的，D矩阵有这些性质。这里，r'=n-r=deg(g(x))。
00:00:14.600 0.715350 0.408269 1. 后r行，第n行最左边的n-r'-1个元素为0。
00:00:15.200 0.715350 0.408269 2. 后r行，第n行第n-r'的元素为1。
00:00:15.800 0.715350 0.408269 3. 后r行，线性无关，即任意一行都不能由别的行叠加。
00:00:16.400 0.715350 0.408269 4. 前r'行，任意一行都可以由后r行叠加。
00:00:17.000 0.706800 0.408269 这些性质都不难证明。由于视频时长有限，有兴趣的观众朋友可以自行证明。
00:00:17.000 0.684000 0.408269 这些性质都不难证明。由于视频时长有限，有兴趣的观众朋友可以自行证明。
00:00:17.600 0.709650 0.408269 现在，我们有z=D*x=g(H)x
00:00:18.200 0.715350 0.408269 接下来，我们只需要将Z拆解成不同D行的叠加，就能表式出x。
00:00:18.800 0.715350 0.408269 由于D矩阵后r行线性无关，因此我们只需要将后r行叠加起来即可。
00:00:19.400 0.715350 0.408269 又由于后r行，从第j-r'列开始的元素才为1，为了保证z的第i个元素消去，我们可以唯一选定D的第i+r'行来叠加。
00:00:19.400 0.715350 0.408269 又由于后r行，从第j-r'列开始的元素才为1，为了保证z的第i个元素消去，我们可以唯一选定D的第i+r'行来叠加。
00:00:20.000 0.715350 0.408269 又因为只有这一行的第(i+r')-r'=i列的元素为1，其余后面的行的这一列的元素都为0，因而无法消去z的第i个元素。
00:00:20.000 0.715350 0.408269 又因为只有这一行的第(i+r')-r'=i列的元素为1，其余后面的行的这一列的元素都为0，因而无法消去z的第i个元素。
00:00:20.600 0.715350 0.408269 由此，我们通过依次叠加D的后r行，将z的元素依次消去。同时，将消去的i标记为1，也就是最终的x。
00:00:20.600 0.712500 0.408269 由此，我们通过依次叠加D的后r行，将z的元素依次消去。同时，将消去的i标记为1，也就是最终的x。
00:00:21.200 0.715350 0.408269 当然，不难发现这里求得的x是一个特解。
00:00:21.800 0.715350 0.408269 由于前r'行可以表示为后r行的线性叠加，因此我们可以在操作y之前，先将其和前r'的任意行叠加，然后再求解。
00:00:21.800 0.715350 0.408269 由于前r'行可以表示为后r行的线性叠加，因此我们可以在操作y之前，先将其和前r'的任意行叠加，然后再求解。
00:00:22.400 0.715350 0.408269 由于前r'行共有2^r'种，因此求得的解也有2^r'种。
00:00:23.000 0.712500 0.408269 另一方面，由于D矩阵满足十字偶校验约束，其表现出高度的对称性。其中，行和列的坐标可以互换。
00:00:23.000 0.715350 0.408269 另一方面，由于D矩阵满足十字偶校验约束，其表现出高度的对称性。其中，行和列的坐标可以互换。
00:00:23.600 0.715350 0.408269 因此，我们可以同样只叠加前r行，从右往左进行消元。由于效果是相同的，这里不再赘述。
00:00:23.600 0.715350 0.408269 因此，我们可以同样只叠加前r行，从右往左进行消元。由于效果是相同的，这里不再赘述。
00:00:24.200 0.709650 0.408269 最终，我们通过欧几里得法和反向消元法。完成了Bx=y的求解，实现了点灯游戏在O(n^2)时间复杂度的算法。
00:00:24.200 0.715350 0.408269 最终，我们通过欧几里得法和反向消元法。完成了Bx=y的求解，实现了点灯游戏在O(n^2)时间复杂度的算法。
00:00:24.800 0.712500 0.408269 细心的观众会发现，其实这两个式子有相同的形式。
00:00:25.400 0.712500 0.408269 既然我们可以在第二个式子用反向消元法求x，为什么不能用相同的方法在第一个式子求x呢？
00:00:25.400 0.681150 0.408269 既然我们可以在第二个式子用反向消元法求x，为什么不能用相同的方法在第一个式子求x呢？
00:00:26.000 0.715350 0.408269 事实上，这种方法求得的x并不正确。
00:00:26.600 0.709650 0.408269 这因为这里的D矩阵是由g(H)生成的，具有满足带状上三角的可回代结构，即上述的四个性质。
00:00:26.600 0.712500 0.408269 这因为这里的D矩阵是由g(H)生成的，具有满足带状上三角的可回代结构，即上述的四个性质。
00:00:27.200 0.712500 0.408269 而B=p'(H)D破坏了这一结构，不满足这些性质。
00:00:27.800 0.715350 0.408269 不过，当g=1时，这个种解法是可行的。尽管这个办法首先需要求出完整的B矩阵。
00:00:27.800 0.684000 0.408269 不过，当g=1时，这个种解法是可行的。尽管这个办法首先需要求出完整的B矩阵。
00:00:28.400 0.715350 0.408269 同时，因为B矩阵不是三角结构，还需标记每行首个i的位置来选择。因此，直接计算q(H)*Y会更加方便。
00:00:28.400 0.715350 0.408269 同时，因为B矩阵不是三角结构，还需标记每行首个i的位置来选择。因此，直接计算q(H)*Y会更加方便。
00:00:29.300 0.681150 0.538915 算法总结
00:00:30.700 0.383147 0.183721 输出
00:00:30.700 0.383147 0.183721 输入
00:00:30.700 0.379941 0.183721 说明
00:00:30.700 0.383147 0.183721 算法
00:00:30.700 0.371925 0.183721 公式
00:00:30.700 0.182756 0.183721 <cL>L
00:00:30.700 0.383147 0.183721 <cL>灯矩阵第一行
00:00:30.700 0.376734 0.183721 <cL>公式递推
00:00:30.700 0.237263 0.183721 <cL><cL>L(n,x)=L(n-1,x-1)⊕L(n-1,x)⊕L(n-1,x+1)⊕L(n-2,x)
00:00:30.700 0.182756 0.183721 <cB>B
00:00:30.700 0.383147 0.183721 <cB>按钮矩阵第一行
00:00:30.700 0.376734 0.183721 <cB>公式递推
00:00:30.700 0.237263 0.183721 <cB><cB>B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:00:30.700 0.274134 0.183721 <cY>Y
00:00:30.700 0.383147 0.183721 <cY>灯矩阵最后一行
00:00:30.700 0.376734 0.183721 <cY>公式递推...
00:00:30.700 0.266119 0.183721 <cY><cY>Y(n,y)=~(Y(n-1,y-1)⊕Y(n-1,y)⊕Y(n-1,y+1)⊕Y(n-2,y))
00:00:30.700 0.274134 0.183721 <cH>H
00:00:30.700 0.383147 0.183721 <cH>邻接矩阵
00:00:30.700 0.376734 0.183721 <cH>公式递推
00:00:30.700 0.399178 0.183721 <cH><cH>H(y,x)=(∣x-y∣=1)
00:00:30.700 0.274134 0.183721 <cK>K
00:00:30.700 0.274134 0.183721 <cK><cH>H
00:00:30.700 0.260775 0.183721 <cK>H^n第一行（Krylov扩散基矩阵）
00:00:30.700 0.376734 0.183721 <cK>公式递推
00:00:30.700 0.355894 0.183721 <cK><cK>K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)
00:00:30.700 0.274134 0.183721 <cF>F
00:00:30.700 0.274134 0.183721 <cF><cK>K
00:00:30.700 0.391163 0.183721 <cF>K的逆矩阵（Krylov解耦矩阵）
00:00:30.700 0.376734 0.183721 <cF>公式递推
00:00:30.700 0.355894 0.183721 <cF><cF>F(n,x)=F(n-1,x-1)⊕F(n-2,x)
00:00:30.700 0.280547 0.183721 <cC>C
00:00:30.700 0.182756 0.183721 <cC><cB>B
00:00:30.700 0.378338 0.183721 <cC>B关于H的系数矩阵
00:00:30.700 0.376734 0.183721 <cC>公式递推
00:00:30.700 0.355894 0.183721 <cC><cC>C(n,x)=C(n-1,x-1)⊕C(n-1,x)⊕C(n-2,x)
00:00:30.700 0.274134 0.183721 <cP>P
00:00:30.700 0.317419 0.183721 <cP><cF>F<cP>,<cB>b
00:00:30.700 0.386353 0.183721 <cP>多项式p(H)的系数
00:00:30.700 0.378338 0.183721 <cP>矩阵向量乘法
00:00:30.700 0.333450 0.183721 <cP><cP>p=<cF>F<cB>b
00:00:30.700 0.298181 0.183721 <cQ>Q
00:00:30.700 0.333450 0.183721 <cQ><cF>F<cQ>,<cP>p
00:00:30.700 0.387956 0.183721 <cQ>多项式p(x)的在f(x)下的逆
00:00:30.700 0.379941 0.183721 <cQ>扩展欧几里得
00:00:30.700 0.381544 0.183721 <cQ><cQ>q=<cP>p^-1<cQ> mod <cF>F
00:00:30.700 0.280547 0.183721 <cG>G
00:00:30.700 0.317419 0.183721 <cG><cF>F<cG>,<cP>P
00:00:30.700 0.257569 0.183721 <cG>多项式p(x)和q(x)最大共因子
00:00:30.700 0.379941 0.183721 <cG>扩展欧几里得
00:00:30.700 0.371925 0.183721 <cG><cG>g=gcd(<cF>f<cG>,<cC>c<cG>)=gcd(<cF>f<cG>,<cP>p<cG>)
00:00:30.700 0.274134 0.183721 <cZ>Z
00:00:30.700 0.336656 0.183721 <cZ><cQ>Q<cZ>,<cY>y
00:00:30.700 0.381544 0.183721 <cZ>部分逆按钮解
00:00:30.700 0.378338 0.183721 <cZ>矩阵向量乘法
00:00:30.700 0.336656 0.183721 <cZ><cZ>z=<cQ>Q<cY>y
00:00:30.700 0.274134 0.183721 <cD>D
00:00:30.700 0.333450 0.183721 <cD><cK>K<cD>,<cG>g
00:00:30.700 0.387956 0.183721 <cD>多项式g(x)的矩阵
00:00:30.700 0.378338 0.183721 <cD>矩阵向量乘法
00:00:30.700 0.333450 0.183721 <cD><cD>d=<cK>K<cG>g
00:00:30.700 0.274134 0.183721 <cX>X
00:00:30.700 0.317419 0.183721 <cX><cD>D<cX>,<cZ>z
00:00:30.700 0.383147 0.183721 <cX>最终首行按钮解
00:00:30.700 0.381544 0.183721 <cX>前向异或消元
00:00:30.700 0.274134 0.183721 <cX><cZ>z=<cD>D<cX>x
00:00:30.700 0.274134 0.183721 <cT>T
00:00:30.700 0.179550 0.183721 <cT><cX>x
00:00:30.700 0.381544 0.183721 <cT>最终按钮解矩阵
00:00:30.700 0.376734 0.183721 <cT>公式递推
00:00:30.700 0.355894 0.183721 <cT><cT>T(n,x)=T(n-1,x-1)⊕T(n-1,x)⊕T(n-1,x+1)⊕T(n-2,x)
00:00:33.600 0.681150 0.538915 更快的算法
00:00:35.000 0.476900 0.408269 向量和矩阵的乘法，欧几里得算法，以及K矩阵的生成，理论上通过卷积，FFT或牛顿迭代法是有可能优化到O(n*log(n))的。
00:00:35.000 0.473100 0.408269 向量和矩阵的乘法，欧几里得算法，以及K矩阵的生成，理论上通过卷积，FFT或牛顿迭代法是有可能优化到O(n*log(n))的。
00:00:37.600 0.480700 0.408269 考虑到UP主《信号与系统》、《数字信号处理》、《数值分析》等课程较差，暂时就不研究了。有兴趣的小伙伴可自行研究并留言。
00:00:37.600 0.454100 0.408269 考虑到UP主《信号与系统》、《数字信号处理》、《数值分析》等课程较差，暂时就不研究了。有兴趣的小伙伴可自行研究并留言。
00:00:40.200 0.476900 0.408269 如果对视频中的内容有疑问，觉得视频内容表述不清，或者发现视频中的任何错误，也请大家多多留言和指证。谢谢大家观看！
00:00:40.200 0.475000 0.408269 如果对视频中的内容有疑问，觉得视频内容表述不清，或者发现视频中的任何错误，也请大家多多留言和指证。谢谢大家观看！
