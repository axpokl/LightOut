00:00:00.000 0.837791 0.538915 点灯游戏的$O(n^2)$解法
00:00:01.700 0.681150 0.538915 首行叠加法（续上集）
00:00:03.100 0.721050 0.408269 在上集视频的《首行叠加法》中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。
00:00:03.100 0.475000 0.408269 在上集视频的《首行叠加法》中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。
00:00:03.400 0.421800 0.326615 <cB>B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:00:03.700 0.463600 0.326615 <cB>B按钮    <cL>L灯    <cH1>⊕叠加    <cH2>~翻转
00:00:08.300 0.486400 0.408269 我们用B代表按钮，L代表灯，⊕（加）代表叠加，~（非）代表翻转。
00:00:08.733 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:08.733 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:08.733 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:08.733 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:08.733 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:08.767 0.399000 0.130646 y1
00:00:08.800 0.328700 0.130646 n1
00:00:08.967 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:08.967 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:08.967 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:08.967 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:08.967 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:09.000 0.402810 0.130646 y2
00:00:09.033 0.328700 0.130646 n1
00:00:09.200 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.200 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:09.200 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:09.200 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.200 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:09.233 0.402785 0.130646 y3
00:00:09.267 0.328700 0.130646 n1
00:00:09.433 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.433 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:09.433 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:09.433 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.433 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:09.467 0.399000 0.130646 y4
00:00:09.500 0.328700 0.130646 n1
00:00:09.667 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.667 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:09.667 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:09.667 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.667 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:09.700 0.393300 0.130646 y5
00:00:09.733 0.328700 0.130646 n1
00:00:09.900 0.332510 0.130646 n2
00:00:10.067 0.332510 0.130646 n2
00:00:10.233 0.332510 0.130646 n2
00:00:10.400 0.332510 0.130646 n2
00:00:10.567 0.332510 0.130646 n2
00:00:10.733 0.336270 0.130646 n3
00:00:10.900 0.336270 0.130646 n3
00:00:11.067 0.336270 0.130646 n3
00:00:11.233 0.336270 0.130646 n3
00:00:11.400 0.336270 0.130646 n3
00:00:11.567 0.328700 0.130646 n4
00:00:11.733 0.328700 0.130646 n4
00:00:11.900 0.328700 0.130646 n4
00:00:12.067 0.328700 0.130646 n4
00:00:12.233 0.328700 0.130646 n4
00:00:12.400 0.328712 0.130646 n5
00:00:12.567 0.328712 0.130646 n5
00:00:12.733 0.328712 0.130646 n5
00:00:12.900 0.328712 0.130646 n5
00:00:13.067 0.328712 0.130646 n5
00:00:13.400 0.454100 0.408269 n代表从上到下第n行灯或按钮。因为我们是一行行进行推导的，n也代表第n次推导。
00:00:13.400 0.476900 0.408269 n代表从上到下第n行灯或按钮。因为我们是一行行进行推导的，n也代表第n次推导。
00:00:18.600 0.454100 0.408269 x代表从左到右第x列按钮。将灯表示为第一行的某几个列的按钮的叠加。这里的x不局限于第一行。
00:00:18.600 0.454100 0.408269 x代表从左到右第x列按钮。将灯表示为第一行的某几个列的按钮的叠加。这里的x不局限于第一行。
00:00:23.800 0.461700 0.408269 y代表从左到右第y列灯。这里的公式对任意第y个灯都满足，所以省去了y。
00:00:23.800 0.475000 0.408269 y代表从左到右第y列灯。这里的公式对任意第y个灯都满足，所以省去了y。
00:00:29.000 0.475000 0.408269 在这里，粉色原点是用按钮表示按钮，淡蓝色方块是用按钮表示灯。
00:00:36.800 0.712500 0.408269 而在上集视频中，因为最终目标是将灯用按钮表示，因此省去了按钮表示按钮，粉色原点直接为按钮表示灯。
00:00:36.800 0.475000 0.408269 而在上集视频中，因为最终目标是将灯用按钮表示，因此省去了按钮表示按钮，粉色原点直接为按钮表示灯。
00:00:44.100 0.452200 0.408269 让我们举一个具体的例子。在5x5的格子中，我们将灯和按钮编号为1-25。
00:00:44.100 0.475000 0.408269 让我们举一个具体的例子。在5x5的格子中，我们将灯和按钮编号为1-25。
00:00:47.300 0.721050 0.408269 在《叠加法》中，我们将灯表示为所有按钮的叠加。例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
00:00:47.300 0.475000 0.408269 在《叠加法》中，我们将灯表示为所有按钮的叠加。例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
00:01:00.033 0.454100 0.408269 通过这种方式我们得到了25元一次方程组。写成增广矩阵，也就是按钮矩阵加灯向量的形式。
00:01:00.033 0.476900 0.408269 通过这种方式我们得到了25元一次方程组。写成增广矩阵，也就是按钮矩阵加灯向量的形式。
00:01:08.133 0.721050 0.408269 而在《首行叠加法》中，我们需要把灯表示为第一行按钮的叠加。
00:01:08.500 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.500 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:08.500 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:08.500 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.500 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:08.533 0.328700 0.130646 L1
00:01:08.567 0.326800 0.130646 1
00:01:08.667 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.667 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:08.667 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:08.667 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.667 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:08.700 0.332510 0.130646 L2
00:01:08.733 0.330610 0.130646 2
00:01:08.833 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.833 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:08.833 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:08.833 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.833 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:08.867 0.336270 0.130646 L3
00:01:08.900 0.336270 0.130646 3
00:01:09.000 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:09.000 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:09.000 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:09.000 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:09.000 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:09.033 0.328700 0.130646 L4
00:01:09.067 0.326800 0.130646 4
00:01:09.167 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:09.167 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:09.167 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:09.167 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:09.167 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:09.200 0.330612 0.130646 L5
00:01:09.233 0.328712 0.130646 5
00:01:09.333 0.334414 0.130646 6
00:01:09.433 0.321100 0.130646 7
00:01:09.533 0.332500 0.130646 8
00:01:09.633 0.334400 0.130646 9
00:01:09.733 0.335358 0.130646 10
00:01:09.833 0.326800 0.130646 11
00:01:09.933 0.330610 0.130646 12
00:01:10.033 0.336270 0.130646 13
00:01:10.133 0.326800 0.130646 14
00:01:10.233 0.334412 0.130646 15
00:01:10.333 0.334414 0.130646 16
00:01:10.433 0.326800 0.130646 17
00:01:10.533 0.332500 0.130646 18
00:01:10.633 0.334400 0.130646 19
00:01:10.733 0.337267 0.130646 20
00:01:10.833 0.330610 0.130646 21
00:01:10.933 0.330610 0.130646 22
00:01:11.033 0.336295 0.130646 23
00:01:11.133 0.330610 0.130646 24
00:01:11.233 0.338221 0.130646 25
00:01:11.567 0.475000 0.408269 这里的五个矩阵，分别代表第y列是由第一行的哪几个按钮叠加的。
00:01:11.567 0.463600 0.408269 这里的五个矩阵，分别代表第y列是由第一行的哪几个按钮叠加的。
00:01:16.167 0.476900 0.408269 由于按法是动态的，当第二行按钮还未被按下时，L1=B1⊕B2，即第一个灯L1由第一行的一、二个按钮，即B1,B2叠加的。
00:01:16.167 0.476900 0.408269 由于按法是动态的，当第二行按钮还未被按下时，L1=B1⊕B2，即第一个灯L1由第一行的一、二个按钮，即B1,B2叠加的。
00:01:21.367 0.486400 0.408269 然后，B6=~L1=~(B1⊕B2)，即第六个按钮B6是第一个灯L1的翻转。因此，第二行按钮B6和第一行灯L1的叠加状态是相同的。
00:01:21.367 0.476900 0.408269 然后，B6=~L1=~(B1⊕B2)，即第六个按钮B6是第一个灯L1的翻转。因此，第二行按钮B6和第一行灯L1的叠加状态是相同的。
00:01:26.567 0.475000 0.408269 旁边的向量，代表的是按钮或灯有没有翻转。
00:01:31.467 0.476900 0.408269 例如，当第一个向量的第一个灯亮起时，表示第一个灯除了由刚才说的按钮叠加外，还需要再翻转才是正确的状态。
00:01:31.467 0.476900 0.408269 例如，当第一个向量的第一个灯亮起时，表示第一个灯除了由刚才说的按钮叠加外，还需要再翻转才是正确的状态。
00:01:36.067 0.486400 0.408269 同理，B7=~L2=~(B1⊕B2⊕B3)，即第七个按钮B6是第二个灯L2的翻转。同样，第二行的按钮B7和第一行灯L2的叠加状态是相同的。
00:01:36.067 0.476900 0.408269 同理，B7=~L2=~(B1⊕B2⊕B3)，即第七个按钮B6是第二个灯L2的翻转。同样，第二行的按钮B7和第一行灯L2的叠加状态是相同的。
00:01:42.767 0.475000 0.408269 这里，我们将第一个按钮B1的状态补全，将B1用第一行的按钮叠加时，有B1=B1。
00:01:42.767 0.476900 0.408269 这里，我们将第一个按钮B1的状态补全，将B1用第一行的按钮叠加时，有B1=B1。
00:01:47.667 0.452200 0.408269 接下来我们来看第六个灯。L6=B1⊕B6⊕B7=B1⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)=B1⊕B3。
00:01:47.667 0.448400 0.408269 接下来我们来看第六个灯。L6=B1⊕B6⊕B7=B1⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)=B1⊕B3。
00:01:58.467 0.475000 0.408269 又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)⊕~(B2⊕B3⊕B4)=~B4
00:01:58.467 0.448400 0.408269 又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)⊕~(B2⊕B3⊕B4)=~B4
00:02:15.567 0.475000 0.408269 这样不断递推，我们可以将任意L表示为某些B1到B5的叠加，再加上翻转。
00:02:24.967 0.475000 0.408269 现在，如果我们把序号1-25用坐标x,y表示，则灯和按钮矩阵可写为上述公式。让我们以L7(2)=L(2,2,2)为例。
00:02:24.967 0.454100 0.408269 现在，如果我们把序号1-25用坐标x,y表示，则灯和按钮矩阵可写为上述公式。让我们以L7(2)=L(2,2,2)为例。
00:02:25.267 0.440800 0.326615 <cL>L(n,x,y)=<cB>B(n,x,y-1)⊕B(n,x,y)⊕B(n,x,y+1)⊕B(n-1,x,y)
00:02:25.567 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.567 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:25.567 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:25.567 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.567 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:25.600 0.399000 0.130646 y1
00:02:25.633 0.328700 0.130646 n1
00:02:25.667 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.667 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:25.667 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:25.667 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.667 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:25.700 0.402810 0.130646 y2
00:02:25.733 0.328700 0.130646 n1
00:02:25.767 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.767 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:25.767 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:25.767 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.767 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:25.800 0.402785 0.130646 y3
00:02:25.833 0.328700 0.130646 n1
00:02:25.867 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.867 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:25.867 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:25.867 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.867 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:25.900 0.399000 0.130646 y4
00:02:25.933 0.328700 0.130646 n1
00:02:25.967 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.967 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:25.967 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:25.967 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:25.967 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:26.000 0.393300 0.130646 y5
00:02:26.033 0.328700 0.130646 n1
00:02:26.067 0.332510 0.130646 n2
00:02:26.100 0.332510 0.130646 n2
00:02:26.133 0.332510 0.130646 n2
00:02:26.167 0.332510 0.130646 n2
00:02:26.200 0.332510 0.130646 n2
00:02:26.233 0.336270 0.130646 n3
00:02:26.267 0.336270 0.130646 n3
00:02:26.300 0.336270 0.130646 n3
00:02:26.333 0.336270 0.130646 n3
00:02:26.367 0.336270 0.130646 n3
00:02:26.400 0.328700 0.130646 n4
00:02:26.433 0.328700 0.130646 n4
00:02:26.467 0.328700 0.130646 n4
00:02:26.500 0.328700 0.130646 n4
00:02:26.533 0.328700 0.130646 n4
00:02:26.567 0.328712 0.130646 n5
00:02:26.600 0.328712 0.130646 n5
00:02:26.633 0.328712 0.130646 n5
00:02:26.667 0.328712 0.130646 n5
00:02:26.700 0.328712 0.130646 n5
00:02:31.433 0.475000 0.408269 这里，我们的矩阵同时满足另一个性质，称之为十字偶校验约束。
00:02:31.433 0.452200 0.408269 这里，我们的矩阵同时满足另一个性质，称之为十字偶校验约束。
00:02:31.733 0.440800 0.326615 <cH2>B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=0
00:02:35.533 0.475000 0.408269 某个元素的左右两个矩阵的对应位置的元素，和元素所在矩阵左右两个元素的叠加后为零。
00:02:35.533 0.454100 0.408269 某个元素的左右两个矩阵的对应位置的元素，和元素所在矩阵左右两个元素的叠加后为零。
00:02:35.833 0.440800 0.326615 <cH2>B(n,x-1,y)⊕B(n,x+1,y)=B(n,x,y-1)⊕B(n,x,y+1)
00:02:38.933 0.721050 0.408269 这就是之前视频中，《优化生成矩阵》章节中的性质，后面我会给予证明。
00:02:38.933 0.454100 0.408269 这就是之前视频中，《优化生成矩阵》章节中的性质，后面我会给予证明。
00:02:42.733 0.476900 0.408269 通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。
00:02:42.733 0.450300 0.408269 通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。
00:02:44.233 0.440800 0.326615 <cL>L(n,x,y)=<cB>B(n,x-1,y)⊕B(n,x,y)⊕B(n,x+1,y)⊕B(n-1,x,y)
00:02:53.733 0.476900 0.408269 因此，我们可以在公式中去除y。去除y后，灯可以表示为当前矩阵的上左中右的按钮的叠加。
00:02:53.733 0.476900 0.408269 因此，我们可以在公式中去除y。去除y后，灯可以表示为当前矩阵的上左中右的按钮的叠加。
00:02:54.033 0.421800 0.326615 <cL>L(n,x)=<cB>B(n,x-1)⊕B(n,x)⊕B(n,x+1)⊕B(n-1,x)
00:02:59.133 0.476900 0.408269 又因为，下一行的按钮是当前灯的翻转。
00:02:59.433 0.454100 0.326615 <cB>B(n+1,x)=<cL>~L(n,x)=<cB>~(B(n,x-1)⊕B(n,x)⊕B(n,x+1)⊕B(n-1,x))
00:03:02.533 0.476900 0.408269 以及，下一行的灯是上左中右的灯的翻转的叠加。
00:03:02.833 0.454100 0.326615 <cL>L(n+1,x)=<cL>~L(n,x-1)⊕~L(n,x)⊕~L(n,x+1)⊕~L(n-1,x)
00:03:05.433 0.486400 0.408269 如果把翻转~提取出来，便有了一开始的推导公式。
00:03:08.033 0.476900 0.408269 也就是，按钮是上一行的左中右按钮和上上行的按钮的叠加。
00:03:08.333 0.421800 0.326615 <cB>B(n,x)=<cB>B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:03:11.433 0.476900 0.408269 以及，灯是上一行的左中右按钮和上上行的灯的叠加。
00:03:11.733 0.421800 0.326615 <cL>L(n,x)=<cL>L(n-1,x-1)⊕L(n-1,x)⊕L(n-1,x+1)⊕L(n-2,x)
00:03:18.033 0.475000 0.408269 可以注意到，按钮和灯的递推公式具有相同的形式，这是因为上一行灯就是下一行按钮。
00:03:18.033 0.454100 0.408269 可以注意到，按钮和灯的递推公式具有相同的形式，这是因为上一行灯就是下一行按钮。
00:03:20.633 0.476900 0.408269 因为最终需要推导的是灯矩阵，因此灯矩阵是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮矩阵也是5行。
00:03:20.633 0.476900 0.408269 因为最终需要推导的是灯矩阵，因此灯矩阵是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮矩阵也是5行。
00:03:25.833 0.475000 0.408269 对于翻转的情况，则可以单独列出来，以类似的方法推导，写成公式Y。
00:03:26.133 0.473100 0.326615 <cH2>Y(n,y)=<cH2>~(Y(n-1,y-1)⊕Y(n-1,y)⊕Y(n-1,y+1)⊕Y(n-2,y))
00:03:28.733 0.454100 0.408269 下一行的翻转是上一行左中右和上上行叠加后的翻转。
00:03:32.533 0.473100 0.408269 可以注意到，这里的公式Y和公式B的推导公式是类似的的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号~。
00:03:32.533 0.486400 0.408269 可以注意到，这里的公式Y和公式B的推导公式是类似的的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号~。
00:03:35.133 0.476900 0.408269 1. 使用零向量：第一次翻转发生在从一到二行的推导过程中，在此之前没有发生过翻转，因此Y的第一行是全零。
00:03:35.133 0.476900 0.408269 1. 使用零向量：第一次翻转发生在从一到二行的推导过程中，在此之前没有发生过翻转，因此Y的第一行是全零。
00:03:39.233 0.486400 0.408269 2. 翻转符号~必须存在：每次推导都需要翻转，因此不可省略。而前者将这个翻转取出来了，因此不用翻转符号~。
00:03:39.233 0.486400 0.408269 2. 翻转符号~必须存在：每次推导都需要翻转，因此不可省略。而前者将这个翻转取出来了，因此不用翻转符号~。
00:03:41.833 0.476900 0.408269 3. 不使用x而使用y：翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
00:03:41.833 0.475000 0.408269 3. 不使用x而使用y：翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
00:03:49.467 0.712500 0.408269 事实上，按钮矩阵也可以用另一种更直观的方法推得。
00:03:52.067 0.715350 0.408269 首先，我们点击第一行的第一个按钮。然后，点击第二行的按钮，尽可能消去第一行的灯。
00:03:52.067 0.715350 0.408269 首先，我们点击第一行的第一个按钮。然后，点击第二行的按钮，尽可能消去第一行的灯。
00:03:59.067 0.715350 0.408269 接着按第三行按钮，不断递推，直到最后一行。
00:04:06.467 0.715350 0.408269 那么，最后一行灯的状态，就是按钮矩阵的第一行。
00:04:09.667 0.712500 0.408269 同理，点击第二个按钮，然后递推。则最后一行灯就是B矩阵第二行。
00:04:09.667 0.681150 0.408269 同理，点击第二个按钮，然后递推。则最后一行灯就是B矩阵第二行。
00:04:15.867 0.712500 0.408269 通过这个方法，我们也得到整个按钮矩阵。
00:04:23.300 0.712500 0.408269 另外，灯向量也可以用相似的方法推得。
00:04:25.900 0.715350 0.408269 我们把所有灯全部点亮，然后用刚才的方法尝试把所有灯消去，最后一行灯的状态就是灯向量。
00:04:25.900 0.681150 0.408269 我们把所有灯全部点亮，然后用刚才的方法尝试把所有灯消去，最后一行灯的状态就是灯向量。
00:04:35.933 0.715350 0.408269 我们把这种方法称作余数矩阵法，和首行叠加法的原理本质上是相同的，有兴趣的观众小伙伴可以自行证明。
00:04:35.933 0.684000 0.408269 我们把这种方法称作余数矩阵法，和首行叠加法的原理本质上是相同的，有兴趣的观众小伙伴可以自行证明。
