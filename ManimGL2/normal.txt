00:00:00.000 0.837791 0.538915 点灯游戏的$O(n^2)$解法
00:00:01.700 0.681150 0.538915 首行叠加法（续上集）
00:00:03.100 0.721050 0.408269 在上集视频的《首行叠加法》中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。
00:00:03.100 0.475000 0.408269 在上集视频的《首行叠加法》中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。
00:00:03.400 0.421800 0.326615 <cB>B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:00:03.700 0.463600 0.326615 <cB>B按钮    <cL>L灯    <cH1>⊕叠加    <cH2>~翻转
00:00:08.300 0.486400 0.408269 我们用B代表按钮，L代表灯，⊕（加）代表叠加，~（非）代表翻转。
00:00:08.733 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:08.733 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:08.733 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:08.733 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:08.733 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:08.767 0.399000 0.130646 y1
00:00:08.800 0.328700 0.130646 n1
00:00:08.967 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:08.967 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:08.967 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:08.967 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:08.967 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:09.000 0.402810 0.130646 y2
00:00:09.033 0.328700 0.130646 n1
00:00:09.200 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.200 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:09.200 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:09.200 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.200 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:09.233 0.402785 0.130646 y3
00:00:09.267 0.328700 0.130646 n1
00:00:09.433 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.433 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:09.433 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:09.433 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.433 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:09.467 0.399000 0.130646 y4
00:00:09.500 0.328700 0.130646 n1
00:00:09.667 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.667 0.332510 0.130646 x1 x2 x3 x4 x5
00:00:09.667 0.336270 0.130646 x1 x2 x3 x4 x5
00:00:09.667 0.328700 0.130646 x1 x2 x3 x4 x5
00:00:09.667 0.328712 0.130646 x1 x2 x3 x4 x5
00:00:09.700 0.393300 0.130646 y5
00:00:09.733 0.328700 0.130646 n1
00:00:09.900 0.332510 0.130646 n2
00:00:10.067 0.332510 0.130646 n2
00:00:10.233 0.332510 0.130646 n2
00:00:10.400 0.332510 0.130646 n2
00:00:10.567 0.332510 0.130646 n2
00:00:10.733 0.336270 0.130646 n3
00:00:10.900 0.336270 0.130646 n3
00:00:11.067 0.336270 0.130646 n3
00:00:11.233 0.336270 0.130646 n3
00:00:11.400 0.336270 0.130646 n3
00:00:11.567 0.328700 0.130646 n4
00:00:11.733 0.328700 0.130646 n4
00:00:11.900 0.328700 0.130646 n4
00:00:12.067 0.328700 0.130646 n4
00:00:12.233 0.328700 0.130646 n4
00:00:12.400 0.328712 0.130646 n5
00:00:12.567 0.328712 0.130646 n5
00:00:12.733 0.328712 0.130646 n5
00:00:12.900 0.328712 0.130646 n5
00:00:13.067 0.328712 0.130646 n5
00:00:13.400 0.454100 0.408269 n代表从上到下第n行灯或按钮。因为我们是一行行进行推导的，n也代表第n次推导。
00:00:13.400 0.476900 0.408269 n代表从上到下第n行灯或按钮。因为我们是一行行进行推导的，n也代表第n次推导。
00:00:18.600 0.454100 0.408269 x代表从左到右第x列按钮。将灯表示为第一行的某几个列的按钮的叠加。这里的x不局限于第一行。
00:00:18.600 0.454100 0.408269 x代表从左到右第x列按钮。将灯表示为第一行的某几个列的按钮的叠加。这里的x不局限于第一行。
00:00:23.800 0.461700 0.408269 y代表从左到右第y列灯。这里的公式对任意第y个灯都满足，所以省去了y。
00:00:23.800 0.475000 0.408269 y代表从左到右第y列灯。这里的公式对任意第y个灯都满足，所以省去了y。
00:00:29.000 0.475000 0.408269 在这里，粉色原点是用按钮表示按钮，淡蓝色方块是用按钮表示灯。
00:00:36.800 0.712500 0.408269 而在上集视频中，因为最终目标是将灯用按钮表示，因此省去了按钮表示按钮，粉色原点直接为按钮表示灯。
00:00:36.800 0.475000 0.408269 而在上集视频中，因为最终目标是将灯用按钮表示，因此省去了按钮表示按钮，粉色原点直接为按钮表示灯。
00:00:44.100 0.452200 0.408269 让我们举一个具体的例子。在5x5的格子中，我们将灯和按钮编号为1-25。
00:00:44.100 0.475000 0.408269 让我们举一个具体的例子。在5x5的格子中，我们将灯和按钮编号为1-25。
00:00:47.300 0.721050 0.408269 在《叠加法》中，我们将灯表示为所有按钮的叠加。例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
00:00:47.300 0.475000 0.408269 在《叠加法》中，我们将灯表示为所有按钮的叠加。例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
00:01:00.033 0.454100 0.408269 通过这种方式我们得到了25元一次方程组。写成增广矩阵，也就是按钮矩阵加灯向量的形式。
00:01:00.033 0.476900 0.408269 通过这种方式我们得到了25元一次方程组。写成增广矩阵，也就是按钮矩阵加灯向量的形式。
00:01:08.133 0.721050 0.408269 而在《首行叠加法》中，我们需要把灯表示为第一行按钮的叠加。
00:01:08.500 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.500 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:08.500 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:08.500 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.500 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:08.533 0.328700 0.130646 L1
00:01:08.567 0.326800 0.130646 1
00:01:08.667 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.667 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:08.667 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:08.667 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.667 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:08.700 0.332510 0.130646 L2
00:01:08.733 0.330610 0.130646 2
00:01:08.833 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.833 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:08.833 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:08.833 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:08.833 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:08.867 0.336270 0.130646 L3
00:01:08.900 0.336270 0.130646 3
00:01:09.000 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:09.000 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:09.000 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:09.000 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:09.000 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:09.033 0.328700 0.130646 L4
00:01:09.067 0.326800 0.130646 4
00:01:09.167 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:09.167 0.332510 0.130646 B1 B2 B3 B4 B5
00:01:09.167 0.336270 0.130646 B1 B2 B3 B4 B5
00:01:09.167 0.328700 0.130646 B1 B2 B3 B4 B5
00:01:09.167 0.330612 0.130646 B1 B2 B3 B4 B5
00:01:09.200 0.330612 0.130646 L5
00:01:09.233 0.328712 0.130646 5
00:01:09.333 0.334414 0.130646 6
00:01:09.433 0.321100 0.130646 7
00:01:09.533 0.332500 0.130646 8
00:01:09.633 0.334400 0.130646 9
00:01:09.733 0.335358 0.130646 10
00:01:09.833 0.326800 0.130646 11
00:01:09.933 0.330610 0.130646 12
00:01:10.033 0.336270 0.130646 13
00:01:10.133 0.326800 0.130646 14
00:01:10.233 0.334412 0.130646 15
00:01:10.333 0.334414 0.130646 16
00:01:10.433 0.326800 0.130646 17
00:01:10.533 0.332500 0.130646 18
00:01:10.633 0.334400 0.130646 19
00:01:10.733 0.337267 0.130646 20
00:01:10.833 0.330610 0.130646 21
00:01:10.933 0.330610 0.130646 22
00:01:11.033 0.336295 0.130646 23
00:01:11.133 0.330610 0.130646 24
00:01:11.233 0.338221 0.130646 25
00:01:11.567 0.475000 0.408269 这里的五个矩阵，分别代表第y列是由第一行的哪几个按钮叠加的。
00:01:11.567 0.463600 0.408269 这里的五个矩阵，分别代表第y列是由第一行的哪几个按钮叠加的。
00:01:16.167 0.476900 0.408269 由于按法是动态的，当第二行按钮还未被按下时，L1=B1⊕B2，即第一个灯L1由第一行的一、二个按钮，即B1,B2叠加的。
00:01:16.167 0.476900 0.408269 由于按法是动态的，当第二行按钮还未被按下时，L1=B1⊕B2，即第一个灯L1由第一行的一、二个按钮，即B1,B2叠加的。
00:01:21.367 0.486400 0.408269 然后，B6=~L1=~(B1⊕B2)，即第六个按钮B6是第一个灯L1的翻转。因此，第二行按钮B6和第一行灯L1的叠加状态是相同的。
00:01:21.367 0.476900 0.408269 然后，B6=~L1=~(B1⊕B2)，即第六个按钮B6是第一个灯L1的翻转。因此，第二行按钮B6和第一行灯L1的叠加状态是相同的。
00:01:26.567 0.475000 0.408269 旁边的向量，代表的是按钮或灯有没有翻转。
00:01:31.467 0.476900 0.408269 例如，当第一个向量的第一个灯亮起时，表示第一个灯除了由刚才说的按钮叠加外，还需要再翻转才是正确的状态。
00:01:31.467 0.476900 0.408269 例如，当第一个向量的第一个灯亮起时，表示第一个灯除了由刚才说的按钮叠加外，还需要再翻转才是正确的状态。
00:01:36.067 0.486400 0.408269 同理，B7=~L2=~(B1⊕B2⊕B3)，即第七个按钮B6是第二个灯L2的翻转。同样，第二行的按钮B7和第一行灯L2的叠加状态是相同的。
00:01:36.067 0.476900 0.408269 同理，B7=~L2=~(B1⊕B2⊕B3)，即第七个按钮B6是第二个灯L2的翻转。同样，第二行的按钮B7和第一行灯L2的叠加状态是相同的。
00:01:42.767 0.475000 0.408269 这里，我们将第一个按钮B1的状态补全，将B1用第一行的按钮叠加时，有B1=B1。
00:01:42.767 0.476900 0.408269 这里，我们将第一个按钮B1的状态补全，将B1用第一行的按钮叠加时，有B1=B1。
00:01:47.667 0.452200 0.408269 接下来我们来看第六个灯。L6=B1⊕B6⊕B7=B1⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)=B1⊕B3。
00:01:47.667 0.448400 0.408269 接下来我们来看第六个灯。L6=B1⊕B6⊕B7=B1⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)=B1⊕B3。
00:01:59.067 0.475000 0.408269 又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)⊕~(B2⊕B3⊕B4)=~B4
00:01:59.067 0.448400 0.408269 又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)⊕~(B2⊕B3⊕B4)=~B4
00:02:17.067 0.475000 0.408269 这样不断递推，我们可以将任意L表示为某些B1到B5的叠加，再加上翻转。
00:02:26.467 0.475000 0.408269 现在，如果我们把序号1-25用坐标x,y表示，则灯和按钮矩阵可写为上述公式。让我们以L7(2)=L(2,2,2)为例。
00:02:26.467 0.454100 0.408269 现在，如果我们把序号1-25用坐标x,y表示，则灯和按钮矩阵可写为上述公式。让我们以L7(2)=L(2,2,2)为例。
00:02:26.767 0.440800 0.326615 <cL>L(n,x,y)=<cB>B(n,x,y-1)⊕B(n,x,y)⊕B(n,x,y+1)⊕B(n-1,x,y)
00:02:27.067 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.067 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:27.067 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:27.067 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.067 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:27.100 0.399000 0.130646 y1
00:02:27.133 0.328700 0.130646 n1
00:02:27.167 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.167 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:27.167 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:27.167 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.167 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:27.200 0.402810 0.130646 y2
00:02:27.233 0.328700 0.130646 n1
00:02:27.267 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.267 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:27.267 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:27.267 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.267 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:27.300 0.402785 0.130646 y3
00:02:27.333 0.328700 0.130646 n1
00:02:27.367 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.367 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:27.367 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:27.367 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.367 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:27.400 0.399000 0.130646 y4
00:02:27.433 0.328700 0.130646 n1
00:02:27.467 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.467 0.332510 0.130646 x1 x2 x3 x4 x5
00:02:27.467 0.336270 0.130646 x1 x2 x3 x4 x5
00:02:27.467 0.328700 0.130646 x1 x2 x3 x4 x5
00:02:27.467 0.328712 0.130646 x1 x2 x3 x4 x5
00:02:27.500 0.393300 0.130646 y5
00:02:27.533 0.328700 0.130646 n1
00:02:27.567 0.332510 0.130646 n2
00:02:27.600 0.332510 0.130646 n2
00:02:27.633 0.332510 0.130646 n2
00:02:27.667 0.332510 0.130646 n2
00:02:27.700 0.332510 0.130646 n2
00:02:27.733 0.336270 0.130646 n3
00:02:27.767 0.336270 0.130646 n3
00:02:27.800 0.336270 0.130646 n3
00:02:27.833 0.336270 0.130646 n3
00:02:27.867 0.336270 0.130646 n3
00:02:27.900 0.328700 0.130646 n4
00:02:27.933 0.328700 0.130646 n4
00:02:27.967 0.328700 0.130646 n4
00:02:28.000 0.328700 0.130646 n4
00:02:28.033 0.328700 0.130646 n4
00:02:28.067 0.328712 0.130646 n5
00:02:28.100 0.328712 0.130646 n5
00:02:28.133 0.328712 0.130646 n5
00:02:28.167 0.328712 0.130646 n5
00:02:28.200 0.328712 0.130646 n5
00:02:32.933 0.475000 0.408269 这里，我们的矩阵同时满足另一个性质，称之为十字偶校验约束。
00:02:32.933 0.452200 0.408269 这里，我们的矩阵同时满足另一个性质，称之为十字偶校验约束。
00:02:33.233 0.440800 0.326615 <cH2>B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=0
00:02:37.033 0.475000 0.408269 某个元素的左右两个矩阵的对应位置的元素，和元素所在矩阵左右两个元素的叠加后为零。
00:02:37.033 0.454100 0.408269 某个元素的左右两个矩阵的对应位置的元素，和元素所在矩阵左右两个元素的叠加后为零。
00:02:37.333 0.440800 0.326615 <cH2>B(n,x-1,y)⊕B(n,x+1,y)=B(n,x,y-1)⊕B(n,x,y+1)
00:02:40.433 0.721050 0.408269 这就是之前视频中，《优化生成矩阵》章节中的性质，后面我会给予证明。
00:02:40.433 0.454100 0.408269 这就是之前视频中，《优化生成矩阵》章节中的性质，后面我会给予证明。
00:02:44.233 0.476900 0.408269 通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。
00:02:44.233 0.450300 0.408269 通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。
00:02:45.733 0.440800 0.326615 <cL>L(n,x,y)=<cB>B(n,x-1,y)⊕B(n,x,y)⊕B(n,x+1,y)⊕B(n-1,x,y)
00:02:55.233 0.476900 0.408269 因此，我们可以在公式中去除y。去除y后，灯可以表示为当前矩阵的上左中右的按钮的叠加。
00:02:55.233 0.476900 0.408269 因此，我们可以在公式中去除y。去除y后，灯可以表示为当前矩阵的上左中右的按钮的叠加。
00:02:55.533 0.421800 0.326615 <cL>L(n,x)=<cB>B(n,x-1)⊕B(n,x)⊕B(n,x+1)⊕B(n-1,x)
00:03:00.633 0.476900 0.408269 又因为，下一行的按钮是当前灯的翻转。
00:03:00.933 0.454100 0.326615 <cB>B(n+1,x)=<cL>~L(n,x)=<cB>~(B(n,x-1)⊕B(n,x)⊕B(n,x+1)⊕B(n-1,x))
00:03:04.033 0.476900 0.408269 以及，下一行的灯是上左中右的灯的翻转的叠加。
00:03:04.333 0.454100 0.326615 <cL>L(n+1,x)=<cL>~L(n,x-1)⊕~L(n,x)⊕~L(n,x+1)⊕~L(n-1,x)
00:03:06.933 0.486400 0.408269 如果把翻转~提取出来，便有了一开始的推导公式。
00:03:09.533 0.476900 0.408269 也就是，按钮是上一行的左中右按钮和上上行的按钮的叠加。
00:03:09.833 0.421800 0.326615 <cB>B(n,x)=<cB>B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:03:12.933 0.476900 0.408269 以及，灯是上一行的左中右按钮和上上行的灯的叠加。
00:03:13.233 0.421800 0.326615 <cL>L(n,x)=<cL>L(n-1,x-1)⊕L(n-1,x)⊕L(n-1,x+1)⊕L(n-2,x)
00:03:19.533 0.475000 0.408269 可以注意到，按钮和灯的递推公式具有相同的形式，这是因为上一行灯就是下一行按钮。
00:03:19.533 0.454100 0.408269 可以注意到，按钮和灯的递推公式具有相同的形式，这是因为上一行灯就是下一行按钮。
00:03:22.133 0.476900 0.408269 因为最终需要推导的是灯矩阵，因此灯矩阵是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮矩阵也是5行。
00:03:22.133 0.476900 0.408269 因为最终需要推导的是灯矩阵，因此灯矩阵是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮矩阵也是5行。
00:03:27.333 0.475000 0.408269 对于翻转的情况，则可以单独列出来，以类似的方法推导，写成公式Y。
00:03:27.633 0.473100 0.326615 <cH2>Y(n,y)=<cH2>~(Y(n-1,y-1)⊕Y(n-1,y)⊕Y(n-1,y+1)⊕Y(n-2,y))
00:03:30.233 0.454100 0.408269 下一行的翻转是上一行左中右和上上行叠加后的翻转。
00:03:34.033 0.473100 0.408269 可以注意到，这里的公式Y和公式B的推导公式是类似的的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号~。
00:03:34.033 0.486400 0.408269 可以注意到，这里的公式Y和公式B的推导公式是类似的的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号~。
00:03:36.633 0.476900 0.408269 1. 使用零向量：第一次翻转发生在从一到二行的推导过程中，在此之前没有发生过翻转，因此Y的第一行是全零。
00:03:36.633 0.476900 0.408269 1. 使用零向量：第一次翻转发生在从一到二行的推导过程中，在此之前没有发生过翻转，因此Y的第一行是全零。
00:03:40.733 0.486400 0.408269 2. 翻转符号~必须存在：每次推导都需要翻转，因此不可省略。而前者将这个翻转取出来了，因此不用翻转符号~。
00:03:40.733 0.486400 0.408269 2. 翻转符号~必须存在：每次推导都需要翻转，因此不可省略。而前者将这个翻转取出来了，因此不用翻转符号~。
00:03:43.333 0.476900 0.408269 3. 不使用x而使用y：翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
00:03:43.333 0.475000 0.408269 3. 不使用x而使用y：翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
00:03:52.733 0.672600 0.538915 优化生成矩阵（续上集）
00:03:54.133 0.721050 0.408269 在《生成优化矩阵》章节中，我将矩阵的行重排。其实是调换了n和y的位置，使原来从左到右的第y个矩阵变为了第n个矩阵。
00:03:54.133 0.475000 0.408269 在《生成优化矩阵》章节中，我将矩阵的行重排。其实是调换了n和y的位置，使原来从左到右的第y个矩阵变为了第n个矩阵。
00:04:04.100 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.100 0.332510 0.130646 x1 x2 x3 x4 x5
00:04:04.100 0.336270 0.130646 x1 x2 x3 x4 x5
00:04:04.100 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.100 0.328712 0.130646 x1 x2 x3 x4 x5
00:04:04.133 0.328700 0.130646 n1
00:04:04.167 0.399000 0.130646 y1
00:04:04.200 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.200 0.332510 0.130646 x1 x2 x3 x4 x5
00:04:04.200 0.336270 0.130646 x1 x2 x3 x4 x5
00:04:04.200 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.200 0.328712 0.130646 x1 x2 x3 x4 x5
00:04:04.233 0.332510 0.130646 n2
00:04:04.267 0.399000 0.130646 y1
00:04:04.300 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.300 0.332510 0.130646 x1 x2 x3 x4 x5
00:04:04.300 0.336270 0.130646 x1 x2 x3 x4 x5
00:04:04.300 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.300 0.328712 0.130646 x1 x2 x3 x4 x5
00:04:04.333 0.336270 0.130646 n3
00:04:04.367 0.399000 0.130646 y1
00:04:04.400 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.400 0.332510 0.130646 x1 x2 x3 x4 x5
00:04:04.400 0.336270 0.130646 x1 x2 x3 x4 x5
00:04:04.400 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.400 0.328712 0.130646 x1 x2 x3 x4 x5
00:04:04.433 0.328700 0.130646 n4
00:04:04.467 0.399000 0.130646 y1
00:04:04.500 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.500 0.332510 0.130646 x1 x2 x3 x4 x5
00:04:04.500 0.336270 0.130646 x1 x2 x3 x4 x5
00:04:04.500 0.328700 0.130646 x1 x2 x3 x4 x5
00:04:04.500 0.328712 0.130646 x1 x2 x3 x4 x5
00:04:04.533 0.328712 0.130646 n5
00:04:04.567 0.399000 0.130646 y1
00:04:04.600 0.402810 0.130646 y2
00:04:04.633 0.402810 0.130646 y2
00:04:04.667 0.402810 0.130646 y2
00:04:04.700 0.402810 0.130646 y2
00:04:04.733 0.402810 0.130646 y2
00:04:04.767 0.402785 0.130646 y3
00:04:04.800 0.402785 0.130646 y3
00:04:04.833 0.402785 0.130646 y3
00:04:04.867 0.402785 0.130646 y3
00:04:04.900 0.402785 0.130646 y3
00:04:04.933 0.399000 0.130646 y4
00:04:04.967 0.399000 0.130646 y4
00:04:05.000 0.399000 0.130646 y4
00:04:05.033 0.399000 0.130646 y4
00:04:05.067 0.399000 0.130646 y4
00:04:05.100 0.393300 0.130646 y5
00:04:05.133 0.393300 0.130646 y5
00:04:05.167 0.393300 0.130646 y5
00:04:05.200 0.393300 0.130646 y5
00:04:05.233 0.393300 0.130646 y5
00:04:05.567 0.475000 0.408269 这n个矩阵都满足十字偶校验约束，即上下左右四个格子叠加为零，因此这里的公式省去了n。
00:04:05.567 0.446500 0.408269 这n个矩阵都满足十字偶校验约束，即上下左右四个格子叠加为零，因此这里的公式省去了n。
00:04:05.867 0.440800 0.326615 <cH2>B(x-1,y)⊕B(x+1,y)⊕B(x,y-1)⊕B(x,y+1)=0
00:04:08.467 0.476900 0.408269 这里和之前的情况是一样的，只不过n和y调换了，因此位置发生了变化。
00:04:08.467 0.475000 0.408269 这里和之前的情况是一样的，只不过n和y调换了，因此位置发生了变化。
00:04:12.267 0.450300 0.408269 这是一个十分重要的性质。通过这个性质，可以由第一个灯直接推导后面的灯。
00:04:12.267 0.475000 0.408269 这是一个十分重要的性质。通过这个性质，可以由第一个灯直接推导后面的灯。
00:04:14.867 0.476900 0.408269 在后面会说的O(n^2)算法中，其本质也是利用这个性质进行的优化。
00:04:14.867 0.454100 0.408269 在后面会说的O(n^2)算法中，其本质也是利用这个性质进行的优化。
00:04:17.467 0.715350 0.408269 下面让我用数学归纳法，证明这个性质。
00:04:20.067 0.475000 0.408269 由于右边的按钮矩阵就是左边的灯矩阵，为了方便，我们就只看按钮矩阵。
00:04:20.067 0.475000 0.408269 由于右边的按钮矩阵就是左边的灯矩阵，为了方便，我们就只看按钮矩阵。
00:04:23.267 0.715350 0.408269 首先，我们假定前两个矩阵B(n-1)和B(n-2)满足这个性质，现在来证明则B(n)也满足这个性质。
00:04:23.267 0.681150 0.408269 首先，我们假定前两个矩阵B(n-1)和B(n-2)满足这个性质，现在来证明则B(n)也满足这个性质。
00:04:23.567 0.440800 0.326615 <cH2>B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)
00:04:26.967 0.692550 0.408269 将刚才的矩阵递推关系加上参数y并重写。
00:04:27.267 0.440800 0.326615 <cB>B(n,x,y)=B(n-1,x-1,y)⊕B(n-1,x,y)⊕B(n-1,x+1,y)⊕B(n-2,x,y)
00:04:31.367 0.712500 0.408269 对于B(n)，我们将式子竖着写成四项，然后将递推关系代入这个式子。
00:04:31.367 0.678300 0.408269 对于B(n)，我们将式子竖着写成四项，然后将递推关系代入这个式子。
00:04:31.667 0.330600 0.244961 <cH2>B(n,x-1,y)⊕<br><cH2>B(n,x+1,y)⊕<br><cH2>B(n,x,y-1)⊕<br><cH2>B(n,x,y+1)
00:04:31.667 0.330600 0.244961 <cH2>B(n,x-1,y)⊕<br><cH2>B(n,x+1,y)⊕<br><cH2>B(n,x,y-1)⊕<br><cH2>B(n,x,y+1)
00:04:31.667 0.330600 0.244961 <cH2>B(n,x-1,y)⊕<br><cH2>B(n,x+1,y)⊕<br><cH2>B(n,x,y-1)⊕<br><cH2>B(n,x,y+1)
00:04:31.667 0.330600 0.244961 <cH2>B(n,x-1,y)⊕<br><cH2>B(n,x+1,y)⊕<br><cH2>B(n,x,y-1)⊕<br><cH2>B(n,x,y+1)
00:04:34.467 0.330600 0.244961 <cH2>(B(n-1,x-1-1,y)⊕B(n-1,x-1+1,y)⊕B(n-1,x-1,y-1)⊕B(n-1,x-1,y+1))⊕<br><cH2>(B(n-1,x-1,y)⊕B(n-1,x+1,y)⊕B(n-1,x,y-1)⊕B(n-1,x,y+1))⊕<br><cH2>(B(n-1,x+1-1,y)⊕B(n-1,x+1+1,y)⊕B(n-1,x+1,y-1)⊕B(n-1,x+1,y+1))⊕<br><cH2>(B(n-2,x-1,y)⊕B(n-2,x+1,y)⊕B(n-2,x,y-1)⊕B(n-2,x,y+1))
00:04:34.467 0.330600 0.244961 <cH2>(B(n-1,x-1-1,y)⊕B(n-1,x-1+1,y)⊕B(n-1,x-1,y-1)⊕B(n-1,x-1,y+1))⊕<br><cH2>(B(n-1,x-1,y)⊕B(n-1,x+1,y)⊕B(n-1,x,y-1)⊕B(n-1,x,y+1))⊕<br><cH2>(B(n-1,x+1-1,y)⊕B(n-1,x+1+1,y)⊕B(n-1,x+1,y-1)⊕B(n-1,x+1,y+1))⊕<br><cH2>(B(n-2,x-1,y)⊕B(n-2,x+1,y)⊕B(n-2,x,y-1)⊕B(n-2,x,y+1))
00:04:34.467 0.330600 0.244961 <cH2>(B(n-1,x-1-1,y)⊕B(n-1,x-1+1,y)⊕B(n-1,x-1,y-1)⊕B(n-1,x-1,y+1))⊕<br><cH2>(B(n-1,x-1,y)⊕B(n-1,x+1,y)⊕B(n-1,x,y-1)⊕B(n-1,x,y+1))⊕<br><cH2>(B(n-1,x+1-1,y)⊕B(n-1,x+1+1,y)⊕B(n-1,x+1,y-1)⊕B(n-1,x+1,y+1))⊕<br><cH2>(B(n-2,x-1,y)⊕B(n-2,x+1,y)⊕B(n-2,x,y-1)⊕B(n-2,x,y+1))
00:04:34.467 0.330600 0.244961 <cH2>(B(n-1,x-1-1,y)⊕B(n-1,x-1+1,y)⊕B(n-1,x-1,y-1)⊕B(n-1,x-1,y+1))⊕<br><cH2>(B(n-1,x-1,y)⊕B(n-1,x+1,y)⊕B(n-1,x,y-1)⊕B(n-1,x,y+1))⊕<br><cH2>(B(n-1,x+1-1,y)⊕B(n-1,x+1+1,y)⊕B(n-1,x+1,y-1)⊕B(n-1,x+1,y+1))⊕<br><cH2>(B(n-2,x-1,y)⊕B(n-2,x+1,y)⊕B(n-2,x,y-1)⊕B(n-2,x,y+1))
00:04:37.567 0.721050 0.408269 代入后的式子包含16个项目。现在重新排列项目顺序，将y和n调换，类似《优化生成矩阵》章节中的调换操作。
00:04:37.867 0.330600 0.244961 <cH2>(B(n-1,x-1-1,y)⊕B(n-1,x-1,y)⊕B(n-1,x+1-1,y)⊕B(n-2,x-1,y))⊕<br><cH2>(B(n-1,x-1+1,y)⊕B(n-1,x+1,y)⊕B(n-1,x+1+1,y)⊕B(n-2,x+1,y))⊕<br><cH2>(B(n-1,x-1,y-1)⊕B(n-1,x,y-1)⊕B(n-1,x+1,y-1)⊕B(n-2,x,y-1))⊕<br><cH2>(B(n-1,x-1,y+1)⊕B(n-1,x,y+1)⊕B(n-1,x+1,y+1)⊕B(n-2,x,y+1))
00:04:37.867 0.330600 0.244961 <cH2>(B(n-1,x-1-1,y)⊕B(n-1,x-1,y)⊕B(n-1,x+1-1,y)⊕B(n-2,x-1,y))⊕<br><cH2>(B(n-1,x-1+1,y)⊕B(n-1,x+1,y)⊕B(n-1,x+1+1,y)⊕B(n-2,x+1,y))⊕<br><cH2>(B(n-1,x-1,y-1)⊕B(n-1,x,y-1)⊕B(n-1,x+1,y-1)⊕B(n-2,x,y-1))⊕<br><cH2>(B(n-1,x-1,y+1)⊕B(n-1,x,y+1)⊕B(n-1,x+1,y+1)⊕B(n-2,x,y+1))
00:04:37.867 0.330600 0.244961 <cH2>(B(n-1,x-1-1,y)⊕B(n-1,x-1,y)⊕B(n-1,x+1-1,y)⊕B(n-2,x-1,y))⊕<br><cH2>(B(n-1,x-1+1,y)⊕B(n-1,x+1,y)⊕B(n-1,x+1+1,y)⊕B(n-2,x+1,y))⊕<br><cH2>(B(n-1,x-1,y-1)⊕B(n-1,x,y-1)⊕B(n-1,x+1,y-1)⊕B(n-2,x,y-1))⊕<br><cH2>(B(n-1,x-1,y+1)⊕B(n-1,x,y+1)⊕B(n-1,x+1,y+1)⊕B(n-2,x,y+1))
00:04:37.867 0.330600 0.244961 <cH2>(B(n-1,x-1-1,y)⊕B(n-1,x-1,y)⊕B(n-1,x+1-1,y)⊕B(n-2,x-1,y))⊕<br><cH2>(B(n-1,x-1+1,y)⊕B(n-1,x+1,y)⊕B(n-1,x+1+1,y)⊕B(n-2,x+1,y))⊕<br><cH2>(B(n-1,x-1,y-1)⊕B(n-1,x,y-1)⊕B(n-1,x+1,y-1)⊕B(n-2,x,y-1))⊕<br><cH2>(B(n-1,x-1,y+1)⊕B(n-1,x,y+1)⊕B(n-1,x+1,y+1)⊕B(n-2,x,y+1))
00:04:49.167 0.706800 0.408269 不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此整个式子化为了零。
00:04:49.167 0.476900 0.408269 不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此整个式子化为了零。
00:04:49.467 0.273600 0.244961 <cH2>0⊕<br><cH2>0⊕<br><cH2>0⊕<br><cH2>0
00:04:49.467 0.273600 0.244961 <cH2>0⊕<br><cH2>0⊕<br><cH2>0⊕<br><cH2>0
00:04:49.467 0.273600 0.244961 <cH2>0⊕<br><cH2>0⊕<br><cH2>0⊕<br><cH2>0
00:04:49.467 0.266475 0.244961 <cH2>0⊕<br><cH2>0⊕<br><cH2>0⊕<br><cH2>0
00:04:51.267 0.364800 0.326615 <cH2>0⊕0⊕0⊕0
00:04:54.067 0.440800 0.326615 <cH2>B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=0
00:04:58.667 0.475000 0.408269 现在，我们只需要证明最左边两个矩阵也满足这个性质即可。第一个矩阵是单位矩阵，显然满足这个性质。
00:04:58.667 0.475000 0.408269 现在，我们只需要证明最左边两个矩阵也满足这个性质即可。第一个矩阵是单位矩阵，显然满足这个性质。
00:05:06.267 0.454100 0.408269 第二个矩阵可以表示为左边两个矩阵的叠加。由于单位矩阵左边没有矩阵，因此相当于叠加了一个零矩阵。
00:05:06.267 0.475000 0.408269 第二个矩阵可以表示为左边两个矩阵的叠加。由于单位矩阵左边没有矩阵，因此相当于叠加了一个零矩阵。
00:05:10.367 0.475000 0.408269 由于零矩阵显然满足这个性质，因此第二个矩阵也满足这个性质。
00:05:14.467 0.476900 0.408269 因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出下面的行，求得完整的矩阵B(n)。
00:05:14.467 0.715350 0.408269 因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出下面的行，求得完整的矩阵B(n)。
00:05:22.967 1.021725 0.538915 首行求逆法
00:05:24.367 0.715350 0.408269 对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。
00:05:24.367 0.715350 0.408269 对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。
00:05:24.967 0.324900 0.195969    B   
00:05:27.567 0.709650 0.408269 这里，让我以我们以n=7为例。这里的B就是前面提到的按钮矩阵B，而y就是翻转矩阵Y的最后一行。
00:05:27.567 0.715350 0.408269 这里，让我以我们以n=7为例。这里的B就是前面提到的按钮矩阵B，而y就是翻转矩阵Y的最后一行。
00:05:28.467 0.424650 0.195969 y
00:05:31.067 0.715350 0.408269 我们的目标是，对于Bx=y，在已知B的第一行和y的情况下求x。
00:05:31.367 0.399000 0.326615 <cB>B<cX>x<cY>=y
00:05:32.267 0.319200 0.195969 x
00:05:33.167 0.503025 0.195969 0 1 2 3 4 5 6
00:05:33.167 0.326800 0.195969 0 1 2 3 4 5 6
00:05:33.167 0.330610 0.195969 0 1 2 3 4 5 6
00:05:33.167 0.336270 0.195969 0 1 2 3 4 5 6
00:05:33.167 0.326800 0.195969 0 1 2 3 4 5 6
00:05:33.167 0.328712 0.195969 0 1 2 3 4 5 6
00:05:33.167 0.334414 0.195969 0 1 2 3 4 5 6
00:05:34.567 0.319200 0.195969 x
00:05:36.000 0.424650 0.195969 y
00:05:41.800 0.476900 0.408269 如果将n在不同情况下B的第一行写在一起，这样的矩阵长这样，我们记为B'。
00:05:43.200 0.421800 0.326615 <cB>B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:05:43.800 0.503025 0.195969 0 1 2 3 4 5 6 7
00:05:43.800 0.326800 0.195969 0 1 2 3 4 5 6 7
00:05:43.800 0.330610 0.195969 0 1 2 3 4 5 6 7
00:05:43.800 0.336270 0.195969 0 1 2 3 4 5 6 7
00:05:43.800 0.326800 0.195969 0 1 2 3 4 5 6 7
00:05:43.800 0.328712 0.195969 0 1 2 3 4 5 6 7
00:05:43.800 0.334414 0.195969 0 1 2 3 4 5 6 7
00:05:43.800 0.321100 0.195969 0 1 2 3 4 5 6 7
00:05:44.100 0.328700 0.195969 B'
00:05:47.300 0.476900 0.408269 注意，这里的B'矩阵不是刚才说的当n确定时的完整的B矩阵，而是B(n)的第一行拼接起来。
00:05:47.300 0.681150 0.408269 注意，这里的B'矩阵不是刚才说的当n确定时的完整的B矩阵，而是B(n)的第一行拼接起来。
00:05:50.500 0.715350 0.408269 另外，这里从n=0开始一共递推n次，最后一个1不包含在B矩阵的第一行内。例如n=7时，第一行为1011011，最后一个1省去。
00:05:50.500 0.715350 0.408269 另外，这里从n=0开始一共递推n次，最后一个1不包含在B矩阵的第一行内。例如n=7时，第一行为1011011，最后一个1省去。
00:05:51.100 0.328700 0.195969 B''
00:05:52.500 0.450300 0.408269 改写后的矩阵记为B''=B'⊕I
00:05:56.600 0.476900 0.408269 把Y的第一行写在一起是这样的，记作Y'。
00:05:56.900 0.473100 0.326615 <cY>Y(n,y)=~(Y(n-1,y-1)⊕Y(n-1,y)⊕Y(n-1,y+1)⊕Y(n-2,y))
00:05:57.500 0.503025 0.195969 0 1 2 3 4 5 6 7
00:05:57.500 0.326800 0.195969 0 1 2 3 4 5 6 7
00:05:57.500 0.330610 0.195969 0 1 2 3 4 5 6 7
00:05:57.500 0.336270 0.195969 0 1 2 3 4 5 6 7
00:05:57.500 0.326800 0.195969 0 1 2 3 4 5 6 7
00:05:57.500 0.328712 0.195969 0 1 2 3 4 5 6 7
00:05:57.500 0.334414 0.195969 0 1 2 3 4 5 6 7
00:05:57.500 0.321100 0.195969 0 1 2 3 4 5 6 7
00:05:57.800 0.328700 0.195969 Y'
00:06:01.300 0.450300 0.408269 合并在一起后的Y'有上述递推公式。
00:06:01.600 0.330600 0.244961 <cY>Y0(n,y)=Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y),y>y;Y'(y,n),y=1<br><cY>Y1(n,y)=Y'(n-1,y-1)⊕Y0(n-1,y)<br><cY>Y2(n,y)=Y1(n-1,y-1)⊕Y0(n-2,y)<br><cY>Y'(n,y)=~(Y1(n,y-1)⊕Y1(n,y)⊕Y1(n,y+1)⊕Y2(n,y)),y<=n;0,y>n
00:06:01.600 0.330600 0.244961 <cY>Y0(n,y)=Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y),y>y;Y'(y,n),y=1<br><cY>Y1(n,y)=Y'(n-1,y-1)⊕Y0(n-1,y)<br><cY>Y2(n,y)=Y1(n-1,y-1)⊕Y0(n-2,y)<br><cY>Y'(n,y)=~(Y1(n,y-1)⊕Y1(n,y)⊕Y1(n,y+1)⊕Y2(n,y)),y<=n;0,y>n
00:06:01.600 0.330600 0.244961 <cY>Y0(n,y)=Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y),y>y;Y'(y,n),y=1<br><cY>Y1(n,y)=Y'(n-1,y-1)⊕Y0(n-1,y)<br><cY>Y2(n,y)=Y1(n-1,y-1)⊕Y0(n-2,y)<br><cY>Y'(n,y)=~(Y1(n,y-1)⊕Y1(n,y)⊕Y1(n,y+1)⊕Y2(n,y)),y<=n;0,y>n
00:06:01.600 0.354825 0.244961 <cY>Y0(n,y)=Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y),y>y;Y'(y,n),y=1<br><cY>Y1(n,y)=Y'(n-1,y-1)⊕Y0(n-1,y)<br><cY>Y2(n,y)=Y1(n-1,y-1)⊕Y0(n-2,y)<br><cY>Y'(n,y)=~(Y1(n,y-1)⊕Y1(n,y)⊕Y1(n,y+1)⊕Y2(n,y)),y<=n;0,y>n
00:06:01.900 0.330600 0.244961 <cY>Y0(n,y)=Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y),y>1;Y'(n,y),y=1<br><cY>Y'(n,y)=~(Y'(n-1,y-2)⊕Y'(n-1,y-1)⊕Y'(n-1,y)⊕Y'(n-2,y-2)<br><cY>⊕Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y-1)⊕Y0(n-2,y)),y<=n;0,y>n
00:06:01.900 0.354825 0.244961 <cY>Y0(n,y)=Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y),y>1;Y'(n,y),y=1<br><cY>Y'(n,y)=~(Y'(n-1,y-2)⊕Y'(n-1,y-1)⊕Y'(n-1,y)⊕Y'(n-2,y-2)<br><cY>⊕Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y-1)⊕Y0(n-2,y)),y<=n;0,y>n
00:06:01.900 0.330600 0.244961 <cY>Y0(n,y)=Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y),y>1;Y'(n,y),y=1<br><cY>Y'(n,y)=~(Y'(n-1,y-2)⊕Y'(n-1,y-1)⊕Y'(n-1,y)⊕Y'(n-2,y-2)<br><cY>⊕Y0(n-1,y-1)⊕Y0(n-1,y)⊕Y0(n-1,y+1)⊕Y0(n-2,y-1)⊕Y0(n-2,y)),y<=n;0,y>n
00:06:05.400 0.715350 0.408269 为了实现这个目标，我们需要首先将B进行分解。这里，让我首先介绍一个非常重要的矩阵H，称为邻接矩阵。
00:06:05.400 0.715350 0.408269 为了实现这个目标，我们需要首先将B进行分解。这里，让我首先介绍一个非常重要的矩阵H，称为邻接矩阵。
00:06:05.700 0.473100 0.326615 <cH>H(y,x)=(∣x-y∣=1)
00:06:06.300 0.487350 0.195969    H   
00:06:06.600 0.503025 0.195969 0 1 2 3 4 5 6
00:06:06.600 0.326800 0.195969 0 1 2 3 4 5 6
00:06:06.600 0.330610 0.195969 0 1 2 3 4 5 6
00:06:06.600 0.336270 0.195969 0 1 2 3 4 5 6
00:06:06.600 0.326800 0.195969 0 1 2 3 4 5 6
00:06:06.600 0.328712 0.195969 0 1 2 3 4 5 6
00:06:06.600 0.334414 0.195969 0 1 2 3 4 5 6
00:06:07.200 0.712500 0.408269 对于H的每一个元素，如果x和y的差为一则为一，否则为零。
00:06:09.800 0.715350 0.408269 如果将向量v乘以该矩阵，等同于将向量v的每个元素向左右扩散后叠加。
00:06:10.100 0.416100 0.326615 <cV>v'(x)=v(x)*<cH>H<cV>=v(x-1)⊕v(x+1)
00:06:11.500 0.324900 0.195969 v
00:06:12.433 0.498750 0.195969 v'
00:06:15.633 0.681150 0.408269 这是因为矩阵的对应行就是向量每个元素左右扩散的结果。
00:06:20.333 0.721050 0.408269 不难发现，《首行叠加法》中的各个B矩阵，可以使用H表示为以上公式。
00:06:20.633 0.416100 0.326615 <cB>B(n)=B(n-1)*<cH>H<cB>⊕B(n-1)⊕B(n-2)
00:06:20.933 0.427500 0.326615 <cB>B(0)=<cI>I<cH>=H^0
00:06:21.233 0.427500 0.326615 <cB>B(1)=<cH>H=<cH>H^0+H^1
00:06:21.533 0.427500 0.326615 <cB>B(2)=B(1)*<cH>H<cB>+B(1)+B(0)=<cH>(H^2+H^1)+(H^1+H^0)+H^0=H^2
00:06:22.133 0.712500 0.408269 例如，B(0)=H^0，B(1)=H^0+H^1，B(2)=H^2
00:06:25.633 0.712500 0.408269 将其系数用多项式c(n,x)表达，则有和B矩阵类似的表达式。同时，将系数c写成矩阵的形式，记为C。
00:06:25.633 0.712500 0.408269 将其系数用多项式c(n,x)表达，则有和B矩阵类似的表达式。同时，将系数c写成矩阵的形式，记为C。
00:06:26.233 0.503025 0.195969 0 1 2 3 4 5 6 7
00:06:26.233 0.326800 0.195969 0 1 2 3 4 5 6 7
00:06:26.233 0.330610 0.195969 0 1 2 3 4 5 6 7
00:06:26.233 0.336270 0.195969 0 1 2 3 4 5 6 7
00:06:26.233 0.326800 0.195969 0 1 2 3 4 5 6 7
00:06:26.233 0.328712 0.195969 0 1 2 3 4 5 6 7
00:06:26.233 0.334414 0.195969 0 1 2 3 4 5 6 7
00:06:26.233 0.321100 0.195969 0 1 2 3 4 5 6 7
00:06:26.533 0.498750 0.195969 C
00:06:26.833 0.421800 0.326615 <cC>C(n,x)=C(n-1,x-1)⊕C(n-1,x)⊕C(n-2,x)
00:06:30.033 0.715350 0.408269 注意，这里的乘以H的操作在系数上代表右移而不是左右扩散，因此表达式中只有x-1而没有x+1。
00:06:30.033 0.672600 0.408269 注意，这里的乘以H的操作在系数上代表右移而不是左右扩散，因此表达式中只有x-1而没有x+1。
00:06:32.633 0.678300 0.408269 这个C矩阵和后面提到的F矩阵息息相关。
00:06:37.333 0.712500 0.408269 现在，如果我们将多个H相乘，也就是H^n，则其首行H^n(0)从单位矩阵n=0开始，看起来像是这样的。
00:06:37.333 0.715350 0.408269 现在，如果我们将多个H相乘，也就是H^n，则其首行H^n(0)从单位矩阵n=0开始，看起来像是这样的。
00:06:37.933 0.503025 0.195969 0 1 2 3 4 5 6 7
00:06:37.933 0.326800 0.195969 0 1 2 3 4 5 6 7
00:06:37.933 0.330610 0.195969 0 1 2 3 4 5 6 7
00:06:37.933 0.336270 0.195969 0 1 2 3 4 5 6 7
00:06:37.933 0.326800 0.195969 0 1 2 3 4 5 6 7
00:06:37.933 0.328712 0.195969 0 1 2 3 4 5 6 7
00:06:37.933 0.334414 0.195969 0 1 2 3 4 5 6 7
00:06:37.933 0.321100 0.195969 0 1 2 3 4 5 6 7
00:06:38.233 0.487350 0.195969 K
00:06:40.833 0.712500 0.408269 我们把这个下三角矩阵记为K，即Krylov矩阵或扩散基矩阵。也就是说，对于K的第n行，有K(n)=H^n(0)。
00:06:40.833 0.715350 0.408269 我们把这个下三角矩阵记为K，即Krylov矩阵或扩散基矩阵。也就是说，对于K的第n行，有K(n)=H^n(0)。
00:06:41.133 0.427500 0.326615 <cK>K(n)=k(n-1)*<cH>H=H^n(0)
00:06:43.733 0.715350 0.408269 这里下一行是上一行乘以H，也就是上一行左右扩散的叠加。因此对于K的每个元素，有上述递推公式。
00:06:43.733 0.475000 0.408269 这里下一行是上一行乘以H，也就是上一行左右扩散的叠加。因此对于K的每个元素，有上述递推公式。
00:06:44.033 0.421800 0.326615 <cK>K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)
00:06:49.333 0.715350 0.408269 现在，定义多项式p(x)。我们的目标是把B拆分成H^n。
00:06:49.333 0.450300 0.408269 现在，定义多项式p(x)。我们的目标是把B拆分成H^n。
00:06:49.633 0.452200 0.326615 <cP>p(x)=p0*x^0+p1*x^1+p2*x^2...=SUM+(pi*x^i)
00:06:52.233 0.475000 0.408269 将矩阵H代入多项式p(x)，得到p(H)，并用其表示矩阵B。
00:06:52.533 0.452200 0.326615 <cB>B<cP>=p(<cH>H<cP>)=p0*<cH>H^0<cP>⊕p1*<cH>H^1<cP>⊕p2*<cH>H^2<cP>⊕...=SUM⊕(pi*<cH>H^i<cP>)
00:06:55.133 0.712500 0.408269 这样，原始求x的问题就变为了p(H)x=y。
00:06:55.433 0.440800 0.326615 <cB>B<cX>x<cP>=p(<cH>H<cP>)<cX>x<cP>=<cY>y
00:06:58.033 0.715350 0.408269 现在，我们需要把多项式p(H)的系数计算出来。这个系数构成的向量我们记为p。
00:06:58.033 0.692550 0.408269 现在，我们需要把多项式p(H)的系数计算出来。这个系数构成的向量我们记为p。
00:06:58.333 0.440800 0.326615 <cP>p=(p0,p1,p2...)
00:07:00.933 0.715350 0.408269 为了简化运算，我们只关心矩阵第一行B(0)，记为b。根据刚才的定义，我们可以得到b=K*p。
00:07:00.933 0.715350 0.408269 为了简化运算，我们只关心矩阵第一行B(0)，记为b。根据刚才的定义，我们可以得到b=K*p。
00:07:01.233 0.353400 0.326615 <cB>b<br><cB>=B(0)<br><cP>=p(<cH>H(0)<cP>)<br><cP>=p0*<cH>H^0(0)<cP>⊕p1*<cH>H^1(0)<cP>⊕p2*<cH>H^2(0)<cP>⊕...<br><cP>=p0*<cK>K(0)<cP>⊕p1*<cK>K(1)<cP>⊕p2*<cK>K(2)<cP>⊕...<br><cP>=<cK>K<cP>p
00:07:01.233 0.416100 0.326615 <cB>b<br><cB>=B(0)<br><cP>=p(<cH>H(0)<cP>)<br><cP>=p0*<cH>H^0(0)<cP>⊕p1*<cH>H^1(0)<cP>⊕p2*<cH>H^2(0)<cP>⊕...<br><cP>=p0*<cK>K(0)<cP>⊕p1*<cK>K(1)<cP>⊕p2*<cK>K(2)<cP>⊕...<br><cP>=<cK>K<cP>p
00:07:01.233 0.440800 0.326615 <cB>b<br><cB>=B(0)<br><cP>=p(<cH>H(0)<cP>)<br><cP>=p0*<cH>H^0(0)<cP>⊕p1*<cH>H^1(0)<cP>⊕p2*<cH>H^2(0)<cP>⊕...<br><cP>=p0*<cK>K(0)<cP>⊕p1*<cK>K(1)<cP>⊕p2*<cK>K(2)<cP>⊕...<br><cP>=<cK>K<cP>p
00:07:01.233 0.452200 0.326615 <cB>b<br><cB>=B(0)<br><cP>=p(<cH>H(0)<cP>)<br><cP>=p0*<cH>H^0(0)<cP>⊕p1*<cH>H^1(0)<cP>⊕p2*<cH>H^2(0)<cP>⊕...<br><cP>=p0*<cK>K(0)<cP>⊕p1*<cK>K(1)<cP>⊕p2*<cK>K(2)<cP>⊕...<br><cP>=<cK>K<cP>p
00:07:01.233 0.440800 0.326615 <cB>b<br><cB>=B(0)<br><cP>=p(<cH>H(0)<cP>)<br><cP>=p0*<cH>H^0(0)<cP>⊕p1*<cH>H^1(0)<cP>⊕p2*<cH>H^2(0)<cP>⊕...<br><cP>=p0*<cK>K(0)<cP>⊕p1*<cK>K(1)<cP>⊕p2*<cK>K(2)<cP>⊕...<br><cP>=<cK>K<cP>p
00:07:01.233 0.399000 0.326615 <cB>b<br><cB>=B(0)<br><cP>=p(<cH>H(0)<cP>)<br><cP>=p0*<cH>H^0(0)<cP>⊕p1*<cH>H^1(0)<cP>⊕p2*<cH>H^2(0)<cP>⊕...<br><cP>=p0*<cK>K(0)<cP>⊕p1*<cK>K(1)<cP>⊕p2*<cK>K(2)<cP>⊕...<br><cP>=<cK>K<cP>p
00:07:04.733 0.399000 0.326615 <cB>b=<cK>K<cP>p
00:07:05.833 0.487350 0.195969    K   
00:07:06.133 0.503025 0.195969 0 1 2 3 4 5 6
00:07:06.133 0.326800 0.195969 0 1 2 3 4 5 6
00:07:06.133 0.330610 0.195969 0 1 2 3 4 5 6
00:07:06.133 0.336270 0.195969 0 1 2 3 4 5 6
00:07:06.133 0.326800 0.195969 0 1 2 3 4 5 6
00:07:06.133 0.328712 0.195969 0 1 2 3 4 5 6
00:07:06.133 0.334414 0.195969 0 1 2 3 4 5 6
00:07:07.533 0.430350 0.195969 p
00:07:09.300 0.493050 0.195969 b
00:07:14.800 0.712500 0.408269 为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1。为了方便我们记为F，又称反Krylov矩阵或解耦矩阵。
00:07:14.800 0.715350 0.408269 为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1。为了方便我们记为F，又称反Krylov矩阵或解耦矩阵。
00:07:15.400 0.503025 0.195969 0 1 2 3 4 5 6 7
00:07:15.400 0.326800 0.195969 0 1 2 3 4 5 6 7
00:07:15.400 0.330610 0.195969 0 1 2 3 4 5 6 7
00:07:15.400 0.336270 0.195969 0 1 2 3 4 5 6 7
00:07:15.400 0.326800 0.195969 0 1 2 3 4 5 6 7
00:07:15.400 0.328712 0.195969 0 1 2 3 4 5 6 7
00:07:15.400 0.334414 0.195969 0 1 2 3 4 5 6 7
00:07:15.400 0.321100 0.195969 0 1 2 3 4 5 6 7
00:07:15.700 0.487350 0.195969 F
00:07:18.900 0.712500 0.408269 这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵F也满足类似的性质。
00:07:18.900 0.712500 0.408269 这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵F也满足类似的性质。
00:07:19.200 0.421800 0.326615 <cK>K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)
00:07:19.500 0.421800 0.326615 <cF>F(n,x)=F(n-1,x-1)⊕F(n-2,x)
00:07:20.700 0.487350 0.195969 K
00:07:23.500 0.487350 0.195969 F
00:07:27.000 0.709650 0.408269 有兴趣的小伙伴可以试着证明一下，使用这两个性质构造的矩阵K和F，证明S=K*F为单位矩阵I。
00:07:27.000 0.712500 0.408269 有兴趣的小伙伴可以试着证明一下，使用这两个性质构造的矩阵K和F，证明S=K*F为单位矩阵I。
00:07:29.600 0.712500 0.408269 提示：矩阵S=K*F满足十字偶校验约束，因此有以上递推公式。
00:07:29.900 0.421800 0.326615 <cI>S(n,x)=S(n-1,x-1)⊕S(n-1,x+1)⊕S(n-2,x)
00:07:34.300 0.715350 0.408269 这里说明一下，矩阵F的每行对应多项式f(n,x)，也就是上一集视频《解的数量》章节中提到的OEIS中的Fibonacci多项式。
00:07:34.300 0.686850 0.408269 这里说明一下，矩阵F的每行对应多项式f(n,x)，也就是上一集视频《解的数量》章节中提到的OEIS中的Fibonacci多项式。
00:07:34.600 0.421800 0.326615 <cF>f(n,x)=x*f(n-1,x)⊕f(n-2,x)
00:07:34.900 0.421800 0.326615 <cF>F(n,x)=F(n-1,x-1)⊕F(n-2,x)
00:07:38.100 0.712500 0.408269 此外，刚才递推得到的C矩阵对应多项式c(n,x)，其实也就是这里提到的f(n,x+1)。
00:07:38.100 0.675450 0.408269 此外，刚才递推得到的C矩阵对应多项式c(n,x)，其实也就是这里提到的f(n,x+1)。
00:07:38.400 0.421800 0.326615 <cC>c(n,x)=x*c(n-1,x)⊕c(n-1,x)⊕c(n-2,x)
00:07:38.700 0.421800 0.326615 <cC>C(n,x)=C(n-1,x-1)⊕C(n-1,x)⊕C(n-2,x)
00:07:39.000 0.421800 0.326615 <cC>c(n,x)<cF>=f(n,x+1)
00:07:39.600 0.712500 0.408269 这个证明也不难，大家可以使用公式求出F和C的递推公式，或者由递推公式反推。
00:07:39.600 0.675450 0.408269 这个证明也不难，大家可以使用公式求出F和C的递推公式，或者由递推公式反推。
00:07:42.200 0.709650 0.408269 同时，B(n)矩阵也可以表示为以上形式。这里的H⊕I等价于x+1。
00:07:42.200 0.681150 0.408269 同时，B(n)矩阵也可以表示为以上形式。这里的H⊕I等价于x+1。
00:07:42.500 0.416100 0.326615 <cB>B(n)=B(n-1)*(<cH>H<cB>⊕<cI>I<cB>)⊕B(n-2)
00:07:42.800 0.421800 0.326615 <cB>B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:07:47.500 0.709650 0.408269 让我们继续求p。由于F和K互逆，我们有：F*b=F*K*p=p。这样我们便求出了p。
00:07:47.500 0.689700 0.408269 让我们继续求p。由于F和K互逆，我们有：F*b=F*K*p=p。这样我们便求出了p。
00:07:47.800 0.399000 0.326615 <cP>p=<cF>F<cB>b
00:07:52.100 0.715350 0.408269 这里，为了和视频演示一致，由于b是竖着的，写为p=F*b，省去了转置符号。对于矩阵乘法运算来说，则有P=B''*F。
00:07:52.100 0.715350 0.408269 这里，为了和视频演示一致，由于b是竖着的，写为p=F*b，省去了转置符号。对于矩阵乘法运算来说，则有P=B''*F。
00:07:52.700 0.487350 0.195969    F   
00:07:53.000 0.503025 0.195969 0 1 2 3 4 5 6
00:07:53.000 0.326800 0.195969 0 1 2 3 4 5 6
00:07:53.000 0.330610 0.195969 0 1 2 3 4 5 6
00:07:53.000 0.336270 0.195969 0 1 2 3 4 5 6
00:07:53.000 0.326800 0.195969 0 1 2 3 4 5 6
00:07:53.000 0.328712 0.195969 0 1 2 3 4 5 6
00:07:53.000 0.334414 0.195969 0 1 2 3 4 5 6
00:07:54.400 0.493050 0.195969 b
00:07:55.833 0.430350 0.195969 p
00:08:00.833 0.712500 0.408269 将多项式p(x)写成矩阵的形式，记为P。
00:08:01.733 0.503025 0.195969 0 1 2 3 4 5 6 7
00:08:01.733 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:01.733 0.330610 0.195969 0 1 2 3 4 5 6 7
00:08:01.733 0.336270 0.195969 0 1 2 3 4 5 6 7
00:08:01.733 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:01.733 0.328712 0.195969 0 1 2 3 4 5 6 7
00:08:01.733 0.334414 0.195969 0 1 2 3 4 5 6 7
00:08:01.733 0.321100 0.195969 0 1 2 3 4 5 6 7
00:08:02.033 0.487350 0.195969 P
00:08:05.533 0.715350 0.408269 有了b*F=p之后，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
00:08:05.533 0.681150 0.408269 有了b*F=p之后，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
00:08:06.133 0.487350 0.195969    F   
00:08:06.433 0.503025 0.195969 0 1 2 3 4 5 6
00:08:06.433 0.326800 0.195969 0 1 2 3 4 5 6
00:08:06.433 0.330610 0.195969 0 1 2 3 4 5 6
00:08:06.433 0.336270 0.195969 0 1 2 3 4 5 6
00:08:06.433 0.326800 0.195969 0 1 2 3 4 5 6
00:08:06.433 0.328712 0.195969 0 1 2 3 4 5 6
00:08:06.433 0.334414 0.195969 0 1 2 3 4 5 6
00:08:07.833 0.493050 0.195969 b
00:08:09.267 0.430350 0.195969 p
00:08:14.167 0.692550 0.408269 这是因为我们已经将问题从Bx=y转为了p(H)=y。由此，在前面说到的生成矩阵也只需要计算第一行b。
00:08:14.167 0.715350 0.408269 这是因为我们已经将问题从Bx=y转为了p(H)=y。由此，在前面说到的生成矩阵也只需要计算第一行b。
00:08:14.767 0.328700 0.130646 B1 B2 B3 B4 B5 B6 B7
00:08:14.767 0.332510 0.130646 B1 B2 B3 B4 B5 B6 B7
00:08:14.767 0.336270 0.130646 B1 B2 B3 B4 B5 B6 B7
00:08:14.767 0.328700 0.130646 B1 B2 B3 B4 B5 B6 B7
00:08:14.767 0.330612 0.130646 B1 B2 B3 B4 B5 B6 B7
00:08:14.767 0.334414 0.130646 B1 B2 B3 B4 B5 B6 B7
00:08:14.767 0.324900 0.130646 B1 B2 B3 B4 B5 B6 B7
00:08:14.800 0.335358 0.130646 n0
00:08:15.133 0.328700 0.130646 n1
00:08:15.467 0.332510 0.130646 n2
00:08:15.800 0.336270 0.130646 n3
00:08:16.133 0.328700 0.130646 n4
00:08:16.467 0.328712 0.130646 n5
00:08:16.800 0.501600 0.130646 n6
00:08:17.133 0.484500 0.130646 n7
00:08:20.067 0.715350 0.408269 由于在不同n的情况下计算b的方式是一样的，我们可以把n-1情况下算出的b，直接用于计算n的情况。
00:08:20.067 0.715350 0.408269 由于在不同n的情况下计算b的方式是一样的，我们可以把n-1情况下算出的b，直接用于计算n的情况。
00:08:20.367 0.421800 0.326615 <cB>b(n,x)=b(n-1,x-1)⊕b(n-1,x)⊕b(n-1,x+1)⊕b(n-2,x)
00:08:20.667 0.421800 0.326615 <cB>B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:08:21.300 0.503025 0.195969 0 1 2 3 4 5 6 7
00:08:21.300 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:21.300 0.330610 0.195969 0 1 2 3 4 5 6 7
00:08:21.300 0.336270 0.195969 0 1 2 3 4 5 6 7
00:08:21.300 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:21.300 0.328712 0.195969 0 1 2 3 4 5 6 7
00:08:21.300 0.334414 0.195969 0 1 2 3 4 5 6 7
00:08:21.300 0.321100 0.195969 0 1 2 3 4 5 6 7
00:08:21.600 0.328700 0.195969 B'
00:08:23.800 0.715350 0.408269 这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
00:08:23.800 0.684000 0.408269 这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
00:08:28.500 0.715350 0.408269 同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
00:08:28.500 0.715350 0.408269 同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
00:08:28.800 0.421800 0.326615 <cK>K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)
00:08:29.400 0.503025 0.195969 0 1 2 3 4 5 6 7
00:08:29.400 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:29.400 0.330610 0.195969 0 1 2 3 4 5 6 7
00:08:29.400 0.336270 0.195969 0 1 2 3 4 5 6 7
00:08:29.400 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:29.400 0.328712 0.195969 0 1 2 3 4 5 6 7
00:08:29.400 0.334414 0.195969 0 1 2 3 4 5 6 7
00:08:29.400 0.321100 0.195969 0 1 2 3 4 5 6 7
00:08:29.700 0.487350 0.195969 K
00:08:33.400 0.421800 0.326615 <cF>F(n,x)=F(n-1,x-1)⊕F(n-2,x)
00:08:34.000 0.503025 0.195969 0 1 2 3 4 5 6 7
00:08:34.000 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:34.000 0.330610 0.195969 0 1 2 3 4 5 6 7
00:08:34.000 0.336270 0.195969 0 1 2 3 4 5 6 7
00:08:34.000 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:34.000 0.328712 0.195969 0 1 2 3 4 5 6 7
00:08:34.000 0.334414 0.195969 0 1 2 3 4 5 6 7
00:08:34.000 0.321100 0.195969 0 1 2 3 4 5 6 7
00:08:34.300 0.487350 0.195969 F
00:08:35.500 0.715350 0.408269 如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
00:08:35.500 0.715350 0.408269 如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
00:08:39.600 0.712500 0.408269 为了求出p=F*b，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
00:08:39.600 0.684000 0.408269 为了求出p=F*b，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
00:08:41.300 0.399000 0.326615 <cP>p=<cF>F<cB>b
00:08:41.900 0.487350 0.195969    F   
00:08:42.200 0.503025 0.195969 0 1 2 3 4 5 6
00:08:42.200 0.326800 0.195969 0 1 2 3 4 5 6
00:08:42.200 0.330610 0.195969 0 1 2 3 4 5 6
00:08:42.200 0.336270 0.195969 0 1 2 3 4 5 6
00:08:42.200 0.326800 0.195969 0 1 2 3 4 5 6
00:08:42.200 0.328712 0.195969 0 1 2 3 4 5 6
00:08:42.200 0.334414 0.195969 0 1 2 3 4 5 6
00:08:43.600 0.493050 0.195969 b
00:08:45.033 0.430350 0.195969 p
00:08:47.133 0.715350 0.408269 因为矩阵F是有递推规律的，理论上使用FFT等算法，可以把乘法优化到O(n*log(n))。
00:08:47.133 0.684000 0.408269 因为矩阵F是有递推规律的，理论上使用FFT等算法，可以把乘法优化到O(n*log(n))。
00:08:49.833 0.715350 0.408269 事实上，这里计算p的时候，我们将B''的对角线去除了，有P=B''*F。假如我们保留B''的对角线，则有C=B'*F。
00:08:49.833 0.712500 0.408269 事实上，这里计算p的时候，我们将B''的对角线去除了，有P=B''*F。假如我们保留B''的对角线，则有C=B'*F。
00:08:50.133 0.353400 0.326615 <cP>P=<cB>B''<cF>F
00:08:50.733 0.503025 0.195969 0 1 2 3 4 5 6 7
00:08:50.733 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:50.733 0.330610 0.195969 0 1 2 3 4 5 6 7
00:08:50.733 0.336270 0.195969 0 1 2 3 4 5 6 7
00:08:50.733 0.326800 0.195969 0 1 2 3 4 5 6 7
00:08:50.733 0.328712 0.195969 0 1 2 3 4 5 6 7
00:08:50.733 0.334414 0.195969 0 1 2 3 4 5 6 7
00:08:50.733 0.321100 0.195969 0 1 2 3 4 5 6 7
00:08:51.033 0.328700 0.195969 B''
00:08:53.633 0.353400 0.326615 <cC>C=<cB>B'<cF>F
00:08:54.233 0.328700 0.195969 B'
00:08:58.833 0.715350 0.408269 为了证明这一点，我们假定B'*F=C'，得出以上递推公式。由于C'的递推公式和C是相同的，因此这里的C'就是C，即C'=C=B'*F。
00:08:58.833 0.712500 0.408269 为了证明这一点，我们假定B'*F=C'，得出以上递推公式。由于C'的递推公式和C是相同的，因此这里的C'就是C，即C'=C=B'*F。
00:08:59.133 0.316350 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.316350 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.336300 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.336300 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.336300 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.336300 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.336300 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.336300 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.336300 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:08:59.133 0.316350 0.244961 <cC>C'(n,x)<br><cC>=(<cB>B'<cC>*<cF>F<cC>)(n,x)<br><cC>=Sum_j:[<cB>B'(n,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[(<cB>B'(n-1,j-1)<cC>⊕<cB>B'(n-1,j)<cC>⊕<cB>B'(n-1,j+1)<cC>⊕<cB>B'(n-2,j))<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j-1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j+1)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j+1,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-1,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j-2,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*(<cF>F(j-1,x-1)<cC>⊕<cF>F(j-2,x))<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=Sum_j:[<cB>B'(n-1,j)<cC>*<cF>F(j,x-1)<cC>⊕<cB>B'(n-1,j)<cC>*<cF>F(j,x)<cC>⊕<cB>B'(n-2,j)<cC>*<cF>F(j,x)<cC>]<br><cC>=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:09:01.433 0.421800 0.326615 <cC>C'(n,x)=C'(n-1,x-1)<cC>⊕C'(n-1,x)<cC>⊕C'(n-2,x)
00:09:04.533 0.698250 0.408269 由于C=B'*F，因此P=C⊕F。我们可以用递推公式计算出C，和F叠加直接求得P，无需使用矩阵乘法。
00:09:04.533 0.715350 0.408269 由于C=B'*F，因此P=C⊕F。我们可以用递推公式计算出C，和F叠加直接求得P，无需使用矩阵乘法。
00:09:04.833 0.416100 0.326615 <cP>P=<cB>B''<cP>*<cF>F<cP>=(<cB>B'<cP>⊕<cI>I<cP>)*<cF>F=<cB>B'<cP>*<cF>F<cP>⊕<cI>I<cP>*<cF>F<cP>=<cC>C<cP>⊕<cF>F
00:09:07.433 0.712500 0.408269 同时，由于P=C⊕F，因此P也可以写成这个递推公式，从而无需B，C或F，直接在O(n)的时间内，由P自己推得。
00:09:07.433 0.715350 0.408269 同时，由于P=C⊕F，因此P也可以写成这个递推公式，从而无需B，C或F，直接在O(n)的时间内，由P自己推得。
00:09:07.733 0.421800 0.326615 <cP>P(n,x)=P(n-1,x)⊕P(n-2,x-1)⊕P(n-2,x-2)⊕P(n-3,x)⊕P(n-4,x)
00:09:10.333 0.476900 0.408269 这个证明较长，因此这里就不展示出来了。有兴趣的观众可以从C和F的递推公式进行证明。
00:09:10.333 0.456000 0.408269 这个证明较长，因此这里就不展示出来了。有兴趣的观众可以从C和F的递推公式进行证明。
00:09:13.833 0.712500 0.408269 现在，我们已求得了p，并将原始问题转换为了p(H)x=y。那这又有什么用呢？
00:09:13.833 0.672600 0.408269 现在，我们已求得了p，并将原始问题转换为了p(H)x=y。那这又有什么用呢？
00:09:14.133 0.661200 0.489923 <cB>B<cX>x<cP>=p(<cH>H<cP>)<cX>x<cP>=<cY>y
00:09:17.033 0.712500 0.408269 试想一下，如果有一个多项式q(x)，满足q(x)*p(x)=1 mod f(x)。
00:09:17.033 0.684000 0.408269 试想一下，如果有一个多项式q(x)，满足q(x)*p(x)=1 mod f(x)。
00:09:17.333 0.440800 0.326615 <cQ>q(x)<cP>p(x)<cI>=1 mod <cF>f(x)
00:09:17.933 0.430350 0.195969 p
00:09:18.533 0.430350 0.195969 q
00:09:19.133 0.433200 0.195969 g
00:09:19.733 0.493050 0.195969 f
00:09:28.833 0.681150 0.408269 这里的f(x)就是前面提到的多项式f(n,x)。那么，将原始两边同时乘以q(H)，便有：x=q(H)*y。
00:09:28.833 0.712500 0.408269 这里的f(x)就是前面提到的多项式f(n,x)。那么，将原始两边同时乘以q(H)，便有：x=q(H)*y。
00:09:29.133 0.440800 0.326615 <cX>x=<cQ>q(<cH>H<cQ>)<cP>p(<cH>H<cP>)<cX>x=<cQ>q(<cH>H<cQ>)<cY>y
00:09:32.533 0.715350 0.408269 这样，我们就能立刻求出x。
00:09:33.133 0.353400 0.195969    Q'   
00:09:33.433 0.503025 0.195969 0 1 2 3 4 5 6
00:09:33.433 0.326800 0.195969 0 1 2 3 4 5 6
00:09:33.433 0.330610 0.195969 0 1 2 3 4 5 6
00:09:33.433 0.336270 0.195969 0 1 2 3 4 5 6
00:09:33.433 0.326800 0.195969 0 1 2 3 4 5 6
00:09:33.433 0.328712 0.195969 0 1 2 3 4 5 6
00:09:33.433 0.334414 0.195969 0 1 2 3 4 5 6
00:09:34.833 0.424650 0.195969 y
00:09:35.933 0.319200 0.195969 x
00:09:39.933 0.692550 0.408269 让我把这样的多项式q(x)我们称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？
00:09:39.933 0.712500 0.408269 让我把这样的多项式q(x)我们称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？
00:09:40.233 0.430350 0.195969 q
00:09:43.433 0.715350 0.408269 我们可以使用扩展欧几里得算法，利用f(x)和p(x)来求取q(x)。
00:09:44.333 0.493050 0.195969 f
00:09:44.633 0.430350 0.195969 p
00:09:45.533 0.330600 0.195969 o
00:09:45.833 0.330600 0.195969 e
00:09:48.433 0.715350 0.408269 这里，我们同时定义一个零多项式o(x)和单位多项式e(x)，在对f(x)和p(x)操作的同时，对o(x)和e(x)做相同的操作。
00:09:48.433 0.715350 0.408269 这里，我们同时定义一个零多项式o(x)和单位多项式e(x)，在对f(x)和p(x)操作的同时，对o(x)和e(x)做相同的操作。
00:09:51.033 0.712500 0.408269 我们使用辗转相减法，将p(x)右移，使其最高系数和f(x)对齐，然后叠加到f(x)上。
00:09:51.033 0.709650 0.408269 我们使用辗转相减法，将p(x)右移，使其最高系数和f(x)对齐，然后叠加到f(x)上。
00:09:54.633 0.715350 0.408269 叠加后，如果f(x)的最高系数仍旧大于等于p(x)，则继续右移p(x)并叠加到f(x)上。
00:09:54.633 0.689700 0.408269 叠加后，如果f(x)的最高系数仍旧大于等于p(x)，则继续右移p(x)并叠加到f(x)上。
00:09:58.233 0.475000 0.408269 否则，当f(x)的最高系数小于p(x)时，将p(x)和f(x)互换。
00:10:01.833 0.715350 0.408269 重复这样操作，直到f(x)最终被叠加为零。
00:10:11.433 0.712500 0.408269 最后剩下的p(x)则为两个多项式的最大公因子，记为g(x)，同时，最后剩下的e(x)则为p(x)的逆，也就是q(x)。
00:10:11.433 0.473100 0.408269 最后剩下的p(x)则为两个多项式的最大公因子，记为g(x)，同时，最后剩下的e(x)则为p(x)的逆，也就是q(x)。
00:10:13.433 0.433200 0.195969 g
00:10:13.733 0.430350 0.195969 q
00:10:16.967 0.475000 0.408269 将q(x)写成矩阵Q。注意，这里的矩阵不是后面提到的完整的逆矩阵Q'，而是多个q(x)拼接起来。
00:10:16.967 0.692550 0.408269 将q(x)写成矩阵Q。注意，这里的矩阵不是后面提到的完整的逆矩阵Q'，而是多个q(x)拼接起来。
00:10:18.367 0.503025 0.195969 0 1 2 3 4 5 6 7
00:10:18.367 0.326800 0.195969 0 1 2 3 4 5 6 7
00:10:18.367 0.330610 0.195969 0 1 2 3 4 5 6 7
00:10:18.367 0.336270 0.195969 0 1 2 3 4 5 6 7
00:10:18.367 0.326800 0.195969 0 1 2 3 4 5 6 7
00:10:18.367 0.328712 0.195969 0 1 2 3 4 5 6 7
00:10:18.367 0.334414 0.195969 0 1 2 3 4 5 6 7
00:10:18.367 0.321100 0.195969 0 1 2 3 4 5 6 7
00:10:18.667 0.530100 0.195969 Q
00:10:23.067 0.712500 0.408269 这里，由于我们已求得q(x)。我们也可以利用这个式子来求x。
00:10:23.367 0.353400 0.326615 <cX>x<br><cQ>=q(<cH>H<cQ>)<cY>y<br><cQ>=(q0*<cH>H^0<cQ>⊕q1*<cH>H^1<cQ>⊕q2*<cH>H^2<cQ>⊕...)*<cY>y<br><cQ>=q0*<cH>H^0*<cY>y<cQ>⊕q1*<cH>H^1*<cY>y<cQ>⊕q2*<cH>H^2*<cY>y<cQ>⊕...<br><cQ>=SUM:qi*<cH>H^i<cQ>*<cY>y
00:10:23.367 0.440800 0.326615 <cX>x<br><cQ>=q(<cH>H<cQ>)<cY>y<br><cQ>=(q0*<cH>H^0<cQ>⊕q1*<cH>H^1<cQ>⊕q2*<cH>H^2<cQ>⊕...)*<cY>y<br><cQ>=q0*<cH>H^0*<cY>y<cQ>⊕q1*<cH>H^1*<cY>y<cQ>⊕q2*<cH>H^2*<cY>y<cQ>⊕...<br><cQ>=SUM:qi*<cH>H^i<cQ>*<cY>y
00:10:23.367 0.452200 0.326615 <cX>x<br><cQ>=q(<cH>H<cQ>)<cY>y<br><cQ>=(q0*<cH>H^0<cQ>⊕q1*<cH>H^1<cQ>⊕q2*<cH>H^2<cQ>⊕...)*<cY>y<br><cQ>=q0*<cH>H^0*<cY>y<cQ>⊕q1*<cH>H^1*<cY>y<cQ>⊕q2*<cH>H^2*<cY>y<cQ>⊕...<br><cQ>=SUM:qi*<cH>H^i<cQ>*<cY>y
00:10:23.367 0.452200 0.326615 <cX>x<br><cQ>=q(<cH>H<cQ>)<cY>y<br><cQ>=(q0*<cH>H^0<cQ>⊕q1*<cH>H^1<cQ>⊕q2*<cH>H^2<cQ>⊕...)*<cY>y<br><cQ>=q0*<cH>H^0*<cY>y<cQ>⊕q1*<cH>H^1*<cY>y<cQ>⊕q2*<cH>H^2*<cY>y<cQ>⊕...<br><cQ>=SUM:qi*<cH>H^i<cQ>*<cY>y
00:10:23.367 0.452200 0.326615 <cX>x<br><cQ>=q(<cH>H<cQ>)<cY>y<br><cQ>=(q0*<cH>H^0<cQ>⊕q1*<cH>H^1<cQ>⊕q2*<cH>H^2<cQ>⊕...)*<cY>y<br><cQ>=q0*<cH>H^0*<cY>y<cQ>⊕q1*<cH>H^1*<cY>y<cQ>⊕q2*<cH>H^2*<cY>y<cQ>⊕...<br><cQ>=SUM:qi*<cH>H^i<cQ>*<cY>y
00:10:25.967 0.712500 0.408269 这里，我们可以从Y开始，不断将其和H相乘，使用左右扩散的办法计算下一个H^n*y，然后和qn叠加，得到x。
00:10:25.967 0.715350 0.408269 这里，我们可以从Y开始，不断将其和H相乘，使用左右扩散的办法计算下一个H^n*y，然后和qn叠加，得到x。
00:10:26.267 0.452200 0.326615 <cX>x<cQ>=q(<cH>H<cQ>)<cY>y<cQ>=SUM:qi*<cH>H^i<cQ>*<cY>y
00:10:27.067 0.421800 0.326615 <cY>Y'(n,x)=Y'(n-1,x-1)+Y'(n-1,x+1)
00:10:27.667 0.328700 0.195969    Y'   
00:10:27.967 0.503025 0.195969 0 1 2 3 4 5 6
00:10:27.967 0.326800 0.195969 0 1 2 3 4 5 6
00:10:27.967 0.330610 0.195969 0 1 2 3 4 5 6
00:10:27.967 0.336270 0.195969 0 1 2 3 4 5 6
00:10:27.967 0.326800 0.195969 0 1 2 3 4 5 6
00:10:27.967 0.328712 0.195969 0 1 2 3 4 5 6
00:10:27.967 0.334414 0.195969 0 1 2 3 4 5 6
00:10:29.367 0.430350 0.195969 q
00:10:30.300 0.319200 0.195969 x
00:10:34.600 0.476900 0.408269 另一方面，q(x)的系数也就是B的逆矩阵Q'的第一行，并且可以证明B的逆矩阵Q'也满足十字偶校验约束。
00:10:34.600 0.452200 0.408269 另一方面，q(x)的系数也就是B的逆矩阵Q'的第一行，并且可以证明B的逆矩阵Q'也满足十字偶校验约束。
00:10:34.900 0.399000 0.326615 <cX>x<cQ>=Q'<cY>y<cQ>
00:10:35.500 0.353400 0.195969    Q'   
00:10:35.800 0.503025 0.195969 0 1 2 3 4 5 6
00:10:35.800 0.326800 0.195969 0 1 2 3 4 5 6
00:10:35.800 0.330610 0.195969 0 1 2 3 4 5 6
00:10:35.800 0.336270 0.195969 0 1 2 3 4 5 6
00:10:35.800 0.326800 0.195969 0 1 2 3 4 5 6
00:10:35.800 0.328712 0.195969 0 1 2 3 4 5 6
00:10:35.800 0.334414 0.195969 0 1 2 3 4 5 6
00:10:38.400 0.712500 0.408269 因此，也可以通过递推公式，利用q(x)直接求出整个逆矩阵Q'，然后再和y相乘获得x。
00:10:38.400 0.475000 0.408269 因此，也可以通过递推公式，利用q(x)直接求出整个逆矩阵Q'，然后再和y相乘获得x。
00:10:39.800 0.424650 0.195969 y
00:10:40.900 0.319200 0.195969 x
00:10:43.400 0.715350 0.408269 不过，这整个求解的过程有一个问题，那就是我们假设满足q(x)p(x)=1 mod f(x)的多项式q(x)存在。
00:10:43.400 0.461700 0.408269 不过，这整个求解的过程有一个问题，那就是我们假设满足q(x)p(x)=1 mod f(x)的多项式q(x)存在。
00:10:46.000 0.475000 0.408269 如果这样的多项式q(x)不存在，我们又当如何呢？
00:10:50.700 0.675450 0.538915 不可逆矩阵
00:10:52.100 0.480700 0.408269 在上一集视频《解的数量》章节中，我们提到公式r'(n)。
00:10:52.400 0.440800 0.326615 <cR>r'(n)=deg(<cG>gcd(<cF>f(n,x)<cG>,<cC>c(n,x)<cG>)<cR>)
00:10:55.000 0.706800 0.408269 这里，gcd表示最大公因子。不难发现，这里的gcd(f,c)就是前面扩展欧几里得算法中的g(x)。
00:10:55.000 0.715350 0.408269 这里，gcd表示最大公因子。不难发现，这里的gcd(f,c)就是前面扩展欧几里得算法中的g(x)。
00:10:55.300 0.440800 0.326615 <cG>g(n,x)=gcd(<cF>f(n,x)<cG>,<cC>c(n,x)<cG>)
00:10:57.900 0.715350 0.408269 同时，由于F=C+P，因此gcd(f,c)和gcd(f,p)是相等的。
00:10:58.200 0.440800 0.326615 <cG>g(n,x)=gcd(<cF>f(n,x)<cG>,<cC>c(n,x)<cG>)=gcd(<cF>f(n,x)<cG>,<cP>p(n,x)<cG>)
00:11:00.800 0.715350 0.408269 deg则表示最高次幂。r'代表矩阵B丢失的秩，也就是n-r。r'的值决定了解的数量，即2^r'。
00:11:00.800 0.476900 0.408269 deg则表示最高次幂。r'代表矩阵B丢失的秩，也就是n-r。r'的值决定了解的数量，即2^r'。
00:11:03.400 0.475000 0.408269 可以发现，如果B是可逆的，则g(x)=1，r'=0，n=r-r'=r。
00:11:06.900 0.712500 0.408269 将g(x)写成矩阵的形式，记为G。
00:11:07.500 0.503025 0.195969 0 1 2 3 4 5 6 7
00:11:07.500 0.326800 0.195969 0 1 2 3 4 5 6 7
00:11:07.500 0.330610 0.195969 0 1 2 3 4 5 6 7
00:11:07.500 0.336270 0.195969 0 1 2 3 4 5 6 7
00:11:07.500 0.326800 0.195969 0 1 2 3 4 5 6 7
00:11:07.500 0.328712 0.195969 0 1 2 3 4 5 6 7
00:11:07.500 0.334414 0.195969 0 1 2 3 4 5 6 7
00:11:07.500 0.321100 0.195969 0 1 2 3 4 5 6 7
00:11:07.800 0.498750 0.195969 G
00:11:08.100 0.440800 0.326615 <cG>g=gcd(<cF>f<cG>,<cC>c<cG>)=gcd(<cF>f<cG>,<cP>p<cG>)
00:11:11.000 0.709650 0.408269 不难注意到，只有当矩阵B为可逆矩阵时，g(x)=1，并且g(x)的最高次幂为n-r=r'。
00:11:11.000 0.459800 0.408269 不难注意到，只有当矩阵B为可逆矩阵时，g(x)=1，并且g(x)的最高次幂为n-r=r'。
00:11:15.100 0.475000 0.408269 例如，当n=5时的时候，高斯消元后的B的伪逆矩阵Q'和单元矩阵E'矩阵是这样的。
00:11:15.100 0.448400 0.408269 例如，当n=5时的时候，高斯消元后的B的伪逆矩阵Q'和单元矩阵E'矩阵是这样的。
00:11:15.400 0.353400 0.326615 <cB>B<cQ>Q'<cE>=E'
00:11:16.600 0.324900 0.195969   B  
00:11:16.900 0.353400 0.195969   Q'  
00:11:17.200 0.328700 0.195969   E'  
00:11:19.800 0.476900 0.408269 这里，矩阵B不可逆，其秩为r=3。我们以rxr为界将矩阵分为四块，则有这些结论。
00:11:19.800 0.475000 0.408269 这里，矩阵B不可逆，其秩为r=3。我们以rxr为界将矩阵分为四块，则有这些结论。
00:11:23.400 0.476900 0.408269 1. B矩阵左上角rxr的子矩阵满秩，并且为和Q'左上角rxr子矩阵互为逆矩阵。
00:11:23.400 0.450300 0.408269 1. B矩阵左上角rxr的子矩阵满秩，并且为和Q'左上角rxr子矩阵互为逆矩阵。
00:11:27.200 0.475000 0.408269 2. Q'右下角和E'左上角为单位矩阵，Q'右上角和E'下方为零。
00:11:27.200 0.454100 0.408269 2. Q'右下角和E'左上角为单位矩阵，Q'右上角和E'下方为零。
00:11:32.633 0.476900 0.408269 3. Q'左下角Wr和E'右上角的静默操作相同，并且其值等于Q'左上角乘B右上角，或者B左下角乘以Q'左上角。
00:11:32.633 0.476900 0.408269 3. Q'左下角Wr和E'右上角的静默操作相同，并且其值等于Q'左上角乘B右上角，或者B左下角乘以Q'左上角。
00:11:38.700 0.475000 0.408269 这些性质可以通过分块矩阵乘法，结合高斯消元和矩阵B的对称性得出，有兴趣的观众可以自行证明。
00:11:38.700 0.684000 0.408269 这些性质可以通过分块矩阵乘法，结合高斯消元和矩阵B的对称性得出，有兴趣的观众可以自行证明。
00:11:42.500 0.475000 0.408269 可以发现，Q'不满足十字偶校验约束，因而无法通过公式递推求得。并且使用Q'第一行求得的x也不是原方程的解。
00:11:42.500 0.456000 0.408269 可以发现，Q'不满足十字偶校验约束，因而无法通过公式递推求得。并且使用Q'第一行求得的x也不是原方程的解。
00:11:43.900 0.353400 0.195969   Q'  
00:11:44.200 0.503025 0.195969 0 1 2 3 4
00:11:44.200 0.326800 0.195969 0 1 2 3 4
00:11:44.200 0.330610 0.195969 0 1 2 3 4
00:11:44.200 0.336270 0.195969 0 1 2 3 4
00:11:44.200 0.326800 0.195969 0 1 2 3 4
00:11:45.600 0.424650 0.195969 y
00:11:46.533 0.319200 0.195969 x
00:11:51.233 0.476900 0.408269 如果我们令Q'第一行为q(x)，并且和p(x)相乘，得到的g(x)不为1，最高次幂为4。
00:11:51.233 0.471200 0.408269 如果我们令Q'第一行为q(x)，并且和p(x)相乘，得到的g(x)不为1，最高次幂为4。
00:11:52.633 0.430350 0.195969 p
00:11:53.233 0.430350 0.195969 q
00:11:53.833 0.433200 0.195969 g
00:11:54.433 0.493050 0.195969 f
00:12:03.333 0.475000 0.408269 另一方面，如果我们直接使用扩展欧几里得法，通过p(x)和f(x)进行求解，得到的g(x)也不为1。
00:12:03.333 0.476900 0.408269 另一方面，如果我们直接使用扩展欧几里得法，通过p(x)和f(x)进行求解，得到的g(x)也不为1。
00:12:04.233 0.493050 0.195969 f
00:12:04.533 0.430350 0.195969 p
00:12:05.433 0.330600 0.195969 o
00:12:05.733 0.330600 0.195969 e
00:12:09.233 0.433200 0.195969 g
00:12:09.533 0.430350 0.195969 q
00:12:13.033 0.475000 0.408269 将求得的q(x)和p(x)相乘，得到刚才求得的g(x)，其最高次幂为2。
00:12:13.033 0.471200 0.408269 将求得的q(x)和p(x)相乘，得到刚才求得的g(x)，其最高次幂为2。
00:12:14.433 0.430350 0.195969 p
00:12:15.033 0.430350 0.195969 q
00:12:15.633 0.433200 0.195969 g
00:12:16.233 0.493050 0.195969 f
00:12:23.233 0.476900 0.408269 这里，我们计算q(H)*y，发现求得的x也不是解。
00:12:24.633 0.440800 0.195969   q(H)  
00:12:24.933 0.503025 0.195969 0 1 2 3 4
00:12:24.933 0.326800 0.195969 0 1 2 3 4
00:12:24.933 0.330610 0.195969 0 1 2 3 4
00:12:24.933 0.336270 0.195969 0 1 2 3 4
00:12:24.933 0.326800 0.195969 0 1 2 3 4
00:12:26.333 0.424650 0.195969 y
00:12:27.267 0.319200 0.195969 x
00:12:32.267 0.475000 0.408269 两种方法求得的q(x)和g(x)都不相同，g(x)都不为1，并且q(H)*y=x也都不是解。
00:12:32.267 0.476900 0.408269 两种方法求得的q(x)和g(x)都不相同，g(x)都不为1，并且q(H)*y=x也都不是解。
00:12:33.467 0.430350 0.195969 p
00:12:33.767 0.430350 0.195969 q
00:12:34.067 0.430350 0.195969 q
00:12:35.267 0.493050 0.195969 f
00:12:35.567 0.433200 0.195969 g
00:12:35.867 0.433200 0.195969 g
00:12:38.467 0.475000 0.408269 因此，如果g(x)不为1，则q(x)不满足q(x)p(x)=1 mod f(x)。或者说，满足q(x)p(x)=1 mod f(x)的q(x)不存在。
00:12:38.467 0.712500 0.408269 因此，如果g(x)不为1，则q(x)不满足q(x)p(x)=1 mod f(x)。或者说，满足q(x)p(x)=1 mod f(x)的q(x)不存在。
00:12:41.667 0.715350 0.408269 那么对于不可逆的矩阵B，我们又有什么解决办法呢？
00:12:41.967 0.353400 0.326615 <cB>B<cQ>Q'<cE>=E'
00:12:43.167 0.324900 0.195969   B  
00:12:43.467 0.353400 0.195969   Q'  
00:12:43.767 0.328700 0.195969   E'  
00:12:47.567 0.684000 0.538915 首行方程法
00:12:49.267 0.681150 0.538915 算法总结
00:12:50.667 0.255431 0.183721 输出
00:12:50.667 0.255431 0.183721 输入
00:12:50.667 0.253294 0.183721 说明
00:12:50.667 0.255431 0.183721 算法
00:12:50.667 0.247950 0.183721 公式
00:12:50.667 0.198788 0.183721 <cL>L
00:12:50.667 0.255431 0.183721 <cL>灯矩阵第一行
00:12:50.667 0.251156 0.183721 <cL>公式递推
00:12:50.667 0.237263 0.183721 <cL><cL>L(n,x)=L(n-1,x-1)⊕L(n-1,x)⊕L(n-1,x+1)⊕L(n-2,x)
00:12:50.667 0.198788 0.183721 <cB>B
00:12:50.667 0.255431 0.183721 <cB>按钮矩阵第一行
00:12:50.667 0.251156 0.183721 <cB>公式递推
00:12:50.667 0.237263 0.183721 <cB><cB>B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
00:12:50.667 0.198788 0.183721 <cY>Y
00:12:50.667 0.255431 0.183721 <cY>灯矩阵最后一行
00:12:50.667 0.251156 0.183721 <cY>公式递推...
00:12:50.667 0.266119 0.183721 <cY><cY>Y(n,y)=~(Y(n-1,y-1)⊕Y(n-1,y)⊕Y(n-1,y+1)⊕Y(n-2,y))
00:12:50.667 0.198788 0.183721 <cH>H
00:12:50.667 0.260775 0.183721 <cH>H^n第一行（Krylov扩散基矩阵）
00:12:50.667 0.251156 0.183721 <cH>公式递推
00:12:50.667 0.266119 0.183721 <cH><cH>H(y,x)=(∣x-y∣=1)
00:12:50.667 0.198788 0.183721 <cK>K
00:12:50.667 0.260775 0.183721 <cK>H^n第一行（Krylov扩散基矩阵）
00:12:50.667 0.251156 0.183721 <cK>公式递推
00:12:50.667 0.237263 0.183721 <cK><cK>K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)
00:12:50.667 0.198788 0.183721 <cF>F
00:12:50.667 0.260775 0.183721 <cF>K的逆矩阵（Krylov解耦矩阵）
00:12:50.667 0.251156 0.183721 <cF>公式递推
00:12:50.667 0.237263 0.183721 <cF><cF>F(n,x)=F(n-1,x-1)⊕F(n-2,x)
00:12:50.667 0.198788 0.183721 <cC>C
00:12:50.667 0.252225 0.183721 <cC>B关于H的系数矩阵
00:12:50.667 0.251156 0.183721 <cC>公式递推
00:12:50.667 0.237263 0.183721 <cC><cC>C(n,x)=C(n-1,x-1)⊕C(n-1,x)⊕C(n-2,x)
00:12:50.667 0.198788 0.183721 <cP>P
00:12:50.667 0.213750 0.183721 <cP>F,b
00:12:50.667 0.257569 0.183721 <cP>多项式p(H)的系数
00:12:50.667 0.252225 0.183721 <cP>矩阵向量乘法
00:12:50.667 0.224438 0.183721 <cP><cP>p=<cF>F<cB>b
00:12:50.667 0.198788 0.183721 <cQ>Q
00:12:50.667 0.224438 0.183721 <cQ>F,p
00:12:50.667 0.258638 0.183721 <cQ>多项式p(x)的在f(x)下的逆
00:12:50.667 0.253294 0.183721 <cQ>扩展欧几里得
00:12:50.667 0.254363 0.183721 <cQ><cQ>q=<cP>p^-1<cQ> mod <cF>F
00:12:50.667 0.198788 0.183721 <cG>G
00:12:50.667 0.213750 0.183721 <cG>F,F
00:12:50.667 0.257569 0.183721 <cG>多项式p(x)和q(x)最大共因子
00:12:50.667 0.253294 0.183721 <cG>扩展欧几里得
00:12:50.667 0.247950 0.183721 <cG><cG>g=gcd(<cF>f<cG>,<cC>c<cG>)=gcd(<cF>f<cG>,<cP>p<cG>)
00:12:50.667 0.198788 0.183721 <cZ>Z
00:12:50.667 0.224438 0.183721 <cZ>Q,y
00:12:50.667 0.254363 0.183721 <cZ>部分逆按钮解
00:12:50.667 0.252225 0.183721 <cZ>矩阵向量乘法
00:12:50.667 0.224438 0.183721 <cZ><cZ>z=<cQ>Q<cY>y
00:12:50.667 0.198788 0.183721 <cD>D
00:12:50.667 0.224438 0.183721 <cD>K,g
00:12:50.667 0.258638 0.183721 <cD>多项式g(x)的矩阵
00:12:50.667 0.252225 0.183721 <cD>矩阵向量乘法
00:12:50.667 0.224438 0.183721 <cD><cD>d=<cK>K<cG>g
00:12:50.667 0.198788 0.183721 <cM>M
00:12:50.667 0.198788 0.183721 <cM>D
00:12:50.667 0.255431 0.183721 <cM>H每一行的主元索引
00:12:50.667 0.244744 0.183721 <cM>求最大值
00:12:50.667 0.234056 0.183721 <cM><cM>M=max(<cD>D(n)<cM>)
00:12:50.667 0.198788 0.183721 <cX>X
00:12:50.667 0.213750 0.183721 <cX>D,z
00:12:50.667 0.255431 0.183721 <cX>最终首行按钮解
00:12:50.667 0.254363 0.183721 <cX>前向异或消元
00:12:50.667 0.198788 0.183721 <cX><cZ>z=<cG>G<cX>x
00:12:50.667 0.198788 0.183721 <cT>T
00:12:50.667 0.198788 0.183721 <cT>x
00:12:50.667 0.254363 0.183721 <cT>最终按钮解矩阵
00:12:50.667 0.251156 0.183721 <cT>公式递推
00:12:50.667 0.237263 0.183721 <cT><cT>T(n,x)=T(n-1,x-1)⊕T(n-1,x)⊕T(n-1,x+1)⊕T(n-2,x)
00:12:53.567 0.681150 0.538915 更快的算法
00:12:54.967 0.476900 0.408269 向量和矩阵的乘法，欧几里得算法，以及K矩阵的生成，理论上通过卷积，FFT或牛顿迭代法是有可能优化到O(n*log(n))的。
00:12:54.967 0.473100 0.408269 向量和矩阵的乘法，欧几里得算法，以及K矩阵的生成，理论上通过卷积，FFT或牛顿迭代法是有可能优化到O(n*log(n))的。
00:12:57.567 0.480700 0.408269 考虑到UP主《信号与系统》、《数字信号处理》、《数值分析》等课程较差，暂时就不研究了。有兴趣的小伙伴可自行研究并留言。
00:12:57.567 0.454100 0.408269 考虑到UP主《信号与系统》、《数字信号处理》、《数值分析》等课程较差，暂时就不研究了。有兴趣的小伙伴可自行研究并留言。
00:13:00.167 0.476900 0.408269 如果对视频中的内容有疑问，觉得视频内容表述不清，或者发现视频中的任何错误，也请大家多多留言和指证。谢谢大家观看！
00:13:00.167 0.475000 0.408269 如果对视频中的内容有疑问，觉得视频内容表述不清，或者发现视频中的任何错误，也请大家多多留言和指证。谢谢大家观看！
