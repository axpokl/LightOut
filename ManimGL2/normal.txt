00:00:00.000 1.004625 0.538915 反向消元法
00:00:01.400 0.721050 0.408269 在刚才的《首行求逆法》中，我们有这些公式。
00:00:01.700 0.440800 0.326615 <cQ>q(x)<cP>p(x)<cI>=1 mod <cF>f(x)
00:00:02.000 0.440800 0.326615 <cP>p(H)<cX>x=<cY>y
00:00:02.300 0.440800 0.326615 <cX>x=<cQ>q(H)<cY>y
00:00:04.900 0.715350 0.408269 现在，我们定义多项式q'(x)，满足q'(x)*p(x)=g(x) mod f(x)。
00:00:04.900 0.684000 0.408269 现在，我们定义多项式q'(x)，满足q'(x)*p(x)=g(x) mod f(x)。
00:00:05.200 0.661200 0.326615 <cQ>q'(x)<cP>p(x)<cG>=g(x) mod <cF>f(x)
00:00:08.300 0.709650 0.408269 其中，g(x)也就是刚才提到的最大公因子，q'(x)就是刚才求得的q(x)。
00:00:08.300 0.689700 0.408269 其中，g(x)也就是刚才提到的最大公因子，q'(x)就是刚才求得的q(x)。
00:00:08.600 0.440800 0.326615 <cG>g(x)=gcd(<cP>p(x)<cG>,<cF>f(x)<cG>)
00:00:11.200 0.715350 0.408269 由于原本求得的x已不是最终解而是部分解，我们将其重命名为z，即z=q'(H)*y。
00:00:11.200 0.715350 0.408269 由于原本求得的x已不是最终解而是部分解，我们将其重命名为z，即z=q'(H)*y。
00:00:11.500 0.440800 0.326615 <cP>p(H)<cX>x=<cY>y
00:00:12.300 0.440800 0.326615 <cZ>z=<cQ>q'(H)<cY>y
00:00:15.400 0.715350 0.408269 同时，我们定义q'(x)的逆多项式p'(x)，即q'(x)*p'(x)=1 mod f(x)。
00:00:15.400 0.661200 0.408269 同时，我们定义q'(x)的逆多项式p'(x)，即q'(x)*p'(x)=1 mod f(x)。
00:00:15.700 0.440800 0.326615 <cQ>q'(x)<cP>p'(x)<cI>=1 mod <cF>f(x)
00:00:18.300 0.678300 0.408269 我们不难推出以下结论。为了方便表示，我将mod f(x)的部分省去。
00:00:18.300 0.712500 0.408269 我们不难推出以下结论。为了方便表示，我将mod f(x)的部分省去。
00:00:18.600 0.661200 0.326615 <cQ>q'(x)<cP>p(x)<cG>=g(x)
00:00:19.400 0.440800 0.326615 <cQ>q'(x)<cP>p'(x)<cI>=1
00:00:20.200 0.661200 0.326615 <cP>p'(x)<cQ>q'(x)<cP>p(x)<cG>=<cP>p'(x)<cG>g(x)
00:00:20.500 0.661200 0.326615 <cQ>q'(x)=<cQ>q'(x)<cP>p(x)<cQ>q(x)<cG>=g(x)<cQ>q(x)
00:00:20.800 0.440800 0.326615 <cP>p(H)<cX>x=<cG>g(H)<cP>p'(H)<cX>x=<cP>p'(H)<cZ>z=<cP>p'(H)<cQ>q'(H)<cY>y=y
00:00:21.100 0.440800 0.326615 <cZ>z=<cQ>q'(H)<cY>y=<cQ>q'(H)<cP>p(H)<cX>x=<cG>g(H)<cX>x
00:00:21.400 0.440800 0.326615 <cG>g(H)<cY>y=<cQ>q'(H)<cP>p(H)<cY>y=<cG>g(H)<cP>p(H)<cX>x
00:00:24.000 0.709650 0.408269 整理后，我们可以得到这些式子。
00:00:24.300 0.661200 0.326615 <cG>g(x)=<cQ>q'(x)<cP>p(x)
00:00:25.100 0.661200 0.326615 <cI>1=<cQ>q'(x)<cP>p'(x)
00:00:25.900 0.661200 0.326615 <cP>p(x)=p'(x)<cG>g(x)
00:00:26.700 0.661200 0.326615 <cQ>q'(x)=q(x)<cG>g(x)
00:00:27.500 0.440800 0.326615 <cY>y=<cP>p(H)<cX>x
00:00:28.300 0.440800 0.326615 <cZ>z=<cQ>q'(H)<cY>y
00:00:29.100 0.440800 0.326615 <cY>y=<cP>p'(H)<cZ>z
00:00:29.900 0.440800 0.326615 <cZ>z=<cG>g(H)<cX>x
00:00:30.700 0.440800 0.326615 <cQ>q'(H)<cY>y=<cG>g(H)<cX>x
00:00:31.500 0.440800 0.326615 <cY>y=<cP>p(H)<cX>x=<cP>p'(H)<cZ>z
00:00:32.300 0.440800 0.326615 <cZ>z=<cQ>q'(H)<cY>y<cZ>=<cG>g(H)<cX>x
00:00:33.100 0.440800 0.326615 <cZ>z=<cQ>q'(H)<cY>y<cZ>=<cG>g(H)<cX>x
00:00:36.600 0.712500 0.408269 这里，如果g(x)=1，则会有以上式子。
00:00:36.900 0.440800 0.326615 <cG>g(x)=<cI>1
00:00:37.200 0.661200 0.326615 <cQ>q'(x)=q(x)
00:00:37.500 0.661200 0.326615 <cP>p'(x)=p(x)
00:00:37.800 0.353400 0.326615 <cZ>z=<cX>x
00:00:43.100 0.476900 0.408269 前面使用的扩展欧几里得法中，我们已求得q'(x)和g(x)。因此，接下来只需要使用g(x)和z求得x即可。
00:00:43.100 0.712500 0.408269 前面使用的扩展欧几里得法中，我们已求得q'(x)和g(x)。因此，接下来只需要使用g(x)和z求得x即可。
00:00:43.400 0.452200 0.326615 <cQ>q'(x)=<cP>p(x)^-1<cI> mod <cF>f(x)
00:00:46.000 0.715350 0.408269 前者，我们有公式z=q'(H)y。我们不断把y和H叠加，然后利用向量乘以矩阵的方式求得z。
00:00:46.000 0.712500 0.408269 前者，我们有公式z=q'(H)y。我们不断把y和H叠加，然后利用向量乘以矩阵的方式求得z。
00:00:46.300 0.440800 0.326615 <cZ>z=<cQ>q'(H)<cY>y
00:00:49.400 0.709650 0.408269 现在，我们有公式z=g(H)x。由于需要求得的是x，需要用反向叠加的方式来求得。
00:00:49.400 0.712500 0.408269 现在，我们有公式z=g(H)x。由于需要求得的是x，需要用反向叠加的方式来求得。
00:00:49.700 0.440800 0.326615 <cZ>z=<cG>g(H)<cX>x
00:00:53.400 0.440800 0.326615 <cZ>z=<cG>g(H)<cX>x
00:00:54.500 0.712500 0.408269 以n=5为例，我们首先需要使用类似生成B矩阵的方法，生成g(H)，记为矩阵D。
00:00:54.500 0.709650 0.408269 以n=5为例，我们首先需要使用类似生成B矩阵的方法，生成g(H)，记为矩阵D。
00:00:57.100 0.715350 0.408269 1. 创建n个单位向量，也就是D矩阵的第一行。这里和B矩阵相同，一共有n个向量。
00:00:57.100 0.712500 0.408269 1. 创建n个单位向量，也就是D矩阵的第一行。这里和B矩阵相同，一共有n个向量。
00:00:59.200 0.715350 0.408269 2. 使用H矩阵，将每个D矩阵第一行扩散到下面的行。
00:01:01.800 0.715350 0.408269 3. 根据多项式g(x)，将每个D矩阵的对应行叠加起来，叠加完的行共同构成一个新的D矩阵。
00:01:01.800 0.684000 0.408269 3. 根据多项式g(x)，将每个D矩阵的对应行叠加起来，叠加完的行共同构成一个新的D矩阵。
00:01:17.833 0.715350 0.408269 可以发现，这里的步骤和首行叠加法类似，共有n个矩阵要生成，时间复杂度是O(n^3)。
00:01:17.833 0.715350 0.408269 可以发现，这里的步骤和首行叠加法类似，共有n个矩阵要生成，时间复杂度是O(n^3)。
00:01:20.433 0.715350 0.408269 不过，聪明的你一定能猜到，通过《生成矩阵法》调换矩阵的行以后，这些矩阵也都满足十字偶校验约束。
00:01:20.433 0.721050 0.408269 不过，聪明的你一定能猜到，通过《生成矩阵法》调换矩阵的行以后，这些矩阵也都满足十字偶校验约束。
00:01:29.033 0.715350 0.408269 因此。我们同样只需要生成第一个矩阵，然后递推就行。
00:01:36.233 0.712500 0.408269 生成第一个矩阵的过程中，每行乘以H矩阵的结果，就是刚才的K矩阵。
00:01:36.233 0.715350 0.408269 生成第一个矩阵的过程中，每行乘以H矩阵的结果，就是刚才的K矩阵。
00:01:36.533 0.399000 0.326615 <cD>d=<cK>K<cG>g
00:01:37.133 0.487350 0.195969   K  
00:01:37.433 0.503025 0.195969 0 1 2 3 4
00:01:37.433 0.326800 0.195969 0 1 2 3 4
00:01:37.433 0.330610 0.195969 0 1 2 3 4
00:01:37.433 0.336270 0.195969 0 1 2 3 4
00:01:37.433 0.326800 0.195969 0 1 2 3 4
00:01:38.033 0.712500 0.408269 因此，只需要将g(x)和K直接相乘，即可得到第一个矩阵的最后一行，即D矩阵的第一行。
00:01:38.033 0.715350 0.408269 因此，只需要将g(x)和K直接相乘，即可得到第一个矩阵的最后一行，即D矩阵的第一行。
00:01:39.433 0.433200 0.195969 g
00:01:40.367 0.328700 0.195969 d
00:01:45.367 0.712500 0.408269 然后，我们就可以使用十字偶校验约束的递推关系，求得之后的行。
00:01:45.367 0.681150 0.408269 然后，我们就可以使用十字偶校验约束的递推关系，求得之后的行。
00:01:53.067 0.709650 0.408269 由于D矩阵是由H矩阵生成的，D矩阵有这些性质。这里，r'=n-r=deg(g(x))。n=5，r=3，r'=2。
00:01:53.067 0.706800 0.408269 由于D矩阵是由H矩阵生成的，D矩阵有这些性质。这里，r'=n-r=deg(g(x))。n=5，r=3，r'=2。
00:01:53.367 0.440800 0.326615 <cR>r'=n-r=deg(<cG>g(x)<cR>)
00:01:55.967 0.715350 0.408269 1. 后r行，第n行最左边的n-r'-1个元素为0。
00:01:59.467 0.715350 0.408269 2. 后r行，第n行第n-r'的元素为1。
00:02:02.667 0.715350 0.408269 3. 后r行，线性无关，即任意一行都不能由别的行叠加。
00:02:06.167 0.715350 0.408269 4. 前r'行，任意一行都可以由后r行叠加。
00:02:09.667 0.706800 0.408269 这些性质都不难证明。由于视频时长有限，有兴趣的观众朋友可以自行证明。
00:02:09.667 0.684000 0.408269 这些性质都不难证明。由于视频时长有限，有兴趣的观众朋友可以自行证明。
00:02:12.867 0.709650 0.408269 现在，我们有z=D*x=g(H)x。
00:02:13.167 0.661200 0.326615 <cZ>z=<cD>D<cX>x<cZ>=<cG>g(H)<cX>x
00:02:16.267 0.715350 0.408269 接下来，我们只需要将z拆解成不同D行的叠加，就能表式出x。
00:02:16.867 0.487350 0.195969   D  
00:02:17.167 0.503025 0.195969 0 1 2 3 4
00:02:17.167 0.326800 0.195969 0 1 2 3 4
00:02:17.167 0.330610 0.195969 0 1 2 3 4
00:02:17.167 0.336270 0.195969 0 1 2 3 4
00:02:17.167 0.326800 0.195969 0 1 2 3 4
00:02:18.567 0.319200 0.195969 x
00:02:19.500 0.319200 0.195969 z
00:02:21.000 0.715350 0.408269 由于D矩阵后3行线性无关，因此我们只需要将后3行叠加起来即可。
00:02:24.200 0.681150 0.408269 让我们观察z的第1个元素和D的后三行。在D的后3行种中，只有第3行的第1个元素为1。
00:02:24.200 0.715350 0.408269 让我们观察z的第1个元素和D的后三行。在D的后3行种中，只有第3行的第1个元素为1。
00:02:27.400 0.712500 0.408269 因此，如果z的第1个元素为1，我们需要将第3行叠加上去，并标记X的第3个元素为1。
00:02:27.400 0.715350 0.408269 因此，如果z的第1个元素为1，我们需要将第3行叠加上去，并标记X的第3个元素为1。
00:02:30.000 0.712500 0.408269 幸运的是，z的第1个元素为0，因此我们可以跳过这一步骤。
00:02:30.000 0.678300 0.408269 幸运的是，z的第1个元素为0，因此我们可以跳过这一步骤。
00:02:32.900 0.712500 0.408269 我们再看z的第2个元素，该元素为1。因此，我们需要将第4行叠加到z上，同时标记X的第4个元素为1。
00:02:32.900 0.715350 0.408269 我们再看z的第2个元素，该元素为1。因此，我们需要将第4行叠加到z上，同时标记X的第4个元素为1。
00:02:36.100 0.712500 0.408269 现在，z的第2个元素被消去，变成了00111。我们接着看z的第3个元素。
00:02:36.100 0.678300 0.408269 现在，z的第2个元素被消去，变成了00111。我们接着看z的第3个元素。
00:02:40.100 0.712500 0.408269 由于z的第3个元素变为了1，我们需要叠加D的第5行并标记x的第5个元素。
00:02:40.100 0.681150 0.408269 由于z的第3个元素变为了1，我们需要叠加D的第5行并标记x的第5个元素。
00:02:43.300 0.712500 0.408269 这次，z被彻底消去变为了零，而x变为了00011。
00:02:47.300 0.715350 0.408269 由此，我们通过依次叠加D的后3行，将z的元素依次消去。同时，将叠加的行标记为1，也就是最终的x。
00:02:47.300 0.715350 0.408269 由此，我们通过依次叠加D的后3行，将z的元素依次消去。同时，将叠加的行标记为1，也就是最终的x。
00:02:50.800 0.684000 0.408269 不难发现这里求得的x是一个特解。
00:02:53.400 0.715350 0.408269 由于前r'行可以表示为后r行的线性叠加，因此我们可以在操作y之前，先将其和前r'的任意行叠加，然后再求解。
00:02:53.400 0.715350 0.408269 由于前r'行可以表示为后r行的线性叠加，因此我们可以在操作y之前，先将其和前r'的任意行叠加，然后再求解。
00:02:56.300 0.715350 0.408269 由于前r'行共有2^r'种，因此求得的解也有2^r'种。
00:02:59.500 0.712500 0.408269 另一方面，由于D矩阵满足十字偶校验约束，表现出高度的对称性。其中，行和列的坐标可以互换。
00:02:59.500 0.715350 0.408269 另一方面，由于D矩阵满足十字偶校验约束，表现出高度的对称性。其中，行和列的坐标可以互换。
00:03:03.000 0.715350 0.408269 因此，我们可以同样只叠加前r行，从右往左进行消元。由于效果是相同的，这里不再赘述。
00:03:03.000 0.715350 0.408269 因此，我们可以同样只叠加前r行，从右往左进行消元。由于效果是相同的，这里不再赘述。
00:03:11.100 0.712500 0.408269 细心的观众会发现，其实这两个式子有相同的形式。
00:03:11.700 0.712500 0.408269 既然我们可以在第二个式子用反向消元法求x，为什么不能用相同的方法在第一个式子求x呢？
00:03:11.700 0.681150 0.408269 既然我们可以在第二个式子用反向消元法求x，为什么不能用相同的方法在第一个式子求x呢？
00:03:12.300 0.715350 0.408269 事实上，这种方法求得的x并不正确。
00:03:12.900 0.709650 0.408269 这因为这里的D矩阵是由g(H)生成的，具有满足带状上三角的可回代结构，即上述的四个性质。
00:03:12.900 0.712500 0.408269 这因为这里的D矩阵是由g(H)生成的，具有满足带状上三角的可回代结构，即上述的四个性质。
00:03:13.500 0.712500 0.408269 而B=p'(H)D破坏了这一结构，不满足这些性质。
00:03:14.100 0.715350 0.408269 不过，当g=1时，这个种解法是可行的。尽管这个办法首先需要求出完整的B矩阵。
00:03:14.100 0.684000 0.408269 不过，当g=1时，这个种解法是可行的。尽管这个办法首先需要求出完整的B矩阵。
00:03:14.700 0.715350 0.408269 同时，因为B矩阵不是三角结构，还需标记每行首个i的位置来选择。因此，直接计算q(H)*Y会更加方便。
00:03:14.700 0.715350 0.408269 同时，因为B矩阵不是三角结构，还需标记每行首个i的位置来选择。因此，直接计算q(H)*Y会更加方便。
00:03:15.300 0.709650 0.408269 最终，我们通过欧几里得法和反向消元法，完成了Bx=y的求解，实现了点灯游戏在O(n^2)时间复杂度的算法。
00:03:15.300 0.715350 0.408269 最终，我们通过欧几里得法和反向消元法，完成了Bx=y的求解，实现了点灯游戏在O(n^2)时间复杂度的算法。
