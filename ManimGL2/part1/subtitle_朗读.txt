在上集视频的首行叠加法中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。<break time="1000ms" />
我们用B代表按钮，L代表灯，加代表叠加，非代表翻转。<break time="1000ms" />
n代表从上到下第n行灯或按钮。因为我们是一行行进行推导的，n也代表第n次推导。<break time="1000ms" />
x代表从左到右第x列按钮。将灯表示为第一行的某几个列的按钮的叠加。这里的x不局限于第一行。<break time="1000ms" />
y代表从左到右第y列灯。这里的公式对任意第y个灯都满足，所以省去了y。<break time="1000ms" />
在上集视频中，因为最终目标是将灯用按钮表示，因此省去了按钮表示按钮，粉色原点直接为按钮表示灯。<break time="1000ms" />
在这里，粉色原点是用按钮表示按钮，淡蓝色方块是用按钮表示灯。<break time="1000ms" />
让我们举一个具体的例子。在5乘5的格子中，我们将灯和按钮编号为1-25。<break time="1000ms" />
在叠加法中，我们将灯表示为所有按钮的叠加。例如：L1=B1加B2加B6，L6=B1加B6加B7加B11。<break time="1000ms" />
通过这种方式我们得到了25元一次方程组。写成增广矩阵，也就是按钮矩阵加灯向量的形式。<break time="1000ms" />
而在首行叠加法中，我们需要把灯表示为第一行按钮的叠加。<break time="1000ms" />
这里的五个矩阵，分别代表第y列是由第一行的哪几个按钮叠加的。<break time="1000ms" />
由于按法是动态的，当第二行按钮还未被按下时，L1=B1加B2，即第一个灯L1，是由第一行的一、<phoneme alphabet="sapi" ph="er 4">二</phoneme>个按钮，即B1,B2叠加的。<break time="1000ms" />
然后，B6=非L1=非(B1加B2)，即<mstts:ttsbreak strength="none">第六个按钮B6</mstts:ttsbreak>是<break time="50ms" />第一个灯L1的翻转。因此，<mstts:ttsbreak strength="none">第二行按钮B6</mstts:ttsbreak>和第一行灯L1的叠加状态是相同的。<break time="1000ms" />
旁边的向量，代表的是按钮或灯有没有翻转。<break time="1000ms" />
例如，当第一个向量的第一个灯亮起时，表示第一个灯除了由刚才说的按钮叠加外，还需要再翻转才是正确的状态。<break time="1000ms" />
同理，B7=非L2=非(B1加B2加B3)，即<mstts:ttsbreak strength="none">第七个按钮B6</mstts:ttsbreak>是<break time="50ms" />第二个灯L2的翻转。同样，<mstts:ttsbreak strength="none">第二行的按钮B7</mstts:ttsbreak>和第一行灯L2的叠加状态是相同的。<break time="1000ms" />
这里，我们将第一个按钮B1的状态补全。将B1用第一行的按钮叠加时，有B1=B1。<break time="1000ms" />
接下来我们来看第六个灯。L6=B1加B6加B7=B1加B3。<break time="1000ms" />
又比如，L7=B2加B6加B7加B8=非B4。<break time="1000ms" />
这样不断递推，我们可以将任意L表示为某些B1到B5的叠加，再加上翻转非。<break time="1000ms" />
现在，如果我们把序号1-25用<mstts:ttsbreak strength="none">坐标x和y</mstts:ttsbreak>表示，则灯和按钮矩阵可写为上述公式。让我们以L7(2)=<mstts:ttsbreak strength="none">L(2<break time="50ms" />2<break time="50ms" />2)</mstts:ttsbreak>为例。<break time="1000ms" />
这里，我们的矩阵同时满足另一个性质，称之为十字偶校验约束。<break time="1000ms" />
某个元素的左右两个矩阵的对应位置的元素，和元素所在矩阵左右两个元素的叠加后为零。<break time="1000ms" />
这就是之前视频中，优化生成矩阵章节中的性质，后面我会给予证明。<break time="1000ms" />
通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。<break time="1000ms" />
因此，我们可以在公式中去除y。去除y后，灯可以表示为当前矩阵的<mstts:ttsbreak strength="none">上左中右</mstts:ttsbreak>的按钮的叠加。<break time="1000ms" />
又因为，下一行的按钮是当前灯的翻转。<break time="1000ms" />
以及，下一行的灯<break time="50ms" />是<mstts:ttsbreak strength="none">上左中右</mstts:ttsbreak>的灯的翻转的叠加。<break time="1000ms" />
如果把翻转非提取出来，便有了一开始的推导公式。<break time="1000ms" />
也就是，按钮<break time="50ms" />是上一行的<mstts:ttsbreak strength="none">左中右</mstts:ttsbreak>按钮和上上<phoneme alphabet="sapi" ph="hang 2">行</phoneme>的按钮的叠加。<break time="1000ms" />
以及，灯是上一行的<mstts:ttsbreak strength="none">左中右</mstts:ttsbreak>按钮和上上<phoneme alphabet="sapi" ph="hang 2">行</phoneme>的灯的叠加。<break time="1000ms" />
可以注意到，按钮和灯的递推公式具有相同的形式，这是因为上一行灯就是下一行按钮。<break time="1000ms" />
因为最终需要推导的是灯矩阵，因此灯矩阵是从按钮的<mstts:ttsbreak strength="none">第一行推导5行</mstts:ttsbreak>。因为最后一次推导的是灯，因此按钮矩阵也是5行。<break time="1000ms" />
对于翻转的情况，则可以单独列出来，以类似的方法推导，写成公式Y。<break time="1000ms" />
下一行的翻转是上一行<mstts:ttsbreak strength="none">左中右</mstts:ttsbreak><break time="50ms" />和上上<phoneme alphabet="sapi" ph="hang 2">行</phoneme>叠加后的翻转。<break time="1000ms" />
可以注意到，这里的公式Y和公式B的推导公式是类似的的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号非。<break time="1000ms" />
一<break time="300ms" />使用零向量。第一次翻转发生在从一到二行的推导过程中，在此之前没有发生过翻转，因此Y的第一行是全零。<break time="1000ms" />
二<break time="300ms" />翻转符号非必须存在。每次推导都需要翻转，因此不可省略。而前者将这个翻转取出来了，因此不用翻转符号非。<break time="1000ms" />
三<break time="300ms" />不使用x而使用y。翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。<break time="1000ms" />
在生成优化矩阵章节中，我将矩阵的行重排。其实是调换了n和y的位置，使原来从左到右的第y个矩阵变为了第n个矩阵。<break time="1000ms" />
这n个矩阵都满足十字偶校验约束，即上下左右四个格子叠加为零，因此这里的公式省去了n。<break time="1000ms" />
这里和之前的情况是一样的，只不过n和y调换了，因此位置发生了变化。<break time="1000ms" />
这是一个十分重要的性质。通过这个性质，可以由第一个灯直接推导后面的灯。<break time="1000ms" />
在后面会说的O的n方算法中，其本质也是利用这个性质进行的优化。<break time="1000ms" />
下面让我用数学归纳法，证明这个性质。<break time="1000ms" />
由于右边的按钮矩阵就是左边的灯矩阵，为了方便，我们就只看按钮矩阵。<break time="1000ms" />
首先，我们假定前两个矩阵Bn减一和Bn减二满足这个性质，现在来证明Bn也满足这个性质。<break time="1000ms" />
将刚才的矩阵递推关系加上参数y并重写。<break time="1000ms" />
对于Bn，我们将式子竖着写成四项，然后将递推关系代入这个式子。<break time="1000ms" />
代入后的式子包含16个项目。现在重新排列项目顺序，将y和n调换，类似刚才<mstts:ttsbreak strength="none">生成矩阵章节中的</mstts:ttsbreak>调换操作。<break time="1000ms" />
不难发现，这四项属于Bn减一或Bn减二，并且元素之间的关系满足十字偶校验约束，因此整个式子化为了零。<break time="1000ms" />
现在，我们只需要证明最左边两个矩阵也满足这个性质即可。第一个矩阵是单位矩阵，显然满足这个性质。<break time="1000ms" />
第二个矩阵可以表示为左边两个矩阵的叠加。由于单位矩阵左边没有矩阵，因此相当于叠加了一个零矩阵。<break time="1000ms" />
由于零矩阵显然满足这个性质，因此第二个矩阵也满足这个性质。<break time="1000ms" />
因为Bn有了这个性质，我们只需要知道Bn的第一行，就能通过公式推导出下面的行。<break time="1000ms" />
通过这种方法，我们无需对每个y都生成矩阵B，只需计算这些B矩阵的第一行，得到Bn的第一行，即可求得完整的矩阵Bn。<break time="1000ms" />
