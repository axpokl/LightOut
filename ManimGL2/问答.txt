这样，假设B满秩，我们先推推看。

1. 
我理解：
B(n)=p(H):=p0​I⊕p1​H⊕p2​H2⊕⋯.
BX=Y⟺p(H)X=Y.
这里是用多项式把p把B拆开来。
但是，为什么p = B(n) * F？如何证明p可以这么计算？

2. 
接下来就是要求p(H)X=Y
于是X=p^-1(H)Y
令q(H)=p^-1(H)，于是有：
p(x)q(x)≡1 (modχ(x))
p(H)q(H)=1
X=q(h)Y
我不知道上面的几个公式的逻辑关系（哪个先哪个后）
不过可以理解p和q互为逆，因此求得q就可以求得X（因为Y已知）
这里求得p用到了函数：q = rev(F(n), p)
这里又和F有关。这个函数为什么能求得q？为什么又是用到了F？

3. 
因为可逆，所以g(H)=1,因此X=Z
所以，可以直接用X=q(h)Y得到解。
否则，p(H)X=Y⟹g(H)X=p(H)q(H)X=q(H)Y=Z
也就是g(H)=q(H)Y=Z，这个我们之后再说。​


1. 代码中的rev(f[n], p, q)和gcd(f[n], p, g)有什么区别？

2. 是不是对于p(x)q(x)≡g(x)(modχ(x)),一个是求q(x)，一个是求g(x)？

3. 为什么一个p(x)可以同时求出q(x)和g(x)？两种算法有什么不同？

4. 为什么两种算法都用到了F？

5. 为什么一开始计算p(x)也用到F？这个F怎么这么神奇？F到底有什么性质？

上面尽量用简单的式子来说。你刚才说的这个式子有点复杂。
a=k=0∑n−1​pk​ϕk​(H)e0​.
