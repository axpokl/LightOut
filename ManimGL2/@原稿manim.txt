《点灯游戏的O(n^2)解法》

【演示】完整演示5x5的O(n^2)递推

《首行叠加法》

上次我们在首行叠加法中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。
【演示】显示5x5矩阵排列好

B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
【演示】在上方显示公式

这里，我们用B表示按钮，L表示灯。n,x,y则表示为：

n:从上到下第n行：灯或按钮，也代表第y次迭代，因为我们是一行一行进行推导的。
x:从左到右第x列按钮：需要将灯表示为第一行的某几个列的按钮的叠加，这里的x不局限于第一行。
y:从左到右第y列灯：这里的公式对任意第y个灯都满足，所以省去。
【演示】创建灯和按钮矩阵（5x5），标记n,x,y（1..5)
【演示】显示并朗读上面文本

——————————————————————

让我们举一个具体的例子，在5x5的格子中，L代表灯，B代表按钮，⊕（加）代表叠加，~（非）代表翻转，并将灯和按钮编号1-25。
【演示】创建大矩阵(25x25)，以及灯向量，标记数字1-25

在叠加法中，我们将灯表示为所有按钮的叠加，例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
【演示】将L1,B1,B2,B6点亮，然后转移到右边的大矩阵和向量种，L6同理
通过这种方式我们得到了25元一次方程组，写成了增广矩阵，也就是按钮矩阵加灯向量的形式
【演示】填满所有25行（可以从左边第一列开始继续）

而在首行叠加法中，我们需要把灯表示为第一行按钮的叠加。
【演示】画出五个矩阵和灯向量。
这里的五个矩阵，分别代表第n列的按钮或灯是由第一行的哪几个按钮叠加的。例如，当第一个矩阵的第一、二个灯亮起时，表示第一个灯由第一行的一、二个按钮叠加。
而旁边的向量，代表的是按钮或灯有没有翻转。例如当第一个向量的第一个灯亮起时，代表第一个灯除了由刚才说的按钮叠加，还需要翻转才是正确状态。
【演示】亮起第一行两个灯，还有灯向量（第一个）
由于按法是动态的。在B6还没有按下时，L1=B1⊕B2（第一个灯由第一行的一、二个按钮叠加），然后B6=~L1=~(B1⊕B2)（第六个按钮是第一个灯的翻转）。
【演示】亮起第一行两个灯，再亮起第二行两个按钮以及按钮向量
同样，L6=B1⊕B6⊕B7=B1⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)=B1⊕B3
【演示】画出B1,B6,B7的按钮状态，然后三个叠加再一起。
又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)⊕~(B2⊕B3⊕B4)=~B4
【演示】四个叠加在一起
这样不断递推，我们可以将任意L表达为某些B1到B5的叠加，再加上翻转。

——————————————————————

现在，把序号1-25用坐标x,y表示，使用公式表达，则可写为以下公式：
L(n,x)=B(n-1,x-1)⊕B(n,x-1)⊕B(n,x)⊕B(n,x+1)：灯为上左中右按钮的叠加
B(n+1,x)=~L(n,x)=~(B(n-1,x-1)⊕B(n,x-1)⊕B(n,x)⊕B(n,x+1))：下一行按钮是当前灯翻转
L(n+1,x)=~L(n-1,x-1)⊕~L(n,x-1)⊕~L(n,x)⊕~L(n,x+1)：下一行灯是上左中右灯翻转的叠加
【演示，显示并朗读这些公式】
如果把翻转~提取出来，便有了一开始的推导公式：
B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)：按钮是上一行左中右按钮和上上行按钮叠加
L(n,x)=L(n-1,x-1)⊕L(n-1,x)⊕L(n-1,x+1)⊕L(n-2,x)：灯是上一行左中右按钮和上上行灯叠加
【演示，显示并朗读这些公式】

之前叠加时是将多个B行一起叠加，如果拆分为每个B元素，则相当于从上左中右的位置一个个叠加。
【演示】还是叠加L6，但是这次是一个一个元素
这里用公式尽管是一个一个元素叠加的，但是由于每个被叠加的元素已经包含了之前叠加的结果，效果上和使用第一行叠加是相同的。
【演示】还是叠加L6，这次是一起叠加

——————————————————————

这里按钮的第一行是10000，是因为B1也需要表示为B1到B5的表达式，也就是B1=B1。
【演示】B1
在上一个视频中，因为写的是L矩阵，因此L1=B1⊕B2，这里等同于B矩阵的第二行。
【演示】L1
因为B(n+1,x)=~L(n,x)，因此灯矩阵和按钮矩阵在内容上是相同的，只不过按钮矩阵比灯矩阵下移了一行。
【演示】L1到B6
因为最终需要推导的是灯矩阵，因此灯矩阵相当于从按钮的第一行推导5次。因为最后一次推导的是灯，因此按钮矩阵也是5行。
【演示】继续推导L6。。。

——————————————————————

对于翻转的情况，则可以单独列出来，以类似的方法推导，写成Y公式：
Y(n,y)=~(Y(n-1,y-1)⊕Y(n-1,y)⊕Y(n-1,y+1)⊕Y(n-2,y))：下一行的翻转是上一行左中右和上上行叠加后的翻转。
【演示】翻转矩阵
可以注意到，这里的公式Y和B是一样的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号~，因为：

1. 使用零向量：第一次翻转发生在从第一行到第二行的迭代过程中，在此之前没有发生过翻转，因此Y的第一行就不是10000而是00000了。
【演示】圈出0向量
2. 翻转符号~必须存在：是因为每次迭代都需要翻转，因此不可省略。而前者将这个翻转取出来了，不用翻转符号~。
【演示】？
3. 不使用x而使用y：因为这个翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
【演示】将y=1..5写出来

——————————————————————

《优化生成矩阵》

在生成优化矩阵章节中，我将矩阵的行重排，其实是调换了n和y的位置，使原来从左到右为第y个矩阵变为了第n个矩阵。
【演示】再次演示重排，这次包含按钮和灯

这些矩阵具有一个性质，我称之为：十字偶校验约束。这个性质对任意第n个矩阵都满足。
B(x-1,y)⊕B(x+1,y)⊕B(x,y-1)⊕B(x,y+1)=0
【演示】再次圈出4个
这是一个十分重要的性质。通过这个性质，可以由第一个灯推导后面的灯。
在后面会说的O(n^2)算法中，其本质也是利用这个性质进行的优化。
【演示】移动4个到各种位置

下面让我用数学归纳法，证明这个性质。

由于右边一个按钮矩阵就是左边一个灯矩阵，这边我们就拿前三个按钮矩阵为例
【演示】去除多余的灯矩阵和右边几个矩阵
首先，我们假定前两个矩阵B(n-1)和B(n-2)满足这个性质，由此证明则B(n)也满足这个性质。
【演示】圈出左边两个矩阵，然后再圈出第三矩阵
B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=0
【演示】圈出第三矩阵一个圈
将刚才的矩阵递推关系加上参数y并重写为：B(n,x,y)=B(n-1,x-1,y)⊕B(n-1,x,y)⊕B(n-1,x+1,y)⊕B(n-2,x,y)
于是，对于B(n)，我们将递推关系代入这个式子，有；
B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=
(B(n-1,x-1-1,y)⊕B(n-1,x-1,y)⊕B(n-1,x+1-1,y)⊕B(n-2,x-1,y))⊕
(B(n-1,x-1+1,y)⊕B(n-1,x+1,y)⊕B(n-1,x+1+1,y)⊕B(n-2,x+1,y))⊕
(B(n-1,x-1,y-1)⊕B(n-1,x,y-1)⊕B(n-1,x+1,y-1)⊕B(n-2,x,y-1))⊕
(B(n-1,x-1,y+1)⊕B(n-1,x,y+1)⊕B(n-1,x+1,y+1)⊕B(n-2,x,y+1))
【演示】4个里面各选一次，然后选择左边的对应元素
重新排列顺序（也就是生成矩阵章节将y和n掉换），得到：
(B(n-1,x-1-1,y)⊕B(n-1,x-1+1,y)⊕B(n-1,x-1,y-1)⊕B(n-1,x-1,y+1))⊕
(B(n-1,x-1,y)⊕B(n-1,x+1,y)⊕B(n-1,x,y-1)⊕B(n-1,x,y+1))⊕
(B(n-1,x+1-1,y)⊕B(n-1,x+1+1,y)⊕B(n-1,x+1,y-1)⊕B(n-1,x+1,y+1))⊕
(B(n-2,x-1,y)⊕B(n-2,x+1,y))⊕B(n-2,x,y-1)⊕B(n-2,x,y+1))
【演示】依次画出左边的4各圈
不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此式子可以化为：
0⊕0⊕0⊕0=0。
【演示】四个圈叠加到右边

现在，我们只需要证明最左边两个矩阵满足要求即可。第一个矩阵是单位矩阵，显然满足要求
【演示】圈出第一个矩阵
第二个矩阵是其实也可以表示为左边两个矩阵的叠加。由于单位矩阵左边没有矩阵，因此相当于叠加了一个零矩阵。
【演示】画出隐藏零矩阵并圈出
由于零矩阵显然满足要求，因此第二个矩阵也满足要求。
【演示】圈出第二个矩阵

因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出下面的行：
B(x,y)=B(x-1,y-1)⊕B(x-1,y+1)⊕B(x-2,y)
【演示】直接显示最后一个矩阵以及第一行，依次圈出4个元素，并填充第二行
通过这种方法，我们无需对每个y都生成矩阵B，只需计算这些B矩阵的第一行，得到B(n)的第一行，即可求得完整的矩阵B(n)。
【演示】继续填充后面的行

——————————————————————

《首行求逆法》

对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。
【演示】从B到B的第一行

这里，让我以我们以n=7为例。我们的目标是，对于BX=Y，在已知B和Y的情况下求X。
【演示】显示公式
这里的B就是前面提到的按钮矩阵B，而Y就是翻转矩阵Y的最后一行。
【演示】显示b，X，Y

如果将n在不同情况下B的第一行写在一起，这样的B矩阵长这样。

n	B
0	1.......
1	11......
2	101.....
3	0111....
4	00001...
5	011011..
6	1000101.
7	10110111

【演示】一行行展示B矩阵，圈出递推公式

注意，这里的B矩阵不是刚才说的当n确定时的完整的B矩阵。
另外，这里从n=0开始一共递推n次，第n列的1不包含在B矩阵的第一行内。
例如n=5时，第一行为01101，最后一个1省去。

另外，把Y的第一行写在一起是这样的：

n	Y
0	........
1	1.......
2	11......
3	101.....
4	0000....
5	10001...
6	100001..
7	0101010.

为了实现这个目标，我们需要首先将B进行分解。
这里，让我首先介绍一个非常重要的矩阵H。H矩阵的一般形式如下：

n	H
1	01.....
2	101....
3	.101...
4	..101..
5	...101.
6	....101
7	.....10

【演示】显示矩阵H
H(y,x)=∣x−y∣=1
【演示】展示朗读公式（x-y的绝对值）
如果将向量v乘以该矩阵，等同于将向量v的每个元素向左右扩散后叠加：
v(x)*H=v(x-1)⊕v(x+1)
【演示】随便找个向量0100010，然后分解成两个向量，然后叠加1010101
这是因为矩阵的对应行就是向量每个元素左右扩散的结果。
【演示】向量竖着，然后叠加1010000和0000101

——————————————————————

如果将多个H相乘，也就是H^n，则其首行H^n(0)看起来像是这样（这里从单位矩阵n=0开始）：

n	K
0	1.......
1	010.....
2	1010....
3	00010...
4	001010..
5	010001..
6	1010101.
7	00000001

【演示】一行行显示K矩阵，圈出递推公式

我们把这个下三角矩阵记为K（Krylov矩阵或扩散基矩阵）。对于K的第n行有：K(n)=H^n(0)。
这里下一行是上一行乘以H，也就是上一行左右扩散的叠加：K(n)=k(n-1)*H。
对于K的每个元素，有：K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)
【演示】随便选一行，一个个计算元素（高亮左右上行）

——————————————————————

不难发现，首行叠加法中的各个B矩阵，可以表示为以下公式：
B(n)=B(n-1)*H⊕B(n-1)⊕B(n-2)
其中：
B(0)=I=H^0
B(1)=H=H^0+H^1
B(2)=B(1)*H+B(1)+B(0)=H^2+H^1+H^1+H^0+H^0=H^2
....
【演示】展示朗读公式（B(2)只朗读结果）

将其系数用多项式c(n,x)表达，则有和B矩阵类似的表达公式：
c(n,x)=c(n-1,x-1)⊕c(n-1,x)⊕c(n-2,x)
注意，这里的乘以H的操作在系数上代表右移而不是左右扩散，因此表达式中只有x-1而没有x+1。
【演示】展示朗读公式

将系数写成矩阵的形式，记为C：

n	C
0	1.......
1	11......
2	001.....
3	1111....
4	10101...
5	000011..
6	1010001.
7	11111111

这个矩阵和后面提到的F矩阵息息相关。
【演示】一行行显示C矩阵，圈出递推公式

——————————————————————

现在，定义多项式p(x)=p0x^0+p1x^1+p2x^2...
我们的目标是把B拆分成H^n，使用多项式p(H)表示B，也就是
B=p(H)=p0*H^0⊕p1*H^1⊕p2*H2⊕⋯
【演示】展示朗读公式
这样，原始求X的问题就变为了：
BX=Y⟺p(H)X=Y
【演示】展示朗读公式

现在，我们需要把多项式p(H)的系数计算出来，这个系数构成的向量我们记为p=(p0,p1,p2...)。
为了简化运算，我们只关心矩阵第一行B(0)，记为b。根据刚才的定义，我们有：
b=B(0)=p(H(0))=p0*H^0(0)⊕p1*H^1(0)⊕p2*H^2(0)⊕⋯=p0*K(0)⊕p1*K(1)⊕p2*K(2)⊕⋯=p*K
【演示】展示朗读公式(b=B(0)=p(H(0))=p*K)，把0加上去或直接展示新的。
——————————————————————

为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1，为了方便我们记为F（反Krylov矩阵或解耦矩阵）：

n	F
0	1.......
1	01......
2	101.....
3	0001....
4	10101...
5	010001..
6	1000101.
7	00000001

【演示】一行行显示F矩阵，圈出递推公式

这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵也满足类似的性质：
F(y,x)=F(y-1,x-1)⊕F(y-2,x)
有兴趣的小伙伴可以试着证明一下（使用这两个性质构造的矩阵K和F，然后证明互为逆矩阵）。

于是，我们便有：b*F=p*K*F=p。这样我们便求出了p。
【演示】演示，计算P矩阵（b竖着，叠加）

将p(x)写成矩阵，形式如下：

n	P
0	........
1	1.......
2	10......
3	111.....
4	0000....
5	01001...
6	001010..
7	1111111.

【演示】一行行显示P矩阵

——————————————————————

这里说明一下，矩阵F的每行对应多项式f(n,x)，就是上一集视频《解的数量》章节中提到的OEIS中的Fibonacci多项式：
f(n,x)=x·f(n-1,x)⊕f(n-2,x)
【演示】LATEX1
此外，刚才递推得到的C矩阵对应多项式c(n,x)，其实也就是这里提到的f(n,x+1)，即：
c(n,x)=f(n,x+1)
【演示】朗读公式
这是因为B(n)矩阵也可以写为：
B(n)=B(n-1)*(H⊕I)⊕B(n-2)
这里的H⊕I等价于x+1
【演示】朗读公式


同时，上一集视频提到的公式：
r'(n)=deg(gcd(f(n,x),c(n,x)))
这里，gcd(f(n,x)+f(n,x+1)的含义是f(n,x)和f(n,x+1)的最大公因子，我们将其记为多项式g(x)：
g(n,x)=gcd(f(n,x),c(n,x))
而deg(g(n,x))是指g(n,x)的最高次幂，其等价于矩阵B丢失的秩，也就是n-r。这个g(x)和n-r在后续算法中也会提到。

将g(x)写成矩阵G的形式：

n	G
0	1.......
1	10......
2	100.....
3	1000....
4	10101...
5	011000..
6	1000000.
7	10000000

【演示】一行行显示G矩阵

可以发现，如果B是可逆的，则g(x)=1，n=r，r’=0。否则，r'的值决定了解的数量，即2^r'。

【演示】圈出每一行最高系数格

——————————————————————

事实上，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
这是因为我们已经将问题从BX=Y转为了p(H)=Y。由此，在前面说到的生成矩阵也只需要计算第一行b。
由于在不同n的情况下b的计算方式是一样的，我们可以把n-1情况下算出的b，直接用于对n情况下b的计算，也就是：
b(n,x)=b(n-1,x-1)⊕b(n-1,x)⊕b(n-1,x+1)⊕b(n-2,x)
这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
为了求出p=b*F，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
因为矩阵F是有递推规律的，理论上使用FFT等算法可以优化到O(n*log(n))。

现在我们已求得了p，并将原始问题转换为了p(H)X=Y。那这又有什么用呢？

——————————————————————

试想一下，如果有一个多项式q(x)，满足：
q(x)p(x)=1 mod f(x)
这里的f(x)就是前面提到的多项式f(n,x)。那么，将原始两边同时乘以q(H)，便有：
X=q(H)p(H)X=q(H)*Y
这样，我们就能立刻求出X。
让我把这样的多项式q(x)我们称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？

这里，我们同样将q(x)的系数写为向量q，然后扩展欧几里得算法来求取q：

我们使用辗转相减法，将p(x)右移，使最高系数对齐，然后叠加到f(x)上。
如果叠加后的f(x)的最高次数小于p(x)，则将f(x)和p(x)互换，然后再次进行操作。
同时，我们定义一个单位多项式e(x)和零多项式o(x)，在对f(x)和p(x)操作的时候对e(x)和o(x)做同样操作。
这样，最终f(x)会被叠加到零，而剩下的p(x)则为两个多项式的最大公因子，记为g(x)。
同时，最后剩下的o(x)则是p(x)的逆，也就是q(x)。

将q(x)写成矩阵Q的前6行，注意这里的矩阵不是后面提到的完整的逆矩阵Q，而是每个逆矩阵Q的第一行拼凑起来。

n	Q
0	........
1	1.......
2	10......
3	110.....
4	0000....
5	01000...
6	001000..
7	1100000.

——————————————————————

这里，由于我们已求得q(x)。我们也可以利用这个式子来求X：
X=q(H)*Y=(q0*H^0⊕q1*H^1⊕q2*H^2⊕...)*Y=q0*H^0*Y⊕q1*H^1*Y⊕q2*H^2*Y⊕...
这里，我们可以从Y开始，不断将其和H相乘，使用左右扩散的办法计算下一个H^n*Y，然后和qn叠加，得到X。
通过这个办法，我们也可以在O(n^2)中求得X。

事实上，q(x)的系数也就是B的逆矩阵Q的第一行，并且可以证明B的逆矩阵Q也满足十字偶校验约束。
因此，可以通过递推公式，用逆矩阵第一行q(x)直接求出整个逆矩阵Q，然后再和Y相乘获得X。
不过，这整个求解的过程有一个问题，就是我们假设满足q(x)p(x)=1 mod f(x)的多项式q(x)存在。
如果矩阵B不可逆呢？例如当n=5的时候，这种情况下求得的g(x)不为1，因此q(x)不是p(x)的逆。或者说，满足该式子的q(x)不存在：
q(x)p(x)=1 mod f(x)
这种情况下，求得的q(x)和伪逆矩阵Q'不同，并且都不满足q(x)p(x)=1 mod f(x)。并且伪逆矩阵Q'也不满足十字偶校验约束，因此无法通过公式递推再相乘求解X。

例如，n=5时的伪逆矩阵Q'看起来像是这样：

B	Q'	E'
01101	11000	10001
11100	11100	01010
11011	01100	00111
00111	01110	00000
10110	10101	00000


可以证明，这里的伪逆矩阵Q'，以及高斯消元后的伪单位矩阵E'具有这样的形式（转置和矩阵大小下标省略）：
[Br	Ur]	[Qr	0]	[I	Wr]
[Ur	Vr]	[Wr	I]	[0	0]
这里，矩阵B的秩为r，例如n=5时r=3，并以rxr为界将矩阵分为四块，其中：
Qr=Br^-1：B矩阵左上角rxr的子矩阵Br满秩，并且B的伪逆矩阵Q'的左上角rxr子矩阵Qr伪Br的逆。
Wr=Ur*Qr：伪逆矩阵Q'左下角和伪单位矩阵E'右上角内容相同（静默操作），并且其值等于Ur乘以Qr。
矩阵Q'和E'一定具有这样的形式，并且可以用分块矩阵乘法很容易的证明这两个性质。有兴趣的观众可以自行证明。

可以发现，这里的q(x)并不是Q'的第一行，并且求得的X也不是原方程的解。

这里可以验证：
公式递推法：f(x)=x^2+x^5
欧几里得法：q(x)p(x)=x*(x+x^4)=x^2+x^5 ≠ 1 mod x^2+x^5
伪逆第一行：q(x)p(x)=(1+x)*(x+x^4)=x+x^2+x^4+x^5 ≠ 1 mod x^2+x^5

不难注意到，只有当矩阵B为可逆矩阵时，g(x)=1，并且g(x)的最高次幂为n-r=r'。那么对于不可逆的矩阵B，我们又有什么解决办法呢？
【演示】这里可以圈出g(x)以及最高次幂=2

——————————————————————

《首行方程法》

我们定义多项式q'(x)满足：
q'(x)p(x)=g(x) mod f(x)
其中，g(x)也就是刚才提到的最大公因子，q'(x)就是刚才求得的q(x)。
g(x)=gcd(f(x),c(x))=gcd(f(x),g(x))


q'(x)p(x)=g(x)
由于原本求得的x已不是解，我们定义z为部分解，x为最终解，即：
z=q'(H)*y
p(H)*x=y
同时，我们定义q'(x)的逆多项式p'(x)：
q'(x)p'(x)=1
这里，如果g(x)=1时，则会有：
x=z
q'(x)=q(x)
p'(x)=p(x)
我们不难推出以下结论：
p'(x)q'(x)p(x)=p'(x)g(x)
p(x)=p'(x)g(x)
q'(x)p(x)=g(x)
q'(x)=q'(x)p(x)q(x)=g(x)q(x)
另外，根据：
p(H)x=y
我们有：
z=q'(H)*y=q'(H)p(H)*x=g(H)*x
g(H)*y=q'(H)p(H)*y=g(H)p(H)*x
B(n)*x=p(H)*x=g(H)p'(H)*x=p'(H)*z=p'(H)q'(H)*y=y

——————————————————————

整理后，我们得到以下式子：
q'(x)p'(x)=1
g(x)=q'(x)p(x)
p(x)=p'(x)g(x)
q'(x)=q(x)g(x)
y=p(H)*x
y=p'(H)*z
z=q'(H)*y
z=g(H)*x

刚才使用的扩展欧几里得法求得的q实际上是这里的q'，并且同时也获得了最大公因子g，因此接下来只需要使用g和z求得x即可。
刚才我们用公式z=q(H)y，通过不断把y和H叠加，利用类似用向量乘以矩阵的方式求得的z。
这次我们有公式z=g(H)x，由于需要求得的是x，需要用反向叠加的方式来求得。

这里我们需要使用类似生成B矩阵的办法来生成g(H)，记为矩阵D：
1. 首先，创建n个单位向量，也就是D矩阵的第一行，这里和B矩阵相同，一共有n个向量。
2. 然后，使用H矩阵，将每个D矩阵第一行扩散到下面的行。
3. 最后，根据多项式g，将每个D矩阵的对应行叠加起来，叠加完的行共同构成一个新的D矩阵。
可以发现，这里的步骤和首行叠加法类似，共有n个矩阵要生成，时间复杂度是O(n^3)。
不过聪明的朋友一定能猜到，通过生成矩阵中的调换法整理矩阵的行以后，这些矩阵也都满足十字偶校验约束。因此同样只需要生成第一个矩阵，然后递推就行。
在这个过程中，不难发现，每行乘以H矩阵的结果，就是刚才的K矩阵。因此，只需要将g和K直接相乘即可得到第一个矩阵叠加后的行。

有了D矩阵，接下来我们只需要将Z拆解成不同D行的叠加，就能表式出x。(这里感觉说的有些问题）
具体方法是：
1. 生成每个D行最大1的索引。
2. 对于z的每个元素，如果其为1，则找到索引最大的D行叠加上去，同时记录到x。这样z就会不断变小，直到最后为0，此时x就是解。
（为什么？可以证明或者说明一下吗？）

由此，我们便通过计算gcd，在O(n^2)实现了Bx=y的求解，从而实现了点灯游戏在O(n^2)时间复杂度的算法。

——————————————————————

细心的观众会发现，其实这两个式子有相同的形式：
y=p(H)*x
z=g(H)*x
既然我们可以在第二个式子直接求x，为什么不能用相同的办法在第一个式子求x呢？
事实上，这种做法求得的x并不可行，因为这里的D矩阵因为这里的 D 矩阵是由 g(H) 生成、天然满足带状上三角的可回代结构，而 B=p′(H)D 破坏了这一结构。
(∀i, ∀j>i+deg g: D[i,j]=0 且各行最右 1 的列互异)
不过，当g=1式，这个种解法是可行的，尽管在这种情况下直接求出逆q然后直接和y相乘会更加方便。

——————————————————————
《算法总结》

输出	输入	说明				算法		公式
L	-	灯矩阵第一行			公式递推		L(n,x)=L(n-1,x-1)⊕L(n-1,x)⊕L(n-1,x+1)⊕L(n-2,x)
B	-	按钮矩阵第一行			公式递推		B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
Y	-	灯矩阵最后一行			公式递推		Y(n,y)=~(Y(n-1,y-1)⊕Y(n-1,y)⊕Y(n-1,y+1)⊕Y(n-2,y))
K	-	H^n矩阵第一行（Krylov扩散基矩阵）	公式递推		K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)
F	-	K的逆矩阵（Krylov解耦矩阵）	公式递推		F(n,x)=F(n-1,x-1)⊕F(n-2,x)
C	-	B关于H的系数矩阵			公式递推		C(n,x)=C(n-1,x-1)⊕C(n-1,x)⊕C(n-2,x)
P	B,F	多项式p(H)的系数			矩阵向量乘法	P=B*F		
Q	F,P	多项式p(x)的在f(x)下的逆		扩展欧几里得	Q=P^-1 mod F
G	F,P	多项式p(x)和q(x)的最大共因子	扩展欧几里得	G=gcd(F,P)=gcd(F,C)	
z	Q,y	部分逆按钮解			矩阵向量乘法	z=Q*y
D	G	多项式g(x)的矩阵			矩阵向量乘法	D=G*K
ID	D	H每一行的主元索引		求最大值		ID=max(D(n))
x	D,z	最终首行按钮解			前向异或消元	z=G*x
T	x	最终按钮解矩阵			公式递推		T(n,x)=T(n-1,x-1)⊕T(n-1,x)⊕T(n-1,x+1)⊕T(n-2,x)

——————————————————————

《更快的算法》

向量和矩阵的乘法，欧几里得算法，以及K矩阵的生成，理论上通过卷积，FFT或牛顿迭代法是有可能优化到O(n*log(n))的。
考虑到UP主《信号与系统》、《数字信号处理》、《数值分析》等课程学的比较差，暂时就不研究了。有兴趣的小伙伴可自行研究并留言。
如果对视频中的内容有疑问，觉得视频内容表述不清，或者发现视频中的任何错误，也请大家多多留言和指证。谢谢大家观看！




