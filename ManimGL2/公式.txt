1. p = B(n) * F —— 用 B(n) 的 1 位去异或叠加 f【j,*】，得到多项式系数向量 p，使得 B(n) = p(H)。
B(n)=p(H):=p0​I⊕p1​H⊕p2​H2⊕⋯.
BX=Y⟺p(H)X=Y.
2. q = rev(F(n), p) —— 扩展欧几里得。可逆：q = p^{-1} (mod f(n))。不可逆：得到一条特解 q，满足 p·q ≡ g (mod f(n))。
X=p^-1(H)Y=q(h)
p(H)q(H)=g(H),
p(x)q(x)≡g(x)(modχ(x)),χ(H)=0
3. y = L(n) → z = q(H) * y —— 取 y=l(n)（第 n 行灯向量），按 H 扩散并以 q 的系数叠加，得到 z = q(H) y。
p(H)X=Y⟹g(H)X=p(H)q(H)X=q(H)Y=Z​
p(h)X=Y⟹X=p(H)q(H)X=q(H)Y（g(H)=1）
4. g = gcd(p, F(n)) —— 求最大公因式 g，得到秩/亏秩信息。可逆时 g=1；不可逆时 g≠1。
5. H(0) = g * E → 得 h —— 用 Krylov 基 e【j,*】 合成 h【0,*】 = (g(H)·e0)^T，再按同样的扩散递推生成整张 h，等价于系数矩阵 g(H)。
6. r = fxrst1(h) —— 为 h 的每一列找首个 1 的行号，形成阶梯结构索引 r，便于前代。
7. x：解 h * x = z —— 按 r 做前向消元，解出 x。可逆：g=1，这一步瞬间退化为 x = z；不可逆：在像空间里等价的“右逆”。
8. T(0) = x —— 把 x 作为 t(0)，按同样递推生成整张 t；然后做校验/可视化。

——————————————————————

B(n)X=p(H)X=g(H)r(H)X=r(H)Z=r(H)q(H)Y=Y​

p(H)q(H)X=g(H)X=Z=q(H)Y

Z=q(H)Y
Z=g(H)X

χ(x)=g(x)h(x)
p(x)=g(x)r(x)

p(x)q(x)≡g(x) (mod χ(x))
g(x)r(x)q(x)≡g(x) (mod g(x)h(x))
r(x)q(x)≡1 (mod h(x))

​p(H)q(H)=g(H)
g(H)r(H)q(H)=g(H)
r(H)q(H)=1

——————————————————————

下面把你式子里出现的**对象/变量**、**等式/关系**分两张表讲清楚（全部在 GF(2) 上）。我也特别标注了哪些等式是“处处成立”，哪些只在“模掉 (h(x))”或“限制在 (\mathrm{Im}(g(H)))”时成立，避免歧义。

---

# 表一｜符号与对象对照

| 符号             | 类型/维度            | 含义（中文）                                  | 代码里的对应/来源                        | 备注/构造方式                                     |
| -------------- | ---------------- | --------------------------------------- | -------------------------------- | ------------------------------------------- |
| (n)            | 整数               | 矩阵与向量维度                                 | 全局变量 `n`                         | —                                           |
| GF(2)          | 域                | 元素 {0,1}，加法=异或                          | 全局                               | 全部运算都在 GF(2)                                |
| (H)            | (n\times n) 线性算子 | “左右邻叠加”算子：((Hv)[i]=v[i-1]\oplus v[i+1]) | 未显式存；通过 `e`/`f`/递推实现             | 边界外视为 0                                     |
| (e_0)          | 向量               | ((1,0,\dots,0)^T)                       | `e[0,*]`                         | Krylov 基起点                                  |
| (e[j,*])       | 向量               | (H^j e_0)                               | 矩阵 `e`                           | 递推：`e[j]=shiftL(e[j-1]) xor shiftR(e[j-1])` |
| (f[j,*])       | 多项式系数行           | 递推多项式 (\phi_j) 的系数                      | 矩阵 `f`                           | 递推：`f[j]=x·f[j-1] xor f[j-2]`               |
| (\chi(x))      | 多项式              | (H) 的“特征/最小”多项式（在本模型）                   | `f[n,*]`                         | 满足 (\chi(H)=0)                              |
| (A(n)), (B(n)) | (n\times n) 矩阵   | 目标矩阵；你式子里 (B(n)\equiv A(n))             | —                                | 用 (p(H)) 表示                                 |
| (a[n,*])       | 行向量              | (A(n)) 的第一行（输入/生成）                      | 矩阵 `a` 第 n 行                     | 用来恢复 (p(x))                                 |
| (p(x))         | 多项式（次数< n）       | 使 (A(n)=p(H)) 的“配方”                     | 向量 `p`                           | 由 (a[n,*]) 在 `f[j,*]` 基上回代得到                |
| (g(x))         | 多项式              | (\gcd(p,\chi))                          | 向量 `g`                           | `gcd(p, f[n])`                              |
| (h(x))         | 多项式              | (\chi/g)                                | 未单独存                             | 逻辑上用于“模 (h)”                                |
| (r(x))         | 多项式              | (p/g)                                   | 未单独存                             | (p=g,r)                                     |
| (q(x))         | 多项式              | 满足 (p,q\equiv g\pmod{\chi}) 的特解         | 向量 `q`                           | `rev(f[n], p, q)`                           |
| (s(x))         | 多项式              | 满足 (g,s\equiv1\pmod{h}) 的右逆             | 代码不显式计算                          | 代码用“像空间前代”等价实现                              |
| (Y)            | 向量               | 右端项                                     | `y` 初值 ← `l[n,*]`                | 你当前实现把 `l[n,*]` 当作输入                        |
| (Z)            | 向量               | (q(H)Y)                                 | `z`                              | 用“扩散叠加器”算                                   |
| (X)            | 向量               | 使 (A(n)X=Y) 的解                          | `x`                              | 最终前代得到                                      |
| (g(H))         | (n\times n) 算子   | 多项式 (g) 作用在 (H) 上                       | 矩阵 `h`（注意：代码里的 `h` 是列簇矩阵 (g(H))） | 构造：`h[0]=Σ g[j]·e[j]`，再按行递推生成全矩阵            |
| `r[j]`         | 整数数组             | 第 (j) 列首个 1 的行号（主元行）                    | 向量 `r`                           | 用于前代选择列                                     |
| `t`            | 矩阵               | 结果可视/校验的扩展                              | `t`                              | 与 `l` 同型递推生成                                |

---

# 表二｜等式/关系与适用范围

| 等式/关系                                   | 读法/意义                       | 适用范围/条件                   | 代码里体现                               |
| --------------------------------------- | --------------------------- | ------------------------- | ----------------------------------- |
| (\chi(H)=0)                             | (H) 满足其最小/特征多项式             | 恒成立                       | `f[n,*]` 给出 (\chi)                  |
| (\chi(x)=g(x)h(x))                      | 分解 (\chi)                   | 定义                        | `g=gcd(p, f[n])`，(h=\chi/g)（逻辑上）    |
| (p(x)=g(x)r(x))                         | 分解 (p)                      | 定义                        | (r=p/g)（逻辑上）                        |
| (A(n)=p(H))                             | 用 (p) 生成矩阵                  | 恒成立                       | `p` 由 `a[n,*]` 在 `f` 基回代            |
| (p(x)q(x)\equiv g(x)\pmod{\chi(x)})     | 扩欧特解关系                      | 恒成立                       | `rev(f[n], p, q)` 维持                |
| (\Rightarrow; p(H)q(H)=g(H))            | 代入 (H)（因 (\chi(H)=0)）       | 恒成立                       | 用来把 (AX=Y) 化为 (g(H)X=Z)             |
| (Z=q(H)Y)                               | 定义中间量                       | 恒成立                       | 叠加器：按 `q` 的位累加、每步 (y\leftarrow H y) |
| (g(H)X=Z)                               | 在像空间里解线性方程                  | 当且仅当 (AX=Y) 有解            | 用 `h=g(H)` 的列簇做前代消元                 |
| (r(x)q(x)\equiv 1\pmod{h(x)})           | (r) 与 (q) 在模 (h) 下互逆        | 由上两行分解推出                  | 用于证明 (r(H)Z=Y)                      |
| (\Rightarrow; r(H)q(H)=I+h(H)U(H))      | 在 (\mathrm{Im}(g(H))) 上等于恒等 | 对 (Y\in\mathrm{Im}(g(H))) | 证明里使用（代码不显式计算 (U)）                  |
| (\boxed{A(n)X=p(H)X=g(H)r(H)X=r(H)Z=Y}) | 一条求解链                       | 当 (g(H)X=Z) 时             | 最终正确性                               |
| 合并式：(A,S,Q,A=A)                         | 在 (\mathrm{Im}(A)) 上恒等      | (Q=q(H),,S=s(H))          | 代码用前代实现 (S) 的效果，未显式算 (s)            |

> 小心区分：
>
> * 你写的 (r(H)q(H)=1) 应读作 **(r(H)q(H)\equiv I\pmod{h(H)})**，或“在 (\mathrm{Im}(g(H))) 上等于恒等”。它不是对全空间的绝对恒等。
> * 因为 (Y\in\mathrm{Im}(A)=\mathrm{Im}(g(H)))（“题设已知 (AX=Y)”），所以 (r(H)q(H)Y=Y) 成立。

---

## 最短“求解配方”（把上面表格串起来）

1. 由 `a[n,*]` 解回代得 (p(x))，并取 (\chi(x)=f[n,*])。
2. 扩欧：求 (q(x)) 使 (p q\equiv g\ (\bmod \chi))。
3. 叠加：(Z=q(H)Y)。
4. 用 (h=g(H)) 的列簇前代解 (g(H)X=Z)。
5. 得 (A(n)X=Y)。

所有步骤均为 (O(n^2)) 位运算。


——————————————————————

#6
b 100010
f 1000101
e 101010
p 001010
q 001000
y 100001
z 101101
gcd     0
g 1000000
h0 100000
hn 000001
r 012345
x 101101
TRUE

b 100010

p
1	#
01
101
0001
10101	#
010001
1000101

p 001010


LATEX_MAT = [
    (L_COLOR,  "<cL>",  "L",   "-",   "灯矩阵第一行",                 "公式递推",     "<cL>L(n,x)=L(n-1,x-1)⊕L(n-1,x)⊕L(n-1,x+1)⊕L(n-2,x)"),
    (B_COLOR,  "<cB>",  "B",   "-",   "按钮矩阵第一行",               "公式递推",     "<cB>B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)"),
    (Y_COLOR,  "<cY>",  "Y",   "-",   "灯矩阵最后一行",               "公式递推...", "<cY>Y(n,y)=~(Y(n-1,y-1)⊕Y(n-1,y)⊕Y(n-1,y+1)⊕Y(n-2,y))"),
    (H_COLOR,  "<cH>",  "H",   "-",   "邻接矩阵",                     "公式递推",     "<cH>H(y,x)=(∣x-y∣=1)"),
    (K_COLOR,  "<cK>",  "K",   "<cH>H",   "H^n第一行（Krylov扩散基矩阵）", "公式递推",     "<cK>K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)"),
    (F_COLOR,  "<cF>",  "F",   "<cK>K",   "K的逆矩阵（Krylov解耦矩阵）",   "公式递推",     "<cF>F(n,x)=F(n-1,x-1)⊕F(n-2,x)"),
    (C_COLOR,  "<cC>",  "C",   "<cB>B",   "B关于H的系数矩阵",             "公式递推",     "<cC>C(n,x)=C(n-1,x-1)⊕C(n-1,x)⊕C(n-2,x)"),
    (P_COLOR,  "<cP>",  "P",   "<cF>F<cP>,<cB>b", "多项式p(H)的系数",             "矩阵向量乘法", "<cP>p=<cF>F<cB>b"),
    (Q_COLOR,  "<cQ>",  "Q",   "<cF>F<cQ>,<cP>p", "多项式p(x)的在f(x)下的逆",     "扩展欧几里得", "<cQ>q=<cP>p^-1<cQ> mod <cF>F"),
    (G_COLOR,  "<cG>",  "G",   "<cF>F<cG>,<cP>P", "多项式p(x)和q(x)最大共因子",   "扩展欧几里得", "<cG>g=gcd(<cF>f<cG>,<cC>c<cG>)=gcd(<cF>f<cG>,<cP>p<cG>)"),
    (Z_COLOR,  "<cZ>",  "Z",   "<cQ>Q<cZ>,<cY>y", "部分逆按钮解",                 "矩阵向量乘法", "<cZ>z=<cQ>Q<cY>y"),
    (D_COLOR,  "<cD>",  "D",   "<cK>K<cD>,<cG>g", "多项式g(x)的矩阵",             "矩阵向量乘法", "<cD>d=<cK>K<cG>g"),
    (X_COLOR,  "<cX>",  "X",   "<cD>D<cX>,<cZ>z", "最终首行按钮解",               "前向异或消元", "<cZ>z=<cD>D<cX>x"),
    (T_COLOR,  "<cT>",  "T",   "<cX>x",   "最终按钮解矩阵",               "公式递推",     "<cT>T(n,x)=T(n-1,x-1)⊕T(n-1,x)⊕T(n-1,x+1)⊕T(n-2,x)"),