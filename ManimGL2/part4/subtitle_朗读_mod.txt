在上集视频的《首行叠加法》中，有小伙伴对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。<break time="1000ms" />
我们用B代表按钮，L代表灯，加代表叠加，非代表翻转。<break time="1000ms" />
n代表从上到下第n行按钮或灯。因为我们是一行行进行推导的，n也代表第n次推导。<break time="1000ms" />
x代表从左到右第x列按钮。我们将灯表示为第一行的某几个列的按钮的叠加。这里的x不局限于第一行。<break time="1000ms" />
y代表从左到右第y列灯。这里的公式对任意第y个灯都满足，所以省去了y。<break time="1000ms" />
在这里，粉色原点是用按钮表示按钮，淡蓝色方块是用按钮表示灯。<break time="1000ms" />
而在上集视频中，因为最终目标是将灯用按钮表示，因此省去了按钮表示按钮，粉色原点直接是按钮表示灯。<break time="1000ms" />
让我们举一个具体的例子。在5乘5的格子中，我们将按钮和灯编号为1到25。<break time="1000ms" />
在《叠加法》中，我们将灯表示为所有按钮的叠加。例如，L1=B1加B2加B6，L6=B1加B6加B7加B11。<break time="1000ms" />
通过这种方法，我们得到了25个未知数的一次方程组。我们将其写成增广矩阵，也就是按钮矩阵和翻转向量（灯向量）的形式。<break time="1000ms" />
而在《首行叠加法》中，我们需要把灯表示为第一行按钮的叠加。<break time="1000ms" />
这里的五个矩阵，分别代表第y列是由第一行的哪几个按钮叠加的。<break time="1000ms" />
由于按法是动态的，当第二行按钮还未被按下时，L1=B1加B2，即第一个灯L1是由第一行的第一、<phoneme alphabet="sapi" ph="er 4">二</phoneme>个按钮B1,B2叠加的。<break time="1000ms" />
然后，B6=非L1=非(B1加B2)，即第六个按钮B6是第一个灯L1的翻转。因此，第二行按钮B6和第一行灯L1的叠加状态是相同的。<break time="1000ms" />
只不过B6是L1的翻转。而旁边的向量，代表的就是按钮或灯有没有翻转。<break time="1000ms" />
例如，当第一个向量的第一个灯L1亮起时，表示L1除了由刚才说的按钮叠加外，还需要翻转才是正确的状态。<break time="1000ms" />
同理，B7=非L2=非(B1加B2加B3)，即第七个按钮B7是第二个灯L2的翻转。同样，第二行的按钮B7和第一行灯L2的叠加状态是相同的。<break time="1000ms" />
这里，我们将第一个按钮B1的状态补全，将B1用第一行的按钮叠加时，有B1=B1。<break time="1000ms" />
接下来我们来看第六个灯。L6=B1加B6加B7=B1加B3。<break time="1000ms" />
又比如，L7=B2加B6加B7加B8=非B4。<break time="1000ms" />
这样不断递推，我们可以将任意L表示为B1到B5的叠加。加上翻转后，得到完整的矩阵。<break time="1000ms" />
现在，如果我们把序号1到25用<mstts:ttsbreak strength="none">坐标x和y</mstts:ttsbreak>表示，则按钮和灯可写为以上公式。让我们以L7(2)=<mstts:ttsbreak strength="none">L(2<break time="50ms" />2<break time="50ms" />2)</mstts:ttsbreak>为例。<break time="1000ms" />
这里，我们的矩阵同时满足另一个性质，我称之为十字偶校验约束。<break time="1000ms" />
即某个元素的左右两个矩阵的对应位置的元素，和元素所在矩阵左右两个元素的叠加后为零。<break time="1000ms" />
这也就是上集视频中《优化生成矩阵》章节中的性质，之后我会给出证明。<break time="1000ms" />
通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。<break time="1000ms" />
因此，我们可以在公式中去除y。于是，灯可以表示为当前矩阵的<mstts:ttsbreak strength="none">上左中右</mstts:ttsbreak>的按钮的叠加。<break time="1000ms" />
又因为，后一行的按钮是前一行灯的翻转。而后一行的灯是<mstts:ttsbreak strength="none">上左中右</mstts:ttsbreak>的灯的翻转的叠加。<break time="1000ms" />
如果把翻转非提取出来，便有了一开始的推导公式。<break time="1000ms" />
也就是，按钮是前一行的<mstts:ttsbreak strength="none">左中右</mstts:ttsbreak>按钮和上上<phoneme alphabet="sapi" ph="hang 2">行</phoneme>的按钮的叠加。以及，灯是前一行的<mstts:ttsbreak strength="none">左中右</mstts:ttsbreak>按钮和上上<phoneme alphabet="sapi" ph="hang 2">行</phoneme>的灯的叠加。<break time="1000ms" />
可以注意到，按钮和灯的递推公式具有相同的形式，这是因为前一行灯就是后一行按钮。<break time="1000ms" />
因为最终需要推导的是灯，因此灯是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮也是5行。<break time="1000ms" />
对于翻转的情况，则可以单独列出来，以类似的方法推导，写成公式Y。<break time="1000ms" />
即后一行的翻转是前一行<mstts:ttsbreak strength="none">左中右</mstts:ttsbreak>和上上<phoneme alphabet="sapi" ph="hang 2">行</phoneme>叠加后的翻转。<break time="1000ms" />
可以注意到，这里的公式Y和公式B的推导公式是类似的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号非。<break time="1000ms" />
一<break time="300ms" />使用零向量，第一次翻转发生在从一到二行的推导过程中，在此之前没有发生过翻转，因此Y的第一行是全零。<break time="1000ms" />
二<break time="300ms" />翻转符号非必须存在，每次推导都需要翻转，因此不可省略。而前者将这个翻转取出来了，因此不用翻转符号非。<break time="1000ms" />
三<break time="300ms" />不使用x而使用y，翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。<break time="1000ms" />
事实上，按钮矩阵也可以用另一种更直观的方法推得。<break time="1000ms" />
首先，在第一个矩阵中，我们点击第一行的第一个按钮。然后，点击第二行的按钮，尽量消去第一行的灯。<break time="1000ms" />
接着按第三行按钮，消去第二行的灯。不断递推，直到最后一行。<break time="1000ms" />
最终，最后一行按钮和灯的状态，和前面推得的矩阵是一样的。<break time="1000ms" />
同样，在第二个矩阵点击第二个按钮，然后递推，也可以得到第二个矩阵最后一行按钮和灯的状态。<break time="1000ms" />
通过这个方法，我们也可以得到所有矩阵最后一行的状态。<break time="1000ms" />
另外，翻转向量也可以用相似的方法推得。<break time="1000ms" />
我们把所有灯全部点亮，然后用刚才的方法尝试把所有灯消去，同样可以得到翻转向量最后一行的状态。<break time="1000ms" />
我们把这种方法称作余数矩阵法，和首行叠加法的原理本质上是相同的，有兴趣的小伙伴可以自行证明。<break time="1000ms" />
在《生成优化矩阵》章节中，我将矩阵的行重排。其实是调换了n和y的位置，使原来从左到右的第y个矩阵变为了第n个矩阵。<break time="1000ms" />
这n个矩阵都满足十字偶校验约束，即上下左右四个格子叠加为零，因此这里的公式省去了n。<break time="1000ms" />
这里和之前的情况是一样的，只不过n和y调换了，因此位置发生了变化。<break time="1000ms" />
这是一个十分重要的性质。使用这个性质，可以由第一个灯直接推导后面的灯。<break time="1000ms" />
在之后的O(n的二次方)算法中，其本质也是用这个性质进行的优化。<break time="1000ms" />
下面让我用数学归纳法，证明这个性质。<break time="1000ms" />
由于右边的按钮矩阵就是左边的灯矩阵，为了方便，我们就只看按钮矩阵。<break time="1000ms" />
首先，我们假定前两个矩阵B(n-1)和B(n-2)满足这个性质，现在来证明B(n)也满足这个性质。<break time="1000ms" />
将刚才的矩阵递推关系加上参数y并重写。<break time="1000ms" />
对于B(n)，我们将式子竖着写成四项，然后将递推关系代入这个式子。<break time="1000ms" />
代入后的式子包含16项。现在重新排列项目顺序，将y和n调换，类似《优化生成矩阵》章节中的调换操作。<break time="1000ms" />
不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此整个式子化为了零。<break time="1000ms" />
现在，我们只需要证明最左边两个矩阵也满足这个性质即可。第一个矩阵是单位矩阵，显然满足这个性质。<break time="1000ms" />
第二个矩阵可以表示为左边两个矩阵的叠加。由于单位矩阵左边没有矩阵，因此相当于叠加了一个零矩阵。<break time="1000ms" />
由于零矩阵显然满足这个性质，因此第二个矩阵也满足这个性质。<break time="1000ms" />
因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出后续的行，求得完整的矩阵B(n)。<break time="1000ms" />
为了实现O(n的二次方)的算法，我们也需要用到类似的方法，尽量不去对整个矩阵进行操作，而是通过第一行来求逆或求解。<break time="1000ms" />
我们以n=7为例。这里的B就是前面提到的按钮矩阵B(n)，而y就是翻转向量的最后一行，即B(n)的增广向量。<break time="1000ms" />
我们的目标是，对于Bx=y，在已知B的第一行和y的情况下求x。<break time="1000ms" />
如果将n在不同情况下的B的第一行写在一起，矩阵长这样，记为B撇。<break time="1000ms" />
注意，这里的B撇矩阵不是刚才说的当n确定时的完整的矩阵B，而是B(n)的第一行拼接起来的结果。<break time="1000ms" />
另外，这里从n=0开始一共递推n次，最后一个1不包含在矩阵B的第一行内。例如n=7时，第一行为1011011，最后一个1省去。<break time="1000ms" />
改写后的矩阵记为B撇撇=B撇加I。<break time="1000ms" />
把Y的第一行写在一起是这样的，记为Y撇。<break time="1000ms" />
合并在一起后的Y撇有以上递推公式。<break time="1000ms" />
为了不对整个矩阵进行操作，我们需要将矩阵B进行分解。这里，让我介绍一个非常重要的矩阵H，称为邻接扩散矩阵。<break time="1000ms" />
对于H的每一个元素，如果x和y的差为一时取一，否则取零。如果将向量v乘以该矩阵，等同于将向量v的每个元素向左右扩散后叠加。<break time="1000ms" />
这是因为，矩阵的对应行就是向量每个元素左右扩散的结果。<break time="1000ms" />
不难发现，《首行叠加法》中的各个矩阵B，可以用H表示为以上公式。<break time="1000ms" />
这里，B(0)、B(1)、B(2)分别表示为H的不同次数的叠加。<break time="1000ms" />
将这些H的系数用多项式c(n,x)表示，则有和矩阵B类似的递推公式。同时，将系数c写成矩阵的形式，记为C。<break time="1000ms" />
注意，这里的乘以H的操作在系数上代表右移而不是左右扩散，因此，表达式中只有x-1而没有x+1。<break time="1000ms" />
现在，如果我们将多个H相乘，也就是H的n次方，将其首行H的n次方(0)拼接起来，看起来像是这样的。<break time="1000ms" />
我们把这个下三角矩阵记为K，又称Krylov矩阵或扩散基矩阵。对于K的第n行，有以上公式。<break time="1000ms" />
这里后一行是前一行乘以H，也就是前一行的左右扩散。因此对于K的每个元素，有以上递推公式。<break time="1000ms" />
现在，定义多项式p(x)。我们的目标是把B拆分成H的n次方。<break time="1000ms" />
将矩阵H代入多项式p(x)，得到p(H)，并用其表示矩阵B。<break time="1000ms" />
这样，原始求x的问题就转化为了p(H)x=y。<break time="1000ms" />
现在，我们需要把多项式p(H)的系数计算出来。这个系数构成的向量我们记为p。<break time="1000ms" />
为了简化运算，我们只关心矩阵第一行B(0)，记为b。根据刚才K的定义，我们可以得到b=Kp。<break time="1000ms" />
为了求得p，我们可以将两边同时乘以K的逆矩阵，记为F，又称反Krylov矩阵或解耦矩阵。<break time="1000ms" />
这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵F也满足类似的性质。<break time="1000ms" />
使用这两个性质构造的矩阵K和F，可以证明S=KF为单位矩阵I，有兴趣的小伙伴可以自己试着证明一下。<break time="1000ms" />
提示，矩阵S=KF满足十字偶校验约束，也就是满足以上递推公式。<break time="1000ms" />
这里说明一下，矩阵F的每行对应多项式f(n,x)，也就是上集视频《解的数量》章节中提到的OEIS中的Fibonacci多项式。<break time="1000ms" />
此外，刚才递推得到的矩阵C对应多项式c(n,x)，等价于《解的数量》章节中提到的f(n,x+1)。<break time="1000ms" />
这个证明也不难，可以由F和C的关系求出F和C的递推公式，或者由递推公式反推。<break time="1000ms" />
同时，B(n)矩阵也可以表示为以上形式。这里的H加I等价于x+1。<break time="1000ms" />
让我们继续求p。由于F和K互逆，于是我们有，Fb=FKp=p。将向量b和矩阵F相乘，我们便求出了p。<break time="1000ms" />
为了和视频中演示一致，由于b是竖着的，因此写为p=Fb。对于矩阵乘法运算来说，则有P=B撇撇F。这里省去了转置符号。<break time="1000ms" />
将多项式p(x)写成矩阵的形式，记为P。<break time="1000ms" />
有了p=Fb之后，后续的计算我们都不需要用到完整的B，而只需要B的第一行，即向量b。<break time="1000ms" />
这是因为，问题已经从Bx=y转化为了p(H)x=y。因此，在前面说到的生成矩阵，也只需要计算向量b，也就是矩阵B撇。<break time="1000ms" />
由于在不同n的情况下计算b的公式是一样的，我们可以把n-1情况下算出的b，直接用于计算n的情况。<break time="1000ms" />
这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。<break time="1000ms" />
同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。<break time="1000ms" />
如果需要直接计算特定n，可以用其它方法优化到O(n乘log(n))。因为这里的算法不涉及这个优化，因此就不展开了。<break time="1000ms" />
为了求出p=Fb，我们需要将向量和矩阵相乘，一般情况下，其时间复杂度是O(n的二次方)。<break time="1000ms" />
因为矩阵F是有递推规律的，理论上使用FFT等算法，可以把乘法优化到O(n乘log(n))。<break time="1000ms" />
另一方面，这里在计算p的时候，我们将B撇撇的对角线去除了，即P=B撇撇F。假如我们保留B撇撇的对角线，则有C=B撇F。<break time="1000ms" />
为了证明这一点，我们假定B撇F=C撇，得出以上递推公式。由于C撇的递推公式和C是相同的，因此这里的C撇就是C，即C撇=C=B撇F。<break time="1000ms" />
由于C=B撇F，我们可以推得P=C加F。因此，我们可以计算出C和F，叠加后直接求得P，无需使用矩阵乘法。<break time="1000ms" />
同时，由于P=C加F，P也可以写成这个递推公式，从而无需B，C或F，直接在O(n)的时间内，由P的递推公式推得。<break time="1000ms" />
由于这个证明较长，因此这里就不展示出来了。有兴趣的小伙伴可以从C和F的递推公式自行证明。<break time="1000ms" />
现在，我们已用多种方法求得了p，并将原始问题转化为了p(H)x=y，可这又有什么用呢？<break time="1000ms" />
试想一下，如果有一个多项式q(x)，满足q(x)p(x)=1 mod f(x)。这里的f(x)就是前面提到的多项式f(n,x)。<break time="1000ms" />
那么，将式子两边同时乘以q(H)，便有，x=q(H)y。<break time="1000ms" />
这样，我们就能立即求出x。<break time="1000ms" />
我把这样的多项式q(x)称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？<break time="1000ms" />
我们可以使用扩展欧几里得算法，通过f(x)和p(x)来求取q(x)。<break time="1000ms" />
这里，我们同时定义一个零多项式o(x)和单位多项式e(x)，在对f(x)和p(x)操作的同时，对o(x)和e(x)做相同的操作。<break time="1000ms" />
类似矩阵求逆，我们的目标是，将f(x)变为零多项式，p(x)变为单位多项式。<break time="1000ms" />
我们使用辗转相减法，将p(x)右移，使其最高次项和f(x)对齐，然后叠加到f(x)上，从而消去f(x)的最高次项。<break time="1000ms" />
叠加后，如果f(x)的最高次数仍旧大于等于p(x)，则继续右移p(x)并叠加到f(x)上。<break time="1000ms" />
否则，当f(x)的最高次数小于p(x)时，将p(x)和f(x)互换，使得f(x)的最高次数始终大于或等于p(x)，让叠加操作可以继续下去。<break time="1000ms" />
重复这样操作，直到f(x)最终被叠加为零。<break time="1000ms" />
最后，剩下的p(x)为两个多项式的最大公因子，记为g(x)，同时，剩下的e(x)为p(x)的逆，也就是q(x)。<break time="1000ms" />
我们将q(x)写成矩阵Q。注意，这里的矩阵Q不是前面的完整逆矩阵Q撇，而是多个把q(x)拼接起来的结果。<break time="1000ms" />
现在，我们已求得q(x)，接着，我们可以根据q(H)y的定义，用这个式子来求x。<break time="1000ms" />
这里，我们将y不断乘以矩阵H进行左右扩散，再根据q(x)的值进行叠加，从而得到x。<break time="1000ms" />
另一方面，由于q(H)就是B的逆矩阵Q撇，并且可以证明Q撇也满足十字偶校验约束。<break time="1000ms" />
因此，我们也可以通过Kq求出逆矩阵Q撇的第一行，再通过递推公式求得完整的Q撇，最后再和y相乘求得x。<break time="1000ms" />
两种方法求得的x是相同的，有兴趣的小伙伴可以自行证明。<break time="1000ms" />
不过，整个求解的过程中有一个问题，那就是我们假设满足q(x)p(x)=1 mod f(x)的多项式q(x)存在。<break time="1000ms" />
如果这样的多项式q(x)不存在，我们又当如何呢？<break time="1000ms" />
在上集视频《解的数量》章节中，我们提到了公式r撇(n)。<break time="1000ms" />
这里，gcd表示最大公因子。不难发现，这里的gcd(f,c)就是前面扩展欧几里得算法中的g。<break time="1000ms" />
同时，由于F=C加P，因此gcd(f,c)和gcd(f,p)是相等的。<break time="1000ms" />
这里，deg表示最高次数，r撇代表矩阵B丢失的秩，也就是n-r。r撇的值决定了解的数量，即2的r次方撇。<break time="1000ms" />
将g(x)写成矩阵的形式，记为G。<break time="1000ms" />
不难注意到，只有当矩阵B为可逆矩阵时，g(x)=1，并且g(x)的最高次数为r撇=n-r=0。<break time="1000ms" />
例如，当n=5时的时候，高斯消元后的B的伪逆矩阵Q撇和单位矩阵E撇矩阵是这样的。<break time="1000ms" />
这里，矩阵B不可逆，其秩为r=3。我们以r乘r为界将矩阵分为四块，则会有这些结论。<break time="1000ms" />
一<break time="300ms" />矩阵B左上角r乘r的子矩阵满秩，并且和Q撇左上角r乘r子矩阵互为逆矩阵。<break time="1000ms" />
二<break time="300ms" />Q撇右下角和E撇左上角为单位矩阵，Q撇右上角和E撇下方为零矩阵。<break time="1000ms" />
三<break time="300ms" />Q撇左下角Wr和E撇右上角的静默操作相同，并且其值等于Q撇左上角乘以B右上角，或者B左下角乘以Q撇左上角。<break time="1000ms" />
这些性质可以通过分块矩阵乘法，结合高斯消元法和矩阵B的对称性得出，有兴趣的小伙伴可以自行证明。<break time="1000ms" />
可以发现，Q撇不满足十字偶校验约束，因而无法通过公式递推求得。并且使用Q撇第一行求得的x也不是原方程的解。<break time="1000ms" />
如果我们令Q撇第一行为q(x)，并且和p(x)相乘，得到的g(x)不为1，最高次数为4。<break time="1000ms" />
另一方面，如果我们直接使用扩展欧几里得法，通过p(x)和f(x)进行求解，得到的g(x)也不为1。<break time="1000ms" />
将求得的q(x)和p(x)相乘，得到刚才求得的g(x)，其最高次数为2。<break time="1000ms" />
这里，我们计算q(H)y，发现求得的x也不是正确解。<break time="1000ms" />
两种方法求得的q(x)和g(x)都不相同，g(x)都不为1，并且q(H)y也都不是正确解。<break time="1000ms" />
因此，如果g(x)不为1，则q(x)不满足q(x)p(x)=1 mod f(x)。或者说，满足q(x)p(x)=1 mod f(x)的q(x)不存在。<break time="1000ms" />
那么对于不可逆的矩阵B，我们又有什么方法可以求出正确的解呢？<break time="1000ms" />
在刚才的《首行求逆法》中，我们有这些公式。<break time="1000ms" />
现在，我们定义多项式q撇(x)，满足q撇(x)p(x)=g(x) mod f(x)。<break time="1000ms" />
其中，g(x)也就是刚才提到的最大公因子，q撇(x)就是刚才求得的q(x)。<break time="1000ms" />
由于原本求得的x已不是最终解而是部分解，我们将其重命名为z，即z=q撇(H)y。<break time="1000ms" />
同时，我们定义q撇(x)的逆多项式p撇(x)，即q撇(x)p撇(x)=1 mod f(x)。<break time="1000ms" />
我们不难推出这些式子。为了方便表示，这里将mod f(x)的部分省去。<break time="1000ms" />
整理后，我们可以得到这些式子。<break time="1000ms" />
最终，我们得到了z=g(H)x。这里，如果g(x)=1，则会有右边这些式子。<break time="1000ms" />
前面使用的扩展欧几里得法中，我们已求得q撇(x)和g(x)。因此，接下来只需要使用g(x)和z即可求得x。<break time="1000ms" />
前者，我们有公式z=q撇(H)y。我们不断让y乘以H，然后使用向量乘以矩阵的方法求得z。<break time="1000ms" />
现在，我们有公式z=g(H)x。由于需要求得的是x，不能再使用这个方法来求解。<break time="1000ms" />
这次，我们需要用反向叠加法来求x。让我们以n=5为例。<break time="1000ms" />
首先，我们需要使用类似生成矩阵B的方法生成g(H)，这里记为矩阵D，其秩与矩阵B相同。<break time="1000ms" />
一<break time="300ms" />创建n个单位向量，也就是矩阵D的第一行。这里和矩阵B相同，一共有n个向量。<break time="1000ms" />
二<break time="300ms" />使用矩阵H，将每个矩阵D第一行扩散到后续的行。<break time="1000ms" />
三<break time="300ms" />根据多项式g(x)，将每个矩阵D的对应行叠加起来，叠加完的行共同构成一个新的矩阵D。<break time="1000ms" />
可以发现，这里的步骤和《首行叠加法》类似，共有n个矩阵要生成，时间复杂度是O(n的三次方)。<break time="1000ms" />
不过，聪明的你一定能想到，通过《生成矩阵法》调换矩阵的行以后，这些矩阵也都满足十字偶校验约束。<break time="1000ms" />
因此，我们同样只需要生成第一个矩阵，然后递推即可得到矩阵D，时间复杂度降为了O(n的二次方)。<break time="1000ms" />
在生成第一个矩阵的过程中，每行乘以矩阵H的结果，就是刚才的矩阵K。<break time="1000ms" />
因此，只需要将g(x)和K直接相乘，即可得到第一个矩阵的最后一行，即矩阵D的第一行。<break time="1000ms" />
然后，我们就可以使用十字偶校验约束的递推关系，求得之后的行。<break time="1000ms" />
由于矩阵D是由矩阵H生成的，具有以下这些性质。这里，n=5，r=3，r撇=2。<break time="1000ms" />
一<break time="300ms" />后r=3行，第n行最左边的n-r撇-1=n-3个元素为0。<break time="1000ms" />
二<break time="300ms" />后r=3行，第n行第n-r撇=n-2个元素为1。<break time="1000ms" />
三<break time="300ms" />后r=3行，任意一行都不能由别的行叠加，即线性无关。<break time="1000ms" />
四<break time="300ms" />前r撇=2行，任意一行都可以由后r=3行叠加。<break time="1000ms" />
这些性质都不难证明，有兴趣的小伙伴可以自行证明。<break time="1000ms" />
现在，我们有z=g(H)x=Dx。我们可以利用D的性质进行求解。接下来，我们需要将z拆解成矩阵D的若干行的叠加，从而表示出x。<break time="1000ms" />
由于矩阵D后3行线性无关，因此我们只考虑把后3行叠加起来，不需考虑前2行。<break time="1000ms" />
这里，我们尝试将后3行的若干行叠加到现有的z上，使其被消去。<break time="1000ms" />
让我们观察z的第一个元素和D的后三行。在D的后3行中，第三行的第一个元素为1。<break time="1000ms" />
z的第一个元素已经为0。如果我们叠加第三行，则z的第一个元素会变为1，因此不能叠加第三行。<break time="1000ms" />
我们再看z的第二个元素，该元素为1，因此，我们需要将第四行叠加到z上。<break time="1000ms" />
现在，z的第二个元素被消去了，同时，x的第四个元素被标记为1。<break time="1000ms" />
我们接着看z的第三个元素。由于z的第三个元素变为了1，我们需要叠加D的第五行。<break time="1000ms" />
这次，z被彻底消去了，变为了零，并且，x的第五个元素被标记为1。<break time="1000ms" />
由此，我们通过依次叠加D的后3行，将z的元素依次消去。同时，将叠加的行标记为1，也就求得了最终的x。<break time="1000ms" />
不难发现这里求得的x是一个特解。<break time="1000ms" />
由于前r撇行可以表示为后r行的线性叠加，因此我们可以在操作y之前，先将其和前r撇的任意行叠加，然后再求解。<break time="1000ms" />
由于前r撇行共有2的r次方撇种，因此求得的解也有2的r次方撇种。<break time="1000ms" />
另一方面，由于矩阵D满足十字偶校验约束，表现出高度的对称性。其中，行和列的坐标可以互换。<break time="1000ms" />
因此，我们可以同样只叠加前r行，从右往左进行消去。由于效果是相同的，这里不再赘述。<break time="1000ms" />
细心的小伙伴会发现，这两个式子具有相同的形式。<break time="1000ms" />
既然我们可以在第一个式子用反向叠加法求x，为什么不能用相同的方法在第二个式子求x呢？<break time="1000ms" />
这是因为矩阵D是由g(H)生成的，具有带状上三角的可回代结构，满足前面说到的四个性质。<break time="1000ms" />
而B=p撇(H)D破坏了这一结构，不满足这些性质。这里，D=g(H)不满秩，因此p撇(H)不唯一。<break time="1000ms" />
不过，当g=1时，这种解法是可行的，尽管这个方法首先需要求出完整的矩阵B。<break time="1000ms" />
同时，因为矩阵B不是三角结构，还需标记每行首个为1的元素的位置来选择。因此，直接计算q(H)y会更加方便。<break time="1000ms" />
最终，我们通过欧几里得法和反向叠加法，完成了Bx=y的求解，实现了点灯游戏O(n的二次方)的时间复杂度的算法。<break time="1000ms" />
向量矩阵乘法，欧几里得算法，逆向消元法，理论上通过卷积、FFT或牛顿迭代法，是有可能优化到O(n乘log(n))的。<break time="1000ms" />
考虑到UP主《信号与系统》、《数字信号处理》、《数值分析》等课程较差，暂时就不研究了。有兴趣的小伙伴可自行研究并留言。<break time="1000ms" />
如果对视频中的内容有疑问，觉得视频内容表述不清，或者发现视频中的任何错误，也请大家多多留言和指证。谢谢大家观看！<break time="1000ms" />
