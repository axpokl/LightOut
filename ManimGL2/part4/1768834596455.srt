1
00:00:00,160 --> 00:00:02,560
在上集视频的首行叠加法中，

2
00:00:02,560 --> 00:00:06,200
有小伙伴对按钮和灯的递推仍有疑问。

3
00:00:06,200 --> 00:00:11,280
这次我们来讲清楚这个递推公式是怎么来的。

4
00:00:11,280 --> 00:00:13,000
我们用B代表按钮，

5
00:00:13,000 --> 00:00:15,200
L代表灯加代表叠加，

6
00:00:15,200 --> 00:00:18,280
非代表翻转。

7
00:00:18,280 --> 00:00:21,600
N代表从上到下第n行按钮或灯，

8
00:00:21,600 --> 00:00:23,960
因为我们是一行行进行推导的，

9
00:00:23,960 --> 00:00:25,800
N也代表第n次推导。

10
00:00:27,600 --> 00:00:30,400
X代表从左到右第X列按钮，

11
00:00:30,880 --> 00:00:34,400
我们将灯表示为第一行的某几个列的按钮的叠加，

12
00:00:34,880 --> 00:00:37,040
这里的X布局限于第一行。

13
00:00:38,800 --> 00:00:41,800
Y代表从左到右DY列灯，

14
00:00:41,800 --> 00:00:44,720
这里的公式对任意DY格灯都满足，

15
00:00:44,720 --> 00:00:45,920
所以省去了Y。

16
00:00:47,440 --> 00:00:48,160
在这里，

17
00:00:48,160 --> 00:00:50,320
粉色圆点是用按钮表示按钮，

18
00:00:50,400 --> 00:00:52,760
淡蓝色方块是用按钮表示灯，

19
00:00:54,400 --> 00:00:55,800
而在上集视频中。

20
00:00:55,880 --> 00:00:58,480
因为最终目标是将灯用按钮表示，

21
00:00:58,480 --> 00:01:00,560
因此省去了按钮表示按钮，

22
00:01:00,720 --> 00:01:04,640
粉色圆点直接是按钮表示灯，

23
00:01:04,640 --> 00:01:06,480
让我们举一个具体的例子，

24
00:01:06,960 --> 00:01:08,400
在5乘5的格子中，

25
00:01:08,400 --> 00:01:10,800
我们将按钮和灯编号为1到25，

26
00:01:12,800 --> 00:01:13,920
在叠加法中，

27
00:01:13,920 --> 00:01:17,000
我们将灯表示为所有按钮的叠加，

28
00:01:17,000 --> 00:01:20,360
例如L1等于B1加B2加B6，

29
00:01:20,720 --> 00:01:24,040
L6等于B1加B6加B7加B11。

30
00:01:25,680 --> 00:01:26,800
通过这种方法，

31
00:01:26,800 --> 00:01:29,840
我们得到了25个未知数的一次方程组。

32
00:01:30,400 --> 00:01:32,880
我们将其写成增广矩阵，

33
00:01:32,880 --> 00:01:38,560
也就是按钮矩阵和翻转向量及灯向量的形式。

34
00:01:38,560 --> 00:01:40,080
而在首行叠加法中，

35
00:01:40,080 --> 00:01:43,040
我们需要把灯表示为第一行按钮的叠加。

36
00:01:44,480 --> 00:01:51,160
这里的五个矩阵分别代表第Y列是由第一行的哪几个按钮叠加的。

37
00:01:51,160 --> 00:01:52,760
由于按法是动态的，

38
00:01:52,760 --> 00:01:54,960
当第二行按钮还未被按下时。

39
00:01:55,120 --> 00:01:56,920
L1等于B1加B2，

40
00:01:57,280 --> 00:02:04,080
即第一个灯L1是由第一行的第一第二个按钮B1B2叠加的，

41
00:02:04,080 --> 00:02:07,560
然后B6等于非L1等于非B1加B2，

42
00:02:07,840 --> 00:02:11,400
即第六个按钮B6是第一个灯L1的翻转，

43
00:02:11,920 --> 00:02:18,480
因此第二行按钮B6和第一行灯L1的叠加状态是相同的，

44
00:02:18,480 --> 00:02:21,560
只不过B6是L1的翻转，

45
00:02:21,560 --> 00:02:23,120
而旁边的翻转向量。

46
00:02:23,400 --> 00:02:28,080
代表的就是按钮或灯有没有翻转，

47
00:02:28,080 --> 00:02:31,520
例如当第一个向量的第一个灯L1亮起时，

48
00:02:31,520 --> 00:02:34,600
表示L1除了由刚才说的按钮叠加外，

49
00:02:34,600 --> 00:02:36,840
还需要翻转才是正确的状态。

50
00:02:38,320 --> 00:02:39,320
同理，

51
00:02:39,320 --> 00:02:42,720
B7等于非L2等于非B1加B2加B3，

52
00:02:42,880 --> 00:02:47,040
即第七个按钮B7是第二个灯L2的翻转。

53
00:02:47,040 --> 00:02:47,600
同样，

54
00:02:47,680 --> 00:02:52,200
第二行的按钮B7和第一行灯L2的叠加状态是相同的。

55
00:02:53,600 --> 00:02:56,800
这里我们将第一个按钮B1的状态补全，

56
00:02:56,800 --> 00:02:58,920
将B1用第一行的按钮叠加时，

57
00:02:59,040 --> 00:03:02,280
有B1等于B1。

58
00:03:02,280 --> 00:03:08,640
接下来我们来看第六个灯L6等于B1加B6加B7等于B1加B1

59
00:03:08,640 --> 00:03:12,880
加B2加B1加B2加B3等于B1加B3，

60
00:03:14,480 --> 00:03:15,040
又比如。

61
00:03:15,280 --> 00:03:21,680
L7等于B2加B6加B7加B8等于B2加非B1加B2加非B1

62
00:03:21,680 --> 00:03:26,240
加B2加B3加非B2加B3加B4等于非B4。

63
00:03:27,760 --> 00:03:28,880
这样不断递推，

64
00:03:28,880 --> 00:03:32,400
我们可以将任意L表示为B1到B5的叠加，

65
00:03:32,880 --> 00:03:36,760
加上翻转后得到完整的矩阵。

66
00:03:36,760 --> 00:03:41,080
现在如果我们把序号1到25用坐标X和Y表示，

67
00:03:41,280 --> 00:03:43,800
则按钮和灯可写为以上公式。

68
00:03:44,400 --> 00:03:49,840
让我们以L72等于L222为例，

69
00:03:49,840 --> 00:03:52,680
这里我们的矩阵同时满足另一个性质，

70
00:03:52,880 --> 00:03:56,920
让我们称之为十字偶校验约束，

71
00:03:56,920 --> 00:04:02,160
某个元素的左右两个矩阵的对应位置的元素和元素所在矩阵左右两个

72
00:04:02,160 --> 00:04:05,080
元素的叠加后为零，

73
00:04:05,080 --> 00:04:12,280
这也就是上集视频中优化生成矩阵章节中的性质之后会给出证明，

74
00:04:12,280 --> 00:04:13,320
通过这个性质。

75
00:04:13,520 --> 00:04:17,640
递推公式可化为只根据当前矩阵的元素来叠加，

76
00:04:17,640 --> 00:04:20,960
无需依赖于左右矩阵，

77
00:04:20,960 --> 00:04:23,600
因此我们可以在公式中去除外，

78
00:04:24,160 --> 00:04:28,800
于是灯可以表示为当前矩阵的上左中右的按钮的叠加，

79
00:04:30,240 --> 00:04:33,680
又因为后一行的按钮是前一行灯的翻转，

80
00:04:33,680 --> 00:04:37,440
而后一行的灯是上左中右的灯的翻转的叠加。

81
00:04:38,920 --> 00:04:39,440
因此，

82
00:04:39,520 --> 00:04:41,480
如果把翻转飞提取出来，

83
00:04:41,480 --> 00:04:43,400
便有了一开始的推导公式，

84
00:04:44,880 --> 00:04:50,440
也就是按钮是前一行的左中右的按钮和上上行的按钮的叠加，

85
00:04:50,440 --> 00:04:55,000
以及灯是前一行的左中右的按钮和上上行的灯的叠加，

86
00:04:56,480 --> 00:05:00,200
可以注意到按钮和灯的递推公式具有相同的形式，

87
00:05:00,480 --> 00:05:04,880
这是因为前一行灯就是后一行按钮，

88
00:05:04,880 --> 00:05:06,640
因为最终需要推倒的是灯。

89
00:05:06,840 --> 00:05:07,320
因此，

90
00:05:07,320 --> 00:05:09,920
灯是从按钮的第一行推到五行，

91
00:05:10,480 --> 00:05:12,320
因为最后一次推倒的是灯，

92
00:05:12,320 --> 00:05:14,240
因此按钮也是五行。

93
00:05:15,760 --> 00:05:17,000
对于翻转的情况，

94
00:05:17,000 --> 00:05:18,440
则可以单独列出来，

95
00:05:18,440 --> 00:05:19,960
以类似的方法推导，

96
00:05:19,960 --> 00:05:22,720
写成公式外。

97
00:05:22,720 --> 00:05:24,880
即后一行的翻转是前一行，

98
00:05:24,880 --> 00:05:29,160
左中右和上上行叠加后的翻转。

99
00:05:29,160 --> 00:05:33,800
可以注意到这里的公式外和公式B的推导公式是类似的。

100
00:05:34,320 --> 00:05:37,120
只不过Y是从0向量开始推导的，

101
00:05:37,120 --> 00:05:43,040
并且不能省略翻转符号非1使用0向量，

102
00:05:43,040 --> 00:05:46,360
第一次翻转发生在从1到2行的推导过程中，

103
00:05:46,360 --> 00:05:48,520
在此之前没有发生过翻转，

104
00:05:48,720 --> 00:05:53,080
因此Y的第一行是全0，

105
00:05:53,080 --> 00:05:55,640
2翻转符号非必须存在，

106
00:05:55,640 --> 00:05:57,360
每次推导都需要翻转，

107
00:05:57,360 --> 00:05:59,160
因此不可省略，

108
00:05:59,160 --> 00:06:01,440
而前者将这个翻转取出来了，

109
00:06:01,440 --> 00:06:03,320
因此不用翻转符号非。

110
00:06:05,120 --> 00:06:07,360
三不使用X而使用Y，

111
00:06:08,000 --> 00:06:11,520
翻转是前面所有按钮的翻转叠加后提取出来的，

112
00:06:11,520 --> 00:06:13,480
代表的是灯的翻转，

113
00:06:13,480 --> 00:06:16,640
而不是某个按钮的翻转。

114
00:06:16,640 --> 00:06:17,280
事实上，

115
00:06:17,360 --> 00:06:20,800
按钮矩阵也可以用另一种更直观的方法推得。

116
00:06:22,400 --> 00:06:23,040
首先，

117
00:06:23,040 --> 00:06:24,400
在第一个矩阵中，

118
00:06:24,400 --> 00:06:27,040
我们点击第一行第一个按钮，

119
00:06:27,040 --> 00:06:29,040
然后点击第二行的按钮，

120
00:06:29,120 --> 00:06:30,760
尽量消去第一行的灯。

121
00:06:32,320 --> 00:06:35,640
接着按第三行按钮消去第二行的灯，

122
00:06:35,640 --> 00:06:37,760
不断递推直到最后一行。

123
00:06:39,280 --> 00:06:45,800
最终最后一行按钮和灯的状态和前面推得的矩阵是一样的。

124
00:06:45,800 --> 00:06:49,400
同样在第二个矩阵点击第一行第二个按钮，

125
00:06:49,400 --> 00:06:54,200
然后递推也可以得到第二个矩阵最后一行按钮和灯的状态。

126
00:06:55,680 --> 00:06:56,880
通过这个方法，

127
00:06:56,880 --> 00:06:59,880
我们可以得到所有矩阵最后一行的状态。

128
00:07:01,440 --> 00:07:01,920
另外，

129
00:07:01,920 --> 00:07:04,640
翻转向量也可以用相似的方法推得。

130
00:07:06,240 --> 00:07:08,320
我们把所有灯全部点亮，

131
00:07:08,320 --> 00:07:11,600
然后用刚才的方法尝试把所有灯消去，

132
00:07:11,600 --> 00:07:16,200
同样可以得到翻转向量最后一行的状态。

133
00:07:16,200 --> 00:07:22,000
我们把这种方法称作余数矩阵法和首行叠加法的原理本质上是相同的

134
00:07:22,000 --> 00:07:22,040
，

135
00:07:22,240 --> 00:07:26,200
有兴趣的小伙伴可以自行证明。

136
00:07:26,200 --> 00:07:28,200
在生成优化矩阵章节中，

137
00:07:28,200 --> 00:07:29,960
我们将矩阵的行重排。

138
00:07:30,560 --> 00:07:32,920
其实是调换了N和Y的位置，

139
00:07:32,920 --> 00:07:38,600
使原来从左到右的第Y个矩阵变为了第N个矩阵。

140
00:07:38,600 --> 00:07:41,560
这N个矩阵都满足十字偶校验约束，

141
00:07:41,560 --> 00:07:44,000
及上下左右四个格子叠加为零，

142
00:07:44,240 --> 00:07:46,440
因此这里的公式省去了N。

143
00:07:48,000 --> 00:07:50,120
这里和之前的情况是一样的，

144
00:07:50,120 --> 00:07:51,920
只不过N和Y调换了，

145
00:07:51,920 --> 00:07:53,840
因此位置发生了变化。

146
00:07:55,280 --> 00:07:57,200
这是一个十分重要的性质。

147
00:07:57,760 --> 00:08:02,800
使用这个性质可以由第一个灯直接推到后面的灯，

148
00:08:02,800 --> 00:08:05,360
在之后的ON的二次方算法中，

149
00:08:05,360 --> 00:08:08,080
其本质也是用这个性质进行的优化。

150
00:08:09,600 --> 00:08:14,480
下面让我们用数学归纳法证明这个性质，

151
00:08:14,480 --> 00:08:18,120
由于右边的按钮矩阵就是左边的灯矩阵，

152
00:08:18,120 --> 00:08:20,760
为了方便我们就只看按钮矩阵。

153
00:08:22,320 --> 00:08:22,840
首先，

154
00:08:22,840 --> 00:08:27,960
我们假定前两个矩阵bn减1和bn减2满足这个性质，

155
00:08:28,160 --> 00:08:32,520
现在来证明bn也满足这个性质。

156
00:08:32,520 --> 00:08:37,720
将刚才的矩阵递推关系加上参数y并重写。

157
00:08:37,720 --> 00:08:38,560
对于bn，

158
00:08:38,560 --> 00:08:40,920
我们将式子竖着写成四项，

159
00:08:40,920 --> 00:08:44,960
然后将递推关系代入这个式子。

160
00:08:44,960 --> 00:08:47,640
代入后的式子包含16项，

161
00:08:47,640 --> 00:08:51,120
现在重新排列项目顺序将y和n调换。

162
00:08:51,360 --> 00:08:54,560
类似优化生成矩阵章节中的调换操作，

163
00:08:56,080 --> 00:08:58,600
不难发现这四项属于B、

164
00:08:58,600 --> 00:09:00,360
N减1或B、

165
00:09:00,480 --> 00:09:01,080
N减2，

166
00:09:01,080 --> 00:09:04,520
并且元素之间的关系满足十字偶校验约束，

167
00:09:04,520 --> 00:09:06,880
因此整个式子化为了零。

168
00:09:08,320 --> 00:09:13,280
现在我们只需要证明最左边的两个矩阵也满足这个性质即可。

169
00:09:13,760 --> 00:09:15,520
第一个矩阵是单位矩阵，

170
00:09:15,520 --> 00:09:17,040
显然满足这个性质。

171
00:09:18,520 --> 00:09:22,360
第二个矩阵可以表示为左边两个矩阵的叠加，

172
00:09:22,360 --> 00:09:24,600
由于单位矩阵左边没有矩阵，

173
00:09:24,600 --> 00:09:28,600
因此相当于叠加了一个零矩阵。

174
00:09:28,600 --> 00:09:30,920
由于零矩阵显然满足这个性质，

175
00:09:31,120 --> 00:09:33,840
因此第二个矩阵也满足这个性质，

176
00:09:35,360 --> 00:09:37,320
因为BN有了这个性质，

177
00:09:37,520 --> 00:09:42,320
我们只需要知道BN的第一行就能通过公式推导出后续的行，

178
00:09:42,480 --> 00:09:44,320
求得完整的矩阵BN。

179
00:09:46,000 --> 00:09:48,600
为了实现ON的二次方次算法，

180
00:09:48,720 --> 00:09:51,000
我们也需要用到类似的方法，

181
00:09:51,000 --> 00:09:53,360
尽量不去对整个矩阵进行操作，

182
00:09:53,520 --> 00:09:56,120
而是通过第一行来求逆或求解。

183
00:09:57,760 --> 00:09:59,960
我们以N等于7为例，

184
00:09:59,960 --> 00:10:03,240
这里的B就是前面提到的按钮矩阵BN，

185
00:10:03,520 --> 00:10:06,000
而Y就是翻转向量的最后一行，

186
00:10:06,160 --> 00:10:08,080
即BN的增广向量。

187
00:10:09,520 --> 00:10:12,800
我们的目标是对于BX等于Y。

188
00:10:13,040 --> 00:10:16,160
在已知B的第一行和Y的情况下求X，

189
00:10:17,680 --> 00:10:21,360
如果将N在不同情况下的B的第一行写在一起，

190
00:10:21,360 --> 00:10:23,360
矩阵长这样即为B撇。

191
00:10:24,800 --> 00:10:29,920
注意这里的B撇矩阵不是刚才说的当N确定时的完整的矩阵B，

192
00:10:30,160 --> 00:10:34,360
而是BN的第一行拼接起来的结果。

193
00:10:34,360 --> 00:10:34,880
另外，

194
00:10:34,880 --> 00:10:36,560
这里从N等于0开始，

195
00:10:36,560 --> 00:10:37,800
一共递推N次，

196
00:10:38,000 --> 00:10:41,200
最后一个1不包含在矩阵B的第一行内。

197
00:10:41,760 --> 00:10:43,280
例如n等于70，

198
00:10:43,600 --> 00:10:45,880
第一行为1011011，

199
00:10:45,880 --> 00:10:52,080
最后一个一省去改写后的矩阵即为b撇撇等于b撇加i，

200
00:10:53,520 --> 00:10:56,000
把y的第一行写在一起是这样的，

201
00:10:56,000 --> 00:11:03,280
记为y撇合并在一起后的y撇有以上递推公式，

202
00:11:03,280 --> 00:11:05,360
为了不对整个矩阵进行操作，

203
00:11:05,360 --> 00:11:08,200
我们需要将矩阵b进行分解，

204
00:11:08,200 --> 00:11:10,680
这里介绍一个非常重要的矩阵h。

205
00:11:10,880 --> 00:11:12,640
称为邻接扩散矩阵，

206
00:11:14,080 --> 00:11:15,760
对于H的每一个元素，

207
00:11:15,760 --> 00:11:18,480
如果X和Y得差为10取1，

208
00:11:18,560 --> 00:11:19,280
否则取0。

209
00:11:20,000 --> 00:11:22,160
如果将向量V乘以该矩阵，

210
00:11:22,160 --> 00:11:27,520
等同于将向量V的每个元素向左右扩散后叠加。

211
00:11:27,520 --> 00:11:33,480
这是因为矩阵的对应行就是向量每个元素左右扩散的结果，

212
00:11:33,480 --> 00:11:39,160
不难发现首行叠加法中的各个矩阵B可以用H表示为以上公式。

213
00:11:40,800 --> 00:11:41,880
这里B0、

214
00:11:42,080 --> 00:11:42,760
B1、

215
00:11:42,760 --> 00:11:45,920
B2分别表示为H的不同次数的叠加，

216
00:11:47,360 --> 00:11:50,800
将这些H的系数用多项式CNX表示，

217
00:11:50,960 --> 00:11:53,960
则有和矩阵B类似的递推公式，

218
00:11:53,960 --> 00:11:59,080
同时将系数C写成矩阵的形式记为C，

219
00:11:59,080 --> 00:12:04,440
注意这里的乘以H的操作在系数上代表右移而不是左右扩散，

220
00:12:04,440 --> 00:12:08,160
因此表达式中只有X减1而没有X加1。

221
00:12:10,000 --> 00:12:12,360
现在如果我们将多个H相乘，

222
00:12:12,360 --> 00:12:14,600
也就是H的n次方，

223
00:12:14,600 --> 00:12:17,400
将其首行H的n次方0拼接起来，

224
00:12:17,400 --> 00:12:20,320
看起来像是这样的。

225
00:12:20,320 --> 00:12:22,560
我们把这个下三角矩阵即为K，

226
00:12:22,720 --> 00:12:25,760
又称克雷洛夫矩阵或扩散机矩阵。

227
00:12:26,240 --> 00:12:30,200
对于K的第n行有以上公式，

228
00:12:30,200 --> 00:12:32,520
这里后一行是前一行乘以H，

229
00:12:32,640 --> 00:12:34,560
也就是前一行的左右扩散。

230
00:12:35,040 --> 00:12:35,520
因此，

231
00:12:35,520 --> 00:12:38,280
对于K的每个元素有以上递推公式。

232
00:12:39,760 --> 00:12:42,160
现在我们定义多项式PX，

233
00:12:42,640 --> 00:12:45,880
我们的目标是把B拆分成H的n次方，

234
00:12:47,360 --> 00:12:52,880
将矩阵H代入多项式PX得到PH并用其表示矩阵B，

235
00:12:54,400 --> 00:12:59,280
这样原始求X的问题就转化为了PHX等于Y，

236
00:13:00,800 --> 00:13:04,640
现在我们需要把多项式PH的系数计算出来，

237
00:13:05,120 --> 00:13:07,680
这个系数构成的向量我们记为P。

238
00:13:09,280 --> 00:13:10,400
为了简化运算，

239
00:13:10,400 --> 00:13:12,640
我们只关心矩阵第一行B零，

240
00:13:12,720 --> 00:13:13,440
即为B。

241
00:13:13,920 --> 00:13:15,440
根据刚才K的定义，

242
00:13:15,440 --> 00:13:17,440
我们可以得到B等于KP。

243
00:13:18,880 --> 00:13:19,800
为了求得P，

244
00:13:19,800 --> 00:13:22,800
我们可以将两边同时乘以K的逆矩阵，

245
00:13:22,800 --> 00:13:23,440
即为F，

246
00:13:23,680 --> 00:13:28,160
又称反克雷洛夫矩阵或解偶矩阵。

247
00:13:28,160 --> 00:13:30,640
这个矩阵F也是下三角矩阵，

248
00:13:30,640 --> 00:13:32,880
并且和矩阵K看上去差不多，

249
00:13:32,880 --> 00:13:34,760
不过并不相同。

250
00:13:34,760 --> 00:13:35,440
事实上，

251
00:13:35,440 --> 00:13:38,120
这个矩阵F也满足类似的性质。

252
00:13:39,600 --> 00:13:45,720
使用这两个性质构造的矩阵K和F可以证明S等于KF为单位矩阵i

253
00:13:45,720 --> 00:13:45,760
，

254
00:13:45,920 --> 00:13:50,360
有兴趣的小伙伴可以自己试着证明一下。

255
00:13:50,360 --> 00:13:54,800
提示矩阵S等于KF满足10字偶校验约束，

256
00:13:54,800 --> 00:13:58,480
也就是满足以上递推公式。

257
00:13:58,480 --> 00:14:02,960
这里说明一下矩阵F的每行对应多项式FNX。

258
00:14:03,080 --> 00:14:08,560
也就是上集视频解的数量章节中提到的OEIS中的斐波那契多项式

259
00:14:08,560 --> 00:14:08,600
，

260
00:14:10,080 --> 00:14:16,240
此外刚才递推得到的矩阵C对应的多项式CNX等价于解的数量章节

261
00:14:16,240 --> 00:14:18,720
中提到的FNX加1，

262
00:14:18,720 --> 00:14:21,800
这个证明也不难，

263
00:14:21,800 --> 00:14:27,640
可以由F和C的关系求出F和C的递推公式或者由递推公式反推，

264
00:14:29,120 --> 00:14:32,240
同时BN矩阵也可以表示为以上形式。

265
00:14:32,840 --> 00:14:35,520
这里的H加I等价于X加1，

266
00:14:37,120 --> 00:14:38,480
让我们继续求P，

267
00:14:38,960 --> 00:14:40,640
由于F和K互逆，

268
00:14:40,640 --> 00:14:44,160
于是我们有FB等于FKP等于P，

269
00:14:44,640 --> 00:14:46,960
将向量B和矩阵F相乘，

270
00:14:46,960 --> 00:14:49,840
我们便求出了P，

271
00:14:49,840 --> 00:14:51,880
为了和视频中演示的一致，

272
00:14:51,880 --> 00:14:53,560
由于B是竖着的，

273
00:14:53,560 --> 00:14:56,200
因此写为P等于FB，

274
00:14:56,200 --> 00:14:58,000
对于矩阵乘法运算来说，

275
00:14:58,080 --> 00:15:00,200
则有P等于B撇撇F，

276
00:15:00,720 --> 00:15:02,360
这里省去了转置符号。

277
00:15:03,840 --> 00:15:07,520
将多项式PX写成矩阵的形式记为P，

278
00:15:09,040 --> 00:15:10,880
有了P等于FB之后，

279
00:15:10,880 --> 00:15:13,920
后续的计算我们都不需要用到完整的B，

280
00:15:14,160 --> 00:15:16,920
而只需要B的第一行及向量B，

281
00:15:18,400 --> 00:15:23,760
这是因为问题已经从BX等于Y转化为了PHX等于Y，

282
00:15:24,400 --> 00:15:28,720
因此在前面说到的生成矩阵也只需要计算向量B，

283
00:15:28,800 --> 00:15:30,200
也就是矩阵B撇。

284
00:15:31,920 --> 00:15:35,440
由于在不同N的情况下计算B的公式是一样的，

285
00:15:35,440 --> 00:15:39,880
我们可以把N减一情况下算出的B直接用于计算N的情况，

286
00:15:41,360 --> 00:15:44,400
这样如果我们是从N等于0开始计算的，

287
00:15:44,560 --> 00:15:49,960
我们只需要open的时间复杂度便可求出B同样。

288
00:15:50,240 --> 00:15:52,800
计算K和F也是如此，

289
00:15:52,800 --> 00:15:54,560
因为每行之间有递推公式，

290
00:15:54,720 --> 00:15:56,880
如果从N等于0开始计算，

291
00:15:56,880 --> 00:16:00,880
也可以在ON时间内求出。

292
00:16:00,880 --> 00:16:02,800
如果需要直接计算特定N，

293
00:16:02,800 --> 00:16:05,920
可以用其他方法优化到ON乘logN，

294
00:16:06,480 --> 00:16:08,720
因为这里的算法不涉及这个优化，

295
00:16:08,800 --> 00:16:11,920
因此就不展开了。

296
00:16:11,920 --> 00:16:13,680
为了求出P等于FB，

297
00:16:13,760 --> 00:16:16,200
我们需要将向量和矩阵相乘。

298
00:16:16,400 --> 00:16:17,400
一般情况下，

299
00:16:17,400 --> 00:16:21,760
其时间复杂度是ON的二次方，

300
00:16:21,760 --> 00:16:24,120
因为矩阵F是有递推规律的，

301
00:16:24,120 --> 00:16:28,880
理论上使用FFT等算法可以把乘法优化到ON乘logN。

302
00:16:28,880 --> 00:16:31,400
另一方面，

303
00:16:31,400 --> 00:16:33,040
这里在计算P的时候，

304
00:16:33,040 --> 00:16:35,520
我们将B撇撇的对角线去除了，

305
00:16:35,520 --> 00:16:37,440
即P等于B撇撇F。

306
00:16:38,080 --> 00:16:40,480
假如我们保留B撇撇的对角线，

307
00:16:40,480 --> 00:16:42,400
则有C等于B撇F。

308
00:16:44,040 --> 00:16:45,160
为了证明这一点，

309
00:16:45,160 --> 00:16:49,680
我们假定B撇F等于C撇得出以上递推公式。

310
00:16:49,680 --> 00:16:52,800
由于C撇的递推公式和C是相同的，

311
00:16:52,800 --> 00:16:55,040
因此这里的C撇就是C，

312
00:16:55,040 --> 00:16:57,520
即C撇等于C等于B撇F。

313
00:16:59,040 --> 00:17:00,840
由于C等于B撇F，

314
00:17:00,960 --> 00:17:03,400
我们可以推得P等于C加F。

315
00:17:04,000 --> 00:17:04,520
因此，

316
00:17:04,520 --> 00:17:08,280
我们可以计算出C和F叠加后直接求得P，

317
00:17:08,280 --> 00:17:09,720
无需使用矩阵乘法。

318
00:17:11,200 --> 00:17:11,800
同时，

319
00:17:11,800 --> 00:17:13,720
由于P等于C加F。

320
00:17:13,920 --> 00:17:16,200
P也可以写成这个递推公式，

321
00:17:16,200 --> 00:17:22,400
从而无需BC或F在ON的时间内由P的递推公式直接推得。

322
00:17:24,000 --> 00:17:25,600
由于这个证明较长，

323
00:17:25,600 --> 00:17:28,160
因此这里就不展示出来了。

324
00:17:28,160 --> 00:17:34,040
有兴趣的小伙伴可以从C和F的递推公式自行证明。

325
00:17:34,040 --> 00:17:36,480
现在我们已用多种方法求得了P，

326
00:17:36,640 --> 00:17:40,160
并将原始问题转化为了PHX等于Y，

327
00:17:40,320 --> 00:17:41,520
可这又有什么用呢？

328
00:17:43,040 --> 00:17:43,840
试想一下，

329
00:17:43,840 --> 00:17:49,080
如果有一个多项式QX满足QXPX等于一modFX，

330
00:17:49,600 --> 00:17:55,000
这里的FX就是前面提到的多项式FNX，

331
00:17:55,000 --> 00:18:00,320
那么将式子两边同时乘以QH便有X等于QHY，

332
00:18:00,800 --> 00:18:03,000
这样我们就能立即求出X，

333
00:18:04,480 --> 00:18:08,880
我们把这样的多项式QX称之为PX的逆多项式，

334
00:18:09,360 --> 00:18:12,320
那么如何求出逆多项式QX呢？

335
00:18:13,680 --> 00:18:16,280
我们可以使用扩展欧几里德算法，

336
00:18:16,280 --> 00:18:19,360
通过FX和PX来求QX。

337
00:18:21,040 --> 00:18:26,360
这里我们同时定义一个零多项式OX和单位多项式EX，

338
00:18:26,360 --> 00:18:29,120
在对FX和PX操作的同时，

339
00:18:29,120 --> 00:18:33,560
对OX和EX做相同的操作。

340
00:18:33,560 --> 00:18:34,760
类似矩阵求逆，

341
00:18:34,760 --> 00:18:40,360
我们的目标是将FX变为零多项式PX变为单位多项式。

342
00:18:41,880 --> 00:18:43,600
我们使用辗转相减法，

343
00:18:43,600 --> 00:18:47,920
将PX右移使其最高次项和FX对齐，

344
00:18:47,920 --> 00:18:49,840
然后叠加到FX上，

345
00:18:49,840 --> 00:18:53,680
从而消去FX的最高次项。

346
00:18:53,680 --> 00:18:54,320
叠加后，

347
00:18:54,320 --> 00:18:58,080
如果FX的最高次数仍旧大于等于PX，

348
00:18:58,080 --> 00:19:02,920
则继续右移PX并叠加到FX上。

349
00:19:02,920 --> 00:19:03,440
否则，

350
00:19:03,440 --> 00:19:06,480
当FX的最高次数小于PX时，

351
00:19:06,480 --> 00:19:08,640
将PX和FX互换。

352
00:19:08,880 --> 00:19:12,840
使得FX的最高次数始终大于或等于PX，

353
00:19:12,840 --> 00:19:16,400
让叠加操作可以继续下去。

354
00:19:16,400 --> 00:19:17,600
重复这样的操作，

355
00:19:17,680 --> 00:19:20,200
直到FX最终被叠加为零。

356
00:19:21,680 --> 00:19:25,480
最后剩下的PX为两个多项式的最大公因子，

357
00:19:25,600 --> 00:19:26,800
即为GX。

358
00:19:26,800 --> 00:19:30,040
同时剩下的EX为PX的逆，

359
00:19:30,040 --> 00:19:31,360
也就是QX。

360
00:19:32,800 --> 00:19:35,120
我们将QX写成矩阵Q。

361
00:19:35,760 --> 00:19:39,520
注意这里的矩阵Q不是前面的完整逆矩阵Q撇，

362
00:19:39,680 --> 00:19:43,800
而是把多个QX拼接起来的结果。

363
00:19:43,800 --> 00:19:45,880
现在我们已求得QX，

364
00:19:45,880 --> 00:19:48,640
接着我们可以根据QHY的定义，

365
00:19:48,720 --> 00:19:50,480
用这个式子来求X。

366
00:19:52,000 --> 00:19:55,920
这里我们将Y不断乘以矩阵H进行左右扩散，

367
00:19:56,080 --> 00:19:58,560
再根据QX的值进行叠加，

368
00:19:58,640 --> 00:19:59,920
从而得到X。

369
00:20:01,520 --> 00:20:02,240
另一方面，

370
00:20:02,240 --> 00:20:05,000
由于QH就是B的逆矩阵Q撇，

371
00:20:05,120 --> 00:20:10,120
并且可以证明Q撇也满足十字偶校验约束，

372
00:20:10,120 --> 00:20:15,040
因此我们也可以通过KQ求出逆矩阵Q撇的第一行Q撇0，

373
00:20:15,520 --> 00:20:18,120
再通过递推公式求得完整的Q撇，

374
00:20:18,400 --> 00:20:20,720
最后再和Y相乘求得X，

375
00:20:22,240 --> 00:20:24,720
两种方法求得的X是相同的，

376
00:20:24,720 --> 00:20:28,600
有兴趣的小伙伴可以自行证明，

377
00:20:28,600 --> 00:20:31,320
不过整个求解的过程中有一个问题。

378
00:20:31,520 --> 00:20:37,880
那就是我们假设满足QXPX等于一modFX的多项式QX存在，

379
00:20:39,360 --> 00:20:41,920
如果这样的多项式QX不存在，

380
00:20:41,920 --> 00:20:43,200
我们又当如何呢？

381
00:20:44,640 --> 00:20:47,000
在上集视频解的数量章节中，

382
00:20:47,000 --> 00:20:53,720
我们提到了公式R撇N这里GCD表示最大公因子，

383
00:20:53,720 --> 00:20:58,880
不难发现这里的GCDFC就是前面扩展欧几里德算法中的G。

384
00:21:00,480 --> 00:21:01,000
同时，

385
00:21:01,000 --> 00:21:02,720
由于F等于C加P，

386
00:21:02,800 --> 00:21:06,720
因此GCDFC和GCDFP是相等的。

387
00:21:08,160 --> 00:21:13,040
这里DEG表示最高次数R撇代表矩阵B丢失的值，

388
00:21:13,120 --> 00:21:18,640
也就是N减二R撇的值决定了解的数量及二的二撇次方。

389
00:21:20,080 --> 00:21:23,200
将GX写成矩阵的形式记为G，

390
00:21:24,640 --> 00:21:29,200
不难注意到只有当矩阵B为可逆矩阵时GX等于1。

391
00:21:29,440 --> 00:21:33,920
并且GX的最高次数为2撇等于n减2等于0，

392
00:21:35,600 --> 00:21:37,600
例如当n等于5时，

393
00:21:37,600 --> 00:21:43,960
高斯消元后的B的尾逆矩阵Q撇和单位矩阵一撇是这样的，

394
00:21:43,960 --> 00:21:45,800
这里矩阵B不可逆，

395
00:21:45,800 --> 00:21:47,360
其至为2等于3，

396
00:21:47,920 --> 00:21:50,040
现在我们以2乘2为界，

397
00:21:50,040 --> 00:21:53,800
将矩阵分为4块，

398
00:21:53,800 --> 00:21:57,200
1矩阵B左上角R乘2的子矩阵可逆。

399
00:21:57,440 --> 00:22:03,480
并且和Q撇左上角R乘二的子矩阵互为逆矩阵，

400
00:22:03,480 --> 00:22:07,520
二Q撇右下角和一撇左上角为单位矩阵，

401
00:22:07,520 --> 00:22:12,560
Q撇右上角和一撇下方为零矩阵，

402
00:22:12,560 --> 00:22:17,600
三Q撇左下角W二和一撇右上角的静默操作相同，

403
00:22:17,600 --> 00:22:24,480
并且其值等于Q撇左上角乘以B右上角或者B左下角乘以Q撇左上角

404
00:22:24,480 --> 00:22:24,520
。

405
00:22:26,080 --> 00:22:29,000
这些性质可以通过分块矩阵乘法，

406
00:22:29,000 --> 00:22:32,320
结合高斯消元法和矩阵B的对称性得出，

407
00:22:32,480 --> 00:22:35,000
有兴趣的小伙伴可以自行证明，

408
00:22:36,480 --> 00:22:39,640
可以发现Q撇不满足十四偶校验约束，

409
00:22:39,640 --> 00:22:41,800
因而无法通过公式递推求得，

410
00:22:42,480 --> 00:22:44,960
并且使用Q撇第一行求得的X，

411
00:22:44,960 --> 00:22:46,360
也不是原方程的解，

412
00:22:47,840 --> 00:22:50,560
如果我们令Q撇第一行为QX，

413
00:22:50,640 --> 00:22:52,360
并且和PX相乘。

414
00:22:52,560 --> 00:22:54,760
由此得到的GX不为一，

415
00:22:54,840 --> 00:22:57,640
且最高次数为四。

416
00:22:57,640 --> 00:22:58,320
另一方面，

417
00:22:58,400 --> 00:23:01,040
如果我们直接使用扩展欧几里德法，

418
00:23:01,040 --> 00:23:03,920
通过PX和FX进行求解，

419
00:23:03,920 --> 00:23:05,880
得到的GX也不为一。

420
00:23:07,360 --> 00:23:10,200
将求得的QX和PX相乘，

421
00:23:10,200 --> 00:23:12,280
得到刚才求得的GX，

422
00:23:12,280 --> 00:23:13,760
其最高次数为二。

423
00:23:15,280 --> 00:23:17,440
这里我们计算QHY，

424
00:23:17,520 --> 00:23:20,040
发现求得的X也不是正确的解。

425
00:23:21,600 --> 00:23:25,320
两种方法求得的QX和GX都不相同，

426
00:23:25,400 --> 00:23:26,760
GX都不唯一，

427
00:23:26,880 --> 00:23:29,720
并且QHY也都不是正确的解。

428
00:23:31,200 --> 00:23:31,840
因此，

429
00:23:31,840 --> 00:23:33,600
如果GX不唯一，

430
00:23:33,600 --> 00:23:35,040
则QX不满足，

431
00:23:35,040 --> 00:23:42,480
QXPX等于1modFX或者说满足QXPX等于1的QX不存在

432
00:23:42,480 --> 00:23:42,520
。

433
00:23:44,000 --> 00:23:44,480
那么，

434
00:23:44,480 --> 00:23:46,000
对于不可逆的矩阵B，

435
00:23:46,080 --> 00:23:48,720
我们又有什么方法可以求出正确的解呢？

436
00:23:50,240 --> 00:23:52,080
在刚才的首行求逆法中，

437
00:23:52,080 --> 00:23:53,200
我们有这些公式。

438
00:23:54,640 --> 00:24:01,000
现在我们定义多项是Q撇X满足Q撇XPX等于GXmodFX。

439
00:24:02,880 --> 00:24:09,360
其中GX也就是刚才提到的最大公因子Q撇X就是刚才求得的QX。

440
00:24:11,200 --> 00:24:13,920
由于原本求得的X并不是正确的解，

441
00:24:14,000 --> 00:24:18,160
我们将其重命名为Z即Z等于Q撇HY。

442
00:24:20,240 --> 00:24:20,760
同时，

443
00:24:20,760 --> 00:24:23,720
我们定义Q撇X的逆多项是P撇X，

444
00:24:23,920 --> 00:24:24,960
即Q撇X，

445
00:24:24,960 --> 00:24:27,400
P撇X等于1modFX。

446
00:24:28,960 --> 00:24:30,640
我们不难推出这些式子，

447
00:24:31,120 --> 00:24:32,240
为了方便表示，

448
00:24:32,240 --> 00:24:36,480
这里将modFX的部分省去了。

449
00:24:36,480 --> 00:24:37,120
整理后，

450
00:24:37,120 --> 00:24:38,680
我们可以得到这些式子，

451
00:24:40,160 --> 00:24:43,520
最终我们得到了C等于GHX。

452
00:24:44,000 --> 00:24:44,520
这里，

453
00:24:44,520 --> 00:24:46,000
如果GX等于1，

454
00:24:46,160 --> 00:24:47,640
则会有右边这些式子。

455
00:24:49,200 --> 00:24:51,360
前面使用的扩展欧几里得法中，

456
00:24:51,360 --> 00:24:54,120
我们已求得Q撇X和GX，

457
00:24:54,640 --> 00:24:58,920
因此接下来只需要使用GX和Z即可求得X。

458
00:25:00,480 --> 00:25:03,840
前者我们有公式Z等于Q撇HY，

459
00:25:04,320 --> 00:25:06,120
我们不断让Y乘以H，

460
00:25:06,240 --> 00:25:09,440
然后使用向量乘以矩阵的方法求得Z。

461
00:25:10,960 --> 00:25:14,800
现在我们有公式Z等于GHX，

462
00:25:14,800 --> 00:25:16,560
由于需要求得的是X，

463
00:25:16,640 --> 00:25:19,040
因此不能再使用这个方法来求解。

464
00:25:20,480 --> 00:25:23,520
这次我们需要用反向叠加法来求X，

465
00:25:24,000 --> 00:25:27,360
我们以N等于5为例，

466
00:25:27,360 --> 00:25:32,000
首先我们需要使用类似生成矩阵B的方法生成GH，

467
00:25:32,000 --> 00:25:33,480
这里即为矩阵D，

468
00:25:33,480 --> 00:25:37,080
其质与矩阵B相同，

469
00:25:37,080 --> 00:25:39,040
一创建N个单位向量，

470
00:25:39,120 --> 00:25:40,960
也就是矩阵D的第一行，

471
00:25:41,440 --> 00:25:43,120
这里和矩阵B相同，

472
00:25:43,120 --> 00:25:44,560
一共有N个向量。

473
00:25:46,480 --> 00:25:51,040
二使用矩阵H将每个矩阵地的第一行扩散到后续的行，

474
00:25:52,960 --> 00:25:57,840
三根据多项式GX将每个矩阵地的对应行叠加起来，

475
00:25:57,840 --> 00:26:00,720
叠加完的行共同构成一个新的矩阵地，

476
00:26:02,240 --> 00:26:05,360
可以发现这里的步骤和首行叠加法类似，

477
00:26:05,520 --> 00:26:07,400
共有N个矩阵要生成，

478
00:26:07,400 --> 00:26:11,560
时间复杂度是ON的三次方，

479
00:26:11,560 --> 00:26:13,640
不过聪明的你一定能想到。

480
00:26:13,920 --> 00:26:16,800
通过生成矩阵法调换矩阵的行以后，

481
00:26:16,800 --> 00:26:21,120
这些矩阵也都满足十字偶校验约束，

482
00:26:21,120 --> 00:26:24,040
因此我们同样只需要生成第一个矩阵，

483
00:26:24,240 --> 00:26:26,240
然后递推即可得到矩阵地，

484
00:26:26,560 --> 00:26:31,120
时间复杂度降位了ON的二次方，

485
00:26:31,120 --> 00:26:33,120
在生成第一个矩阵的过程中，

486
00:26:33,120 --> 00:26:36,880
每行乘以矩阵H的结果就是刚才的矩阵K，

487
00:26:38,400 --> 00:26:41,200
因此类似Q撇0等于KQ。

488
00:26:41,360 --> 00:26:44,160
只需要将GX和K直接相乘，

489
00:26:44,320 --> 00:26:46,560
即可得到第一个矩阵的最后一行，

490
00:26:46,800 --> 00:26:48,400
即矩阵地的第一行地。

491
00:26:49,920 --> 00:26:54,720
然后我们就可以使用十字偶校验约束的递推关系求得之后的行。

492
00:26:56,240 --> 00:26:58,960
由于矩阵地是由矩阵H生成的，

493
00:26:58,960 --> 00:27:01,400
因此具有以下这些性质。

494
00:27:01,400 --> 00:27:02,720
这里N等于5，

495
00:27:03,120 --> 00:27:04,200
R等于3，

496
00:27:04,200 --> 00:27:05,000
2撇等于2。

497
00:27:05,000 --> 00:27:08,640
1后2等于3行。

498
00:27:08,960 --> 00:27:13,320
第n行最左边的n减二撇负一等于n减三个元素为零，

499
00:27:15,120 --> 00:27:16,800
二后二等于三行，

500
00:27:16,960 --> 00:27:22,520
第n行第n减二撇等于n减二个元素为一，

501
00:27:22,520 --> 00:27:24,400
三后二等于三行，

502
00:27:24,560 --> 00:27:30,120
任意一行都不能由别的行叠加及线性无关，

503
00:27:30,120 --> 00:27:32,000
四前二撇等于二行，

504
00:27:32,160 --> 00:27:35,200
任意一行都可以由后二等于三行叠加。

505
00:27:36,800 --> 00:27:38,520
这些性质都不难证明，

506
00:27:38,520 --> 00:27:42,280
有兴趣的小伙伴可以自行证明。

507
00:27:42,280 --> 00:27:45,840
现在我们有Z等于GHX等于DX，

508
00:27:46,320 --> 00:27:48,640
我们可以利用D的性质进行求解。

509
00:27:49,120 --> 00:27:53,400
接下来我们需要将Z拆解成矩阵D的若干行的叠加，

510
00:27:53,400 --> 00:27:56,400
从而表示出X。

511
00:27:56,400 --> 00:27:58,960
由于矩阵D后三行线性无关，

512
00:27:58,960 --> 00:28:01,880
因此我们只考虑把后三行叠加起来，

513
00:28:01,880 --> 00:28:03,120
不考虑前二行。

514
00:28:04,720 --> 00:28:08,800
这里我们尝试将后三行的若干行叠加到现有的Z上，

515
00:28:08,800 --> 00:28:09,960
使其被消去。

516
00:28:11,440 --> 00:28:14,720
让我们观察Z的第一个元素和D的后三行，

517
00:28:15,280 --> 00:28:16,720
在D的后三行中，

518
00:28:16,720 --> 00:28:20,160
第三行的第一个元素为一。

519
00:28:20,160 --> 00:28:22,560
由于Z的第一个元素已经为零，

520
00:28:23,040 --> 00:28:24,560
如果我们叠加第三行，

521
00:28:24,640 --> 00:28:27,600
则Z的第一个元素会变为一，

522
00:28:27,600 --> 00:28:29,440
因此不能叠加第三行。

523
00:28:30,960 --> 00:28:32,960
我们再看Z的第二个元素，

524
00:28:32,960 --> 00:28:34,000
该元素为一。

525
00:28:34,200 --> 00:28:34,720
因此，

526
00:28:34,720 --> 00:28:38,600
我们需要将第四行叠加到Z上。

527
00:28:38,600 --> 00:28:41,400
现在Z的第二个元素被消去了，

528
00:28:41,400 --> 00:28:46,200
同时X的第四个元素被标记为1。

529
00:28:46,200 --> 00:28:48,880
我们接着看Z的第三个元素，

530
00:28:48,880 --> 00:28:51,120
由于Z的第三个元素变为了1，

531
00:28:51,280 --> 00:28:53,040
我们需要叠加D的第五行。

532
00:28:54,640 --> 00:28:56,880
这次Z被彻底消去了，

533
00:28:56,880 --> 00:28:57,680
变为了0，

534
00:28:57,840 --> 00:29:00,800
并且X的第五个元素被标记为1。

535
00:29:02,400 --> 00:29:02,920
由此，

536
00:29:02,920 --> 00:29:07,200
我们通过一次叠加D的后三行将Z的元素依次消去，

537
00:29:07,680 --> 00:29:10,080
同时将叠加的行标记为一，

538
00:29:10,080 --> 00:29:11,840
也就求得了最终的X。

539
00:29:13,360 --> 00:29:16,280
不难发现这里求得的X是一个特解，

540
00:29:17,760 --> 00:29:21,400
由于前二撇行可以表示为后二行的线性叠加，

541
00:29:21,680 --> 00:29:26,520
因此我们可以在操作Y之前先将其和前二撇的任意行叠加，

542
00:29:26,520 --> 00:29:29,160
然后再求解。

543
00:29:29,160 --> 00:29:32,080
由于前二撇行共有二的二撇次方种。

544
00:29:32,320 --> 00:29:32,800
因此，

545
00:29:32,800 --> 00:29:35,200
求得的解也有二的二撇次方种。

546
00:29:36,720 --> 00:29:37,440
另一方面，

547
00:29:37,520 --> 00:29:40,240
由于矩阵地满足十字偶校验约束，

548
00:29:40,240 --> 00:29:42,520
表现出高度的对称性。

549
00:29:42,520 --> 00:29:43,040
其中，

550
00:29:43,040 --> 00:29:46,400
行和列的坐标可以互换，

551
00:29:46,400 --> 00:29:48,960
因此我们可以同样只叠加前二行，

552
00:29:49,120 --> 00:29:51,600
从右往左进行消去。

553
00:29:51,600 --> 00:29:53,120
由于结果是相同的，

554
00:29:53,120 --> 00:29:54,320
这里不再赘述。

555
00:29:55,760 --> 00:29:57,520
细心的小伙伴会发现，

556
00:29:57,520 --> 00:29:59,720
这两个式子具有相同的形式。

557
00:30:01,280 --> 00:30:05,280
既然我们可以在第一个式子用反向叠加法求X，

558
00:30:05,280 --> 00:30:08,960
为什么不能用相同的方法在第二个式子求X呢？

559
00:30:10,400 --> 00:30:13,680
这是因为矩阵D是由GH生成的，

560
00:30:13,680 --> 00:30:16,280
具有带状上三角的可回带结构，

561
00:30:16,280 --> 00:30:19,920
满足前面说到的四个性质，

562
00:30:19,920 --> 00:30:23,120
而B等于P撇HD破坏了这一结构，

563
00:30:23,120 --> 00:30:24,960
不满足这些性质。

564
00:30:24,960 --> 00:30:27,680
这里D等于GH不可逆，

565
00:30:27,680 --> 00:30:29,960
因此P撇H不唯一。

566
00:30:31,360 --> 00:30:31,840
不过，

567
00:30:31,840 --> 00:30:33,120
当G等于E时，

568
00:30:33,120 --> 00:30:34,720
这种解法是可行的。

569
00:30:35,040 --> 00:30:38,320
尽管这个方法首先需要求出完整的矩阵B，

570
00:30:39,840 --> 00:30:42,600
同时因为矩阵B不是三角结构，

571
00:30:42,600 --> 00:30:46,000
还需标记每行首个唯一的元素的位置来选择。

572
00:30:46,480 --> 00:30:47,080
因此，

573
00:30:47,080 --> 00:30:51,280
直接计算QHY会更加方便。

574
00:30:51,280 --> 00:30:51,800
最终，

575
00:30:51,800 --> 00:30:54,520
我们通过欧几里德法和反向叠加法。

576
00:30:54,800 --> 00:30:56,960
完成了BX等于Y的求解，

577
00:30:57,040 --> 00:30:58,400
实现了点灯游戏，

578
00:30:58,400 --> 00:31:02,960
ON的二次方的时间复杂度的算法。

579
00:31:02,960 --> 00:31:04,640
向量和矩阵的乘法，

580
00:31:04,640 --> 00:31:05,920
欧几里德算法，

581
00:31:05,920 --> 00:31:07,200
逆向校园法，

582
00:31:07,200 --> 00:31:10,800
理论上通过卷积FFT或牛顿迭代法，

583
00:31:10,800 --> 00:31:15,280
是有可能优化到ON乘logN的。

584
00:31:15,280 --> 00:31:17,600
考虑到UP主信号与系统，

585
00:31:17,680 --> 00:31:18,880
数字信号处理，

586
00:31:18,880 --> 00:31:20,520
数值分析等课程较差，

587
00:31:20,800 --> 00:31:22,320
暂时就不研究了。

588
00:31:22,880 --> 00:31:25,640
有兴趣的小伙伴可自行研究并留言，

589
00:31:27,120 --> 00:31:29,080
如果对视频中的内容有疑问，

590
00:31:29,200 --> 00:31:33,560
觉得视频内容表述不清或者发现视频中的任何错误，

591
00:31:33,560 --> 00:31:36,080
也请小伙伴们多多留言和指正，

592
00:31:36,640 --> 00:31:37,480
谢谢观看。

