上次我们在首行叠加法中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。

B(y,x)=B(y-1,x-1)⊕B(y-1,x)⊕B(y-1,x+1)⊕B(y-2,x)

这里，我们用B表示按钮，L表示灯。n,y,x则表示为：
n:从左到右第n列灯：这里的公式对任意第n个灯都满足，所以省去）。
y:从上到下第y行：灯或按钮，也代表第y次迭代，因为我们是一行一行进行推导的。
x:从左到右第x列按钮：需要将灯表示为第一行的某几个列的按钮的叠加，这里的x不局限于第一行。

——————————————————————

在叠加法中，我们将灯表示为所有按钮的叠加。而首行叠加法中，我们则需要把表示为第一行按钮的叠加。

让我们举一个具体的例子，在5x5的格子中，L代表灯，B代表按钮，⊕代表叠加，¬代表翻转，并将灯和按钮编号1-25。
在叠加法中，L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
在首行叠加法中，按法是动态的。在B6还没有按下时，L1=B1⊕B2，然后再让B6=¬L1=¬(B1⊕B2)。
同样，L6=B1⊕B6⊕B7=B1⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)=B1⊕B3
又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)⊕¬(B2⊕B3⊕B4)=¬B4
这样不断递推，我们可以将任意L表达为某些B1到B5的叠加，再加上翻转。

现在，把序号1-25用坐标x,y表示，使用公式表达，则可写为：
L(y,x)=B(y-1,x-1)⊕B(y,x-1)⊕B(y,x)⊕B(y,x+1)
B(y+1,x)=¬L(y,x)=¬(B(y-1,x-1)⊕B(y,x-1)⊕B(y,x)⊕B(y,x+1))
如果把翻转¬提取出来，便有了一开始的推导公式：
B(y,x)=B(y-1,x-1)⊕B(y-1,x)⊕B(y-1,x+1)⊕B(y-2,x)

——————————————————————

将B写成矩阵，前3行为：
10000
11000
10100
这里的第一行是10000，是因为B1也需要表示为B1到B5的表达式，也就是B1=B1。
在上一个视频中，因为写的是L矩阵，因此从L1=B1⊕B2，也就是第二行开始。
这里应该把第一行写上，因为B1=B1在后续的推导中也是必要的。
因为B(y+1,x)=¬L(y,x)，因此L矩阵和B矩阵在内容上是相同的，仅仅是L少了B的第一行。
因为需要推导的是L1到L5而不是B，因此一共需要推导5次，对B矩阵来说，一共是6行。

对于翻转的情况，则可以单独列出来，从零向量开始，以类似的方法推导
l(y,x)=not(l(y-1,x-1) xor l(y-1,x) xor l(y-1,x+1) xor l(y-2,x));
//这里的l记号和L好像不一样

——————————————————————

这些矩阵具有十字偶校验约束性质，这是一个十分重要的性质，下面我来证明。
//n,x,y含义要写清楚。
B(x-1,y) xor B(x+1,y) xor B(x,y-1) xor B(x,y+1) = 0
通过这个性质，可以由第一个灯推导后面的灯。

其实最左边漏掉一个单位矩阵和一个零矩阵，而单位矩阵和零矩阵显然满足这个性质：
(1) 十字偶校验约束：a(x-1,y) ⊕ a(x+1,y) ⊕ a(x,y-1) ⊕ a(x,y+1) = b(x,y) = 0

对于右边的矩阵，我们有：
(2) 矩阵递推关系：a(n,x,y) = a(n-1,x-1,y) ⊕ a(n-1,x,y) ⊕ a(n-1,x+1,y) ⊕ a(n-2,x,y)

然后我们将(2)代入(1)，可以得到：
(a(n-1,x-1-1,y) ⊕ a(n-1,x-1,y) ⊕ a(n-1,x+1-1,y) ⊕ a(n-2,x-1,y)) ⊕
(a(n-1,x-1+1,y) ⊕ a(n-1,x+1,y) ⊕ a(n-1,x+1+1,y) ⊕ a(n-2,x+1,y)) ⊕
(a(n-1,x-1,y-1) ⊕ a(n-1,x,y-1) ⊕ a(n-1,x+1,y-1) ⊕ a(n-2,x,y-1)) ⊕
(a(n-1,x-1,y+1) ⊕ a(n-1,x,y+1) ⊕ a(n-1,x+1,y+1) ⊕ a(n-2,x,y+1))
重新排列顺序，得到：
(a(n-1,x-1-1,y) ⊕ a(n-1,x-1+1,y) ⊕ a(n-1,x-1,y-1) ⊕ a(n-1,x-1,y+1)) ⊕
(a(n-1,x-1,y) ⊕ a(n-1,x+1,y) ⊕ a(n-1,x,y-1) ⊕ a(n-1,x,y+1)) ⊕
(a(n-1,x+1-1,y) ⊕ a(n-1,x+1+1,y) ⊕ a(n-1,x+1,y-1) ⊕ a(n-1,x+1,y+1)) ⊕
(a(n-2,x-1,y) ⊕ a(n-2,x+1,y)) ⊕ a(n-2,x,y-1) ⊕ a(n-2,x,y+1))
不难发现，这四项都符合(1)，因此式子可以化为：
b(n-1,x-1,y) ⊕ b(n-1,x,y) ⊕ b(n-1,x+1,y) ⊕ b(n-2,x,y) = 0 ⊕ 0 ⊕ 0 ⊕ 0 = 0。
——————————————————————

在讲O(n^2)的算法之前，需要介绍一个非常重要的矩阵F/多项式f(x)
这个矩阵F满足特性：F(y,x)=F(y-1,x-1) xor F(y-2,x)
对应多项式f(x)就是之前提到的OEIS中的Fibonacci多项式：
f(n, x) = x · f(n-1, x) + f(n-2, x)
这个多项式是这个算法的核心，之后会多次用到。
f(n,x)就是χ(x)
F={f(0),f(1)...f(n-1)}

为了实现这个算法，我们需要把B(n)拆分成多项式p(H)
也就是：B=p(H):=p0​I⊕p1​H⊕p2​H2⊕⋯.
从而通过这个式子求X：
BX=Y⟺p(H)X=Y.

刚才提到的多项式f(x)和矩阵邻接矩阵H有关。
向量乘以这个多项式的第n行相当于对向量乘以H^n（往两边扩散）。：
f(n,H)*v=H^n*v




我理解：

b 100010

b	F
1	1
0	01
0	101
0	0001
1	10101
0	010001
0	1000101

p = 1 + 10101 =  001010

下面的表达对不对？以下四个式子之间的关系是什么？如何互相推导？

1. 多项式f(x)和矩阵邻接矩阵H有关，满足：
f(n, x) = x · f(n-1, x) + f(n-2, x)
F(y,x)=F(y-1,x-1) xor F(y-2,x)
这里的矩阵F就是把每一个多项式f(n)的系数提取出来，写在第n行。

2. 向量乘以多项式的第n行相当于对向量乘以H^n（往两边扩散）。：
f(n,H)*v=H^n*v

3. 算法里p = B(n) * F，这里B(n)=b是矩阵第一行
p = b * F，这里b和p是行向量，F是刚才的矩阵。

4. 我们有数学公式：B(n)=p(H):=p0​I⊕p1​H⊕p2​H2⊕⋯.
第一行就是：b=p=p01*f(0)+p1*f(1)+p2*f(2)=p*F

