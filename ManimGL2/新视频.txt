上次我们在首行叠加法中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。

B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)

这里，我们用B表示按钮，L表示灯。n,x,y则表示为：

n:从上到下第n行：灯或按钮，也代表第y次迭代，因为我们是一行一行进行推导的。
x:从左到右第x列按钮：需要将灯表示为第一行的某几个列的按钮的叠加，这里的x不局限于第一行。
y:从左到右第y列灯：这里的公式对任意第y个灯都满足，所以省去。

——————————————————————

让我们举一个具体的例子，在5x5的格子中，L代表灯，B代表按钮，⊕代表叠加，¬代表翻转，并将灯和按钮编号1-25。
而首行叠加法中，。
在叠加法中，我们将灯表示为所有按钮的叠加，例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
在首行叠加法中，我们则需要把灯表示为第一行按钮的叠加。
由于按法是动态的。在B6还没有按下时，L1=B1⊕B2，然后再让B6=¬L1=¬(B1⊕B2)。
同样，L6=B1⊕B6⊕B7=B1⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)=B1⊕B3
又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)⊕¬(B2⊕B3⊕B4)=¬B4
这样不断递推，我们可以将任意L表达为某些B1到B5的叠加，再加上翻转。

——————————————————————

现在，把序号1-25用坐标x,y表示，使用公式表达，则可写为：
L(n,x)=B(n-1,x-1)⊕B(n,x-1)⊕B(n,x)⊕B(n,x+1)：灯为上左右按钮的叠加
B(n+1,x)=¬L(n,x)=¬(B(n-1,x-1)⊕B(n,x-1)⊕B(n,x)⊕B(n,x+1))：下一行按钮是当前灯翻转
如果把翻转¬提取出来，便有了一开始的推导公式：
B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)：按钮是上一行左中右按钮和上上行按钮叠加

——————————————————————

将B写成矩阵，前3行为：
10000
11000
10100
这里的第一行是10000，是因为B1也需要表示为B1到B5的表达式，也就是B1=B1。
在上一个视频中，因为写的是L矩阵，因此从L1=B1⊕B2，也就是第二行开始。
这里应该把第一行写上，因为B1=B1在后续的推导中也是必要的。
因为B(n+1,x)=¬L(n,x)，因此L矩阵和B矩阵在内容上是相同的，仅仅是L少了B的第一行。
因为需要推导的是L1到L5而不是B，因此一共需要推导5次，对B矩阵来说，一共是6行。

——————————————————————

对于翻转的情况，则可以单独列出来，以类似的方法推导，写成R公式：
R(n,y)=¬(R(n-1,y-1)⊕R(n-1,y)⊕R(n-1,y+1)⊕R(n-2,y));
可以注意到，这里的公式R和B是一样的。只不过，R是从零向量开始推导的，并且不能省略翻转符号¬，因为：
1. 使用零向量：第一次翻转发生在从第一行到第二行的迭代过程中，在此之前没有发生过翻转，因此R的第一行就不是10000而是00000了。
2. 翻转符号¬必须存在：是因为每次迭代都需要翻转，因此不可省略。而前者将这个翻转取出来了，不用翻转符号¬。
3. 不使用x而使用y：因为这个翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。

——————————————————————

在生成优化矩阵章节中，我将矩阵的行重排，其实是调换了n和y的位置，使原来从左到右为第y个矩阵变为了第n个矩阵。

这些矩阵具有一个性质，我称之为：十字偶校验约束。这个性质对任意第n个矩阵都满足。
B(x-1,y)⊕B(x+1,y)⊕B(x,y-1)⊕B(x,y+1)=0
这是一个十分重要的性质。通过这个性质，可以由第一个灯推导后面的灯。
在后面会说的O(n^2)算法中，其本质也是利用这个性质进行的优化。

下面让我用数学归纳法，证明这个性质。

首先，易知零矩阵和第一个单位矩阵满足这个性质。因此，我们只需证明，如果B(n-1)和B(n-2)满足这个性质，则B(n)也满足这个性质。也就是需要证明：
B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=0
将刚才的矩阵递推关系加上参数y并重写为：B(n,x,y)=B(n-1,x-1,y)⊕B(n-1,x,y)⊕B(n-1,x+1,y)⊕B(n-2,x,y)
于是，对于B(n)，我们将递推关系代入这个式子，有；
B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=
(B(n-1,x-1-1,y)⊕B(n-1,x-1,y)⊕B(n-1,x+1-1,y)⊕B(n-2,x-1,y)) ⊕
(B(n-1,x-1+1,y)⊕B(n-1,x+1,y)⊕B(n-1,x+1+1,y)⊕B(n-2,x+1,y)) ⊕
(B(n-1,x-1,y-1)⊕B(n-1,x,y-1)⊕B(n-1,x+1,y-1)⊕B(n-2,x,y-1)) ⊕
(B(n-1,x-1,y+1)⊕B(n-1,x,y+1)⊕B(n-1,x+1,y+1)⊕B(n-2,x,y+1))
重新排列顺序（也就是生成矩阵章节将y和n掉换），得到：
(B(n-1,x-1-1,y)⊕B(n-1,x-1+1,y)⊕B(n-1,x-1,y-1)⊕B(n-1,x-1,y+1)) ⊕
(B(n-1,x-1,y)⊕B(n-1,x+1,y)⊕B(n-1,x,y-1)⊕B(n-1,x,y+1)) ⊕
(B(n-1,x+1-1,y)⊕B(n-1,x+1+1,y)⊕B(n-1,x+1,y-1)⊕B(n-1,x+1,y+1)) ⊕
(B(n-2,x-1,y)⊕B(n-2,x+1,y))⊕B(n-2,x,y-1)⊕B(n-2,x,y+1))
不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此式子可以化为：
0⊕0⊕0⊕0=0。

因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出下面的行：
B(x,y)=B(x-1,y-1)⊕B(x-1,y+1)⊕B(x-2,y)
通过这种方法，我们无需对每个y都生成矩阵B，只需计算这些B矩阵的第一行，得到B(n)的第一行，即可求得完整的矩阵B(n)。

——————————————————————

对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。

我们的目标是在O(n^2)，在已知B和Y的情况下求X：BX=Y。
这里的B就是前面提到的按钮矩阵B，而Y就是翻转矩阵R的最后一行。

为了实现这个目标，我们需要首先将B进行分解。
这里，让我首先介绍一个非常重要的矩阵H，我称之为邻接矩阵。
H矩阵的一般形式是：
01....
101...
.101..
..101.
...101
....10
或者写成公式
H(y,x)​=​∣x−y∣=1
如果将向量乘以该矩阵，等同于将向量每个元素向左右扩散后叠加：
v(x)*H=v(x-1)⊕v(x+1)

——————————————————————

如果将多个H相乘，也就是H^n，则其首行H(0)^n看起来像是这样（这里从单位矩阵n=0开始）：
0	1.....
1	01....
2	101...
3	0001..
4	00101.
5	010001
让我们把这个下三角矩阵命名为K（Krylov矩阵或扩散基矩阵）。对于K的第n行有：K(n)=H(0)^n。
根据这个定义我们有，K(n)=k(n-1)*H，也就是下一行为上一行乘以H。
再根据刚才向量乘以H的原理，这下一行就是上一行的左右扩散，于是有：
K(y,x)=K(y-1,x-1)⊕K(y-1,x+1)

——————————————————————

现在，定义多项式p(x)=p0x^0+p1x^1+p2x^2...
让我们把B拆分成H^n，使用多项式p(H)表示，也就是
B=p(H)=p0​H^0⊕p1​H^1⊕p2​H2⊕⋯
于是，原始求X的问题就变为了：
BX=Y⟺p(H)X=Y

现在，我们需要把多项式p(H)的系数写出来，这个系数构成的向量我们写为p=(p0,p1,p2...)。
为了简化运算，我们只关心矩阵第一行B(0)，命名为b。根据刚才的定义，我们有：
b=B(0)=p(H(0))=p0​H(0)^0⊕p1​H(0)^1⊕p2​H2(0)⊕⋯=p0​K(0)⊕p1K(1)⊕p2K(2)⊕⋯=p*K

——————————————————————

为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1，为了方便我们命名为F（反Krylov矩阵或解耦矩阵）：
0	1.....
1	01....
2	101...
3	0001..
4	10101.
5	010001
这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多。
事实上，这个矩阵也满足类似的性质：
F(y,x)=F(y-1,x-1)⊕F(y-2,x)
有兴趣的小伙伴可以试着证明一下（使用这两个性质构造的矩阵K和F互为逆矩阵）。

这里说一下，这个矩阵对应的多项式f(x)，就是上一集视频中提到的OEIS中的Fibonacci多项式，用于计算矩阵的失秩：
f(n,x)=x·f(n-1,x)+f(n-2,x)
F={f(0),f(1)...f(n-1)}
在后续的算法中，还会用到χ(x)=f(n,x)

于是，我们便有：b*F=p*K*F=p。这样我们便求出了p。

——————————————————————

事实上，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
这是因为我们已经将问题从BX=Y转为了p(H)=Y。由此，在前面说到的生成矩阵也只需要计算第一行b。
由于在不同n的情况下b的计算方式是一样的，我们可以把n-1情况下算出的b，直接用于对n情况下b的计算，也就是：
b(n,x)=b(n-1,x-1)⊕b(n-1,x)⊕b(n-1,x+1)⊕b(n-2,x)
这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
为了求出p=b*F，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
因为矩阵F是有递推规律的，理论上使用FFT等算法可以优化到O(n*log(n))。

现在我们已求得了p，并将原始问题转换为了p(H)X=Y。那这又有什么用呢？

——————————————————————

试想一下，如果有一个多项式q(x)，满足：
q(x)p(x)=1 mod χ(x)
那么，将原始两边同时乘以q(H)，便有：
X=q(H)p(H)X=q(H)*Y
这样，我们就能立刻求出X。
让我把这样的多项式q(x)我们称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？

rev(...)



