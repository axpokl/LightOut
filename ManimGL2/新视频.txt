上次我们在首行叠加法中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。

B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)

这里，我们用B表示按钮，L表示灯。n,x,y则表示为：

n:从上到下第n行：灯或按钮，也代表第y次迭代，因为我们是一行一行进行推导的。
x:从左到右第x列按钮：需要将灯表示为第一行的某几个列的按钮的叠加，这里的x不局限于第一行。
y:从左到右第y列灯：这里的公式对任意第y个灯都满足，所以省去。

——————————————————————

让我们举一个具体的例子，在5x5的格子中，L代表灯，B代表按钮，⊕代表叠加，¬代表翻转，并将灯和按钮编号1-25。
而首行叠加法中，。
在叠加法中，我们将灯表示为所有按钮的叠加，例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
在首行叠加法中，我们则需要把灯表示为第一行按钮的叠加。
由于按法是动态的。在B6还没有按下时，L1=B1⊕B2，然后再让B6=¬L1=¬(B1⊕B2)。
同样，L6=B1⊕B6⊕B7=B1⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)=B1⊕B3
又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)⊕¬(B2⊕B3⊕B4)=¬B4
这样不断递推，我们可以将任意L表达为某些B1到B5的叠加，再加上翻转。

（这里可以演示按钮和灯矩阵，中间是灯向量，右边的灯元素是左边左中右上四个元素的叠加，然后直接复制到左边下一行，并标记灯向量）
（然后可以直接演示从上面四个元素到下面按钮元素，无需灯）

——————————————————————

现在，把序号1-25用坐标x,y表示，使用公式表达，则可写为：
L(n,x)=B(n-1,x-1)⊕B(n,x-1)⊕B(n,x)⊕B(n,x+1)：灯为上左中右按钮的叠加
B(n+1,x)=¬L(n,x)=¬(B(n-1,x-1)⊕B(n,x-1)⊕B(n,x)⊕B(n,x+1))：下一行按钮是当前灯翻转
L(n+1,x)=¬L(n-1,x-1)⊕¬L(n,x-1)⊕¬L(n,x)⊕¬L(n,x+1)：下一行灯是上左中右灯翻转的叠加
如果把翻转¬提取出来，便有了一开始的推导公式：
B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)：按钮是上一行左中右按钮和上上行按钮叠加
L(n,x)=L(n-1,x-1)⊕L(n-1,x)⊕L(n-1,x+1)⊕L(n-2,x)：灯是上一行左中右按钮和上上行灯叠加

之前叠加时是将多个B行一起叠加，如果拆分为每个B元素，则相当于从上左中右的位置一个个叠加。
这里用公式尽管是一个一个元素叠加的，但是由于每个被叠加的元素已经包含了之前叠加的结果，效果上和使用第一行叠加是相同的。

——————————————————————

将B写成矩阵，前3行为：
10000
11000
10100
这里的第一行是10000，是因为B1也需要表示为B1到B5的表达式，也就是B1=B1。
在上一个视频中，因为写的是L矩阵，因此L1=B1⊕B2，这里等同于B矩阵的第二行。
对于B矩阵来说，第一行是单位向量，将第一行按钮自身用第一行按钮表达出来，例如B1=B1。
因为B(n+1,x)=¬L(n,x)，因此L矩阵和B矩阵在内容上是相同的，仅仅是L少了B的第一行。
因为需要推导的是L1到L5，因此相当于从B的第一行推导5次，一共5行。因为最后一次推导的是灯，因此B矩阵也是5行。

——————————————————————

对于翻转的情况，则可以单独列出来，以类似的方法推导，写成R公式：
R(n,y)=¬(R(n-1,y-1)⊕R(n-1,y)⊕R(n-1,y+1)⊕R(n-2,y));
可以注意到，这里的公式R和B是一样的。只不过，R是从零向量开始推导的，并且不能省略翻转符号¬，因为：
1. 使用零向量：第一次翻转发生在从第一行到第二行的迭代过程中，在此之前没有发生过翻转，因此R的第一行就不是10000而是00000了。
2. 翻转符号¬必须存在：是因为每次迭代都需要翻转，因此不可省略。而前者将这个翻转取出来了，不用翻转符号¬。
3. 不使用x而使用y：因为这个翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。

——————————————————————

在生成优化矩阵章节中，我将矩阵的行重排，其实是调换了n和y的位置，使原来从左到右为第y个矩阵变为了第n个矩阵。

这些矩阵具有一个性质，我称之为：十字偶校验约束。这个性质对任意第n个矩阵都满足。
B(x-1,y)⊕B(x+1,y)⊕B(x,y-1)⊕B(x,y+1)=0
这是一个十分重要的性质。通过这个性质，可以由第一个灯推导后面的灯。
在后面会说的O(n^2)算法中，其本质也是利用这个性质进行的优化。

下面让我用数学归纳法，证明这个性质。

首先，易知零矩阵和第一个单位矩阵满足这个性质。因此，我们只需证明，如果B(n-1)和B(n-2)满足这个性质，则B(n)也满足这个性质。也就是需要证明：
B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=0
将刚才的矩阵递推关系加上参数y并重写为：B(n,x,y)=B(n-1,x-1,y)⊕B(n-1,x,y)⊕B(n-1,x+1,y)⊕B(n-2,x,y)
于是，对于B(n)，我们将递推关系代入这个式子，有；
B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=
(B(n-1,x-1-1,y)⊕B(n-1,x-1,y)⊕B(n-1,x+1-1,y)⊕B(n-2,x-1,y))⊕
(B(n-1,x-1+1,y)⊕B(n-1,x+1,y)⊕B(n-1,x+1+1,y)⊕B(n-2,x+1,y))⊕
(B(n-1,x-1,y-1)⊕B(n-1,x,y-1)⊕B(n-1,x+1,y-1)⊕B(n-2,x,y-1))⊕
(B(n-1,x-1,y+1)⊕B(n-1,x,y+1)⊕B(n-1,x+1,y+1)⊕B(n-2,x,y+1))
重新排列顺序（也就是生成矩阵章节将y和n掉换），得到：
(B(n-1,x-1-1,y)⊕B(n-1,x-1+1,y)⊕B(n-1,x-1,y-1)⊕B(n-1,x-1,y+1))⊕
(B(n-1,x-1,y)⊕B(n-1,x+1,y)⊕B(n-1,x,y-1)⊕B(n-1,x,y+1))⊕
(B(n-1,x+1-1,y)⊕B(n-1,x+1+1,y)⊕B(n-1,x+1,y-1)⊕B(n-1,x+1,y+1))⊕
(B(n-2,x-1,y)⊕B(n-2,x+1,y))⊕B(n-2,x,y-1)⊕B(n-2,x,y+1))
不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此式子可以化为：
0⊕0⊕0⊕0=0。

因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出下面的行：
B(x,y)=B(x-1,y-1)⊕B(x-1,y+1)⊕B(x-2,y)
通过这种方法，我们无需对每个y都生成矩阵B，只需计算这些B矩阵的第一行，得到B(n)的第一行，即可求得完整的矩阵B(n)。

——————————————————————

对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。

我们的目标是在O(n^2)，在已知B和Y的情况下求X：BX=Y。
这里的B就是前面提到的按钮矩阵B，而Y就是翻转矩阵R的最后一行。

为了实现这个目标，我们需要首先将B进行分解。
这里，让我首先介绍一个非常重要的矩阵H，我称之为邻接矩阵。
H矩阵的一般形式是：
01....
101...
.101..
..101.
...101
....10
或者写成公式
H(y,x)​=​∣x−y∣=1
如果将向量v乘以该矩阵，等同于将向量v的每个元素向左右扩散后叠加：
v(x)*H=v(x-1)⊕v(x+1)

——————————————————————

如果将多个H相乘，也就是H^n，则其首行H^n(0)看起来像是这样（这里从单位矩阵n=0开始）：
0	1.....
1	01....
2	101...
3	0001..
4	00101.
5	010001
让我们把这个下三角矩阵命名为K（Krylov矩阵或扩散基矩阵）。对于K的第n行有：K(n)=H^n(0)。
根据这个定义我们有，K(n)=k(n-1)*H，也就是下一行为上一行乘以H。
再根据刚才向量乘以矩阵H的原理，下一行就是上一行的左右扩散，于是有：
K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)

——————————————————————

现在，定义多项式p(x)=p0x^0+p1x^1+p2x^2...
让我们把B拆分成H^n，使用多项式p(H)表示，也就是
B=p(H)=p0*​H^0⊕p1​*H^1⊕p2​*H2⊕⋯
于是，原始求X的问题就变为了：
BX=Y⟺p(H)X=Y

现在，我们需要把多项式p(H)的系数写出来，这个系数构成的向量我们写为p=(p0,p1,p2...)。
为了简化运算，我们只关心矩阵第一行B(0)，命名为b。根据刚才的定义，我们有：
b=B(0)=p(H(0))=p0​*H^0(0)⊕p1*​H^1(0)⊕p2​*H^2(0)⊕⋯=p0​*K(0)⊕p1*K(1)⊕p2*K(2)⊕⋯=p*K

——————————————————————

为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1，为了方便我们命名为F（反Krylov矩阵或解耦矩阵）：
0	1.....
1	01....
2	101...
3	0001..
4	10101.
5	010001
这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵也满足类似的性质：
F(y,x)=F(y-1,x-1)⊕F(y-2,x)
有兴趣的小伙伴可以试着证明一下（使用这两个性质构造的矩阵K和F，然后证明互为逆矩阵）。

这里说一下，这个矩阵对应的多项式f(x)，就是上一集视频中提到的OEIS中的Fibonacci多项式，用于计算矩阵的失秩：
f(n,x)=x·f(n-1,x)⊕f(n-2,x)
F={f(0),f(1)...f(n-1)}

于是，我们便有：b*F=p*K*F=p。这样我们便求出了p。

——————————————————————

事实上，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
这是因为我们已经将问题从BX=Y转为了p(H)=Y。由此，在前面说到的生成矩阵也只需要计算第一行b。
由于在不同n的情况下b的计算方式是一样的，我们可以把n-1情况下算出的b，直接用于对n情况下b的计算，也就是：
b(n,x)=b(n-1,x-1)⊕b(n-1,x)⊕b(n-1,x+1)⊕b(n-2,x)
这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
为了求出p=b*F，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
因为矩阵F是有递推规律的，理论上使用FFT等算法可以优化到O(n*log(n))。

现在我们已求得了p，并将原始问题转换为了p(H)X=Y。那这又有什么用呢？

——————————————————————

试想一下，如果有一个多项式q(x)，满足：
q(x)p(x)=1 mod f(x)
这里的f(x)就是前面提到的多项式f(n,x)。那么，将原始两边同时乘以q(H)，便有：
X=q(H)p(H)X=q(H)*Y
这样，我们就能立刻求出X。
让我把这样的多项式q(x)我们称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？

这里，我们同样将q(x)的系数写为向量q，然后扩展欧几里得算法来求取q：

我们使用辗转相减法，将p(x)右移，使最高系数对齐，然后叠加到f(x)上。
如果叠加后的f(x)的最高次数小于p(x)，则将f(x)和p(x)互换，然后再次进行操作。
同时，我们定义一个单位多项式e(x)和零多项式o(x)，在对f(x)和p(x)操作的时候对e(x)和o(x)做同样操作。
这样，最终f(x)会被叠加到零，而剩下的p(x)则为两个多项式的最大公因子，命名为g(x)。
同时，最后剩下的o(x)则是p(x)的逆，也就是q(x)。

——————————————————————

现在，我们已求得q。于是，和刚才一样，我们有：
X=q(H)*Y=(q0*H^0⊕q1*H^1⊕q2*H^2⊕...)*Y=q0*H^0*Y⊕q1*H^1*Y⊕q2*H^2*Y⊕...
这里，我们可以从Y开始，不断将其和H相乘，使用左右扩散的办法计算下一个H^n*Y，然后和qn叠加，得到X。
通过这个办法，我们可以在O(n^2)中求得X。

不过，这整个过程有一个问题，就是我们假设满足q(x)p(x)=1 mod χ(x)的多项式q(x)存在。
不难证明，如果矩阵B是可逆的，这样的多项式就存在，并且q(x)就是逆矩阵B^-1的第一行。
而且可以证明，B的逆矩阵也满足十字偶校验约束，因此可以用逆矩阵第一行直接求出整个逆矩阵B^-1。

如果矩阵B不可逆呢？这种情况下，我们定义多项式q'(x)满足：
q'(x)p(x)=g(x) mod f(x)
其中g(x)=gcd(p(x),f(x))，也就是p(x)和f(x)的最大公约多项式。

——————————————————————

q'(x)p(x)=g(x)
由于求得的X已不是解，因此这里定义：
Z=q'(H)*Y
同时，我们定义q'(x)的逆多项式p'(x)：
q'(x)p'(x)=1
这里，如果g(x)=1时，则会有：
Z=X
q'(x)=q(x)
p'(x)=p(x)
我们不难推出以下结论：
p'(x)q'(x)p(x)=p'(x)g(x)
p(x)=p'(x)g(x)
q'(x)p(x)=g(x)
q'(x)=q'(x)p(x)q(x)=g(x)q(x)
另外，根据：
p(H)X=Y
我们有：
Z=q'(H)*Y=q'(H)p(H)*X=g(H)*X
g(H)*Y=q'(H)p(H)*Y=g(H)p(H)*X
B(n)*X=p(H)*X=g(H)p'(H)*X=p'(H)*Z=p'(H)q'(H)*Y=Y​

——————————————————————

整理后，我们得到以下式子：
q'(x)p'(x)=1
g(x)=q'(x)p(x)
p(x)=p'(x)g(x)
q'(x)=q(x)g(x)
Y=p(H)*X
Y=p'(H)*Z
Z=q'(H)*Y
Z=g(H)*X

刚才使用的扩展欧几里得法求得的q实际上是这里的q'，并且同时也获得了最大公因子g，因此接下来只需要使用g和Z求得X即可。
刚才我们用公式Z=q(H)Y，通过不断把Y和H叠加，利用类似用向量乘以矩阵的方式求得的Z。
这次我们有公式Z=g(H)X，由于需要求得的是X，需要用反向叠加的方式来求得。

这里我们需要使用类似生成B矩阵的办法来生成g(H)，命名为矩阵D：
1. 首先，创建n个单位向量，也就是D矩阵的第一行，这里和B矩阵相同，一共有n个向量。
2. 然后，使用H矩阵，将每个D矩阵第一行扩散到下面的行。
3. 最后，根据多项式g，将每个D矩阵的对应行叠加起来，叠加完的行共同构成一个新的D矩阵。
可以发现，这里的步骤和首行叠加法类似，共有n个矩阵要生成，时间复杂度是O(n^3)。
不过聪明的朋友一定能猜到，通过生成矩阵中的调换法整理矩阵的行以后，这些矩阵也都满足十字偶校验约束。因此同样只需要生成第一个矩阵，然后递推就行。
在这个过程中，不难发现，每行乘以H矩阵的结果，就是刚才的K矩阵。因此，只需要将g和K直接相乘即可得到第一个矩阵叠加后的行。

有了D矩阵，接下来我们只需要将Z拆解成不同D行的叠加，就能表式出X。(这里感觉说的有些问题）
具体方法是，我们先生成每个D行最大1的索引。对于Z的每个元素，如果其为1，则找到索引最大的D行叠加上去，同时记录到X。这样Z就会不断变小，直到最后为0，此时X就是解。（为什么？可以证明或者说明一下吗？）

由此，我们便通过计算gcd，在O(n^2)实现了BX=Y的求解，从而实现了点灯游戏在O(n^2)时间复杂度的算法。

——————————————————————

细心的观众会发现，其实这两个式子有相同的形式：
Y=p(H)*X
Z=g(H)*X
既然我们可以在第二个式子直接求X，为什么不能用相同的办法在第一个式子求X呢？
事实上，这种做法求得的X并不正确，因为。。。

——————————————————————
总结：

输出	输入	说明				算法		公式
Y	-	灯矩阵最后一行			公式递推		R(n,y)=¬(R(n-1,y-1)⊕R(n-1,y)⊕R(n-1,y+1)⊕R(n-2,y))
B	-	按钮矩阵第一行			公式递推		B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)
K	-	Krylov扩散基矩阵			公式递推		K(n,x)=K(n-1,x-1)⊕K(n-1,x+1)
F	-	反Krylov解耦矩阵			公式递推		F(n,x)=F(n-1,x-1)⊕F(n-2,x)
P	B,F	多项式p(H)的系数			矩阵向量乘法	P=B*F		
Q	F,P	多项式p(x)的在f(x)下的逆		扩展欧几里得	Q=P^-1 mod F
G	F,P	多项式p(x)和q(x)的最大共因子	扩展欧几里得	G=gcd(F,P)	
Z	Q,Y	部分逆按钮解			矩阵向量乘法	Z=Q*Y
D	G	多项式g(x)的矩阵					D=G*K
R	D	H每一行的主元索引		求最大值		R=max(D(n))
X	D,Z	最终首行按钮解			前向异或消元	Z=G*X
T	X	最终按钮解矩阵			公式递推		T(n,x)=T(n-1,x-1)⊕T(n-1,x)⊕T(n-1,x+1)⊕T(n-2,x)

——————————————————————

更快的算法：

向量和矩阵的乘法，欧几里得算法，以及K矩阵的生成，理论上通过卷积，FFT或牛顿迭代法是可能优化到O(n*log(n))的。
考虑到UP主《信号与系统》、《数字信号处理》、《数值分析》等课程学的比较差，暂时就不研究了。有兴趣的小伙伴可自行研究并留言。
如果对视频中的内容有疑问，对视频中表述不清，或者发现视频中的任何错误，也请大家多多留言和指证。谢谢大家观看！




