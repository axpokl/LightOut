上次我们在首行叠加法中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。

B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)

这里，我们用B表示按钮，L表示灯。n,x,y则表示为：

n:从上到下第n行：灯或按钮，也代表第y次迭代，因为我们是一行一行进行推导的。
x:从左到右第x列按钮：需要将灯表示为第一行的某几个列的按钮的叠加，这里的x不局限于第一行。
y:从左到右第y列灯：这里的公式对任意第y个灯都满足，所以省去。

——————————————————————

让我们举一个具体的例子，在5x5的格子中，L代表灯，B代表按钮，⊕代表叠加，¬代表翻转，并将灯和按钮编号1-25。
而首行叠加法中，。
在叠加法中，我们将灯表示为所有按钮的叠加，例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
在首行叠加法中，我们则需要把灯表示为第一行按钮的叠加。
由于按法是动态的。在B6还没有按下时，L1=B1⊕B2，然后再让B6=¬L1=¬(B1⊕B2)。
同样，L6=B1⊕B6⊕B7=B1⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)=B1⊕B3
又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)⊕¬(B2⊕B3⊕B4)=¬B4
这样不断递推，我们可以将任意L表达为某些B1到B5的叠加，再加上翻转。

——————————————————————

现在，把序号1-25用坐标x,y表示，使用公式表达，则可写为：
L(n,x)=B(n-1,x-1)⊕B(n,x-1)⊕B(n,x)⊕B(n,x+1)：灯为上左右按钮的叠加
B(n+1,x)=¬L(n,x)=¬(B(n-1,x-1)⊕B(n,x-1)⊕B(n,x)⊕B(n,x+1))：下一行按钮是当前灯翻转
如果把翻转¬提取出来，便有了一开始的推导公式：
B(n,x)=B(n-1,x-1)⊕B(n-1,x)⊕B(n-1,x+1)⊕B(n-2,x)：按钮是上一行左中右按钮和上上行按钮叠加

——————————————————————

将B写成矩阵，前3行为：
10000
11000
10100
这里的第一行是10000，是因为B1也需要表示为B1到B5的表达式，也就是B1=B1。
在上一个视频中，因为写的是L矩阵，因此从L1=B1⊕B2，也就是第二行开始。
这里应该把第一行写上，因为B1=B1在后续的推导中也是必要的。
因为B(n+1,x)=¬L(n,x)，因此L矩阵和B矩阵在内容上是相同的，仅仅是L少了B的第一行。
因为需要推导的是L1到L5而不是B，因此一共需要推导5次，对B矩阵来说，一共是6行。

——————————————————————

对于翻转的情况，则可以单独列出来，以类似的方法推导，写成R公式：
R(n,y)=¬(R(n-1,y-1)⊕R(n-1,y)⊕R(n-1,y+1)⊕R(n-2,y));
可以注意到，这里的公式R和B是一样的。只不过，R是从零向量开始推导的，并且不能省略翻转符号¬，因为：
1. 使用零向量：第一次翻转发生在从第一行到第二行的迭代过程中，在此之前没有发生过翻转，因此R的第一行就不是10000而是00000了。
2. 翻转符号¬必须存在：是因为每次迭代都需要翻转，因此不可省略。而前者将这个翻转取出来了，不用翻转符号¬。
3. 不使用x而使用y：因为这个翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。

——————————————————————

在生成优化矩阵章节中，我将矩阵的行重排，其实是调换了n和y的位置，使原来从左到右为第y个矩阵变为了第n个矩阵。

这些矩阵具有一个性质，我称之为：十字偶校验约束。这个性质对任意第n个矩阵都满足。
B(x-1,y)⊕B(x+1,y)⊕B(x,y-1)⊕B(x,y+1)=0
这是一个十分重要的性质。通过这个性质，可以由第一个灯推导后面的灯。
在后面会说的O(n^2)算法中，其本质也是利用这个性质进行的优化。

下面让我用数学归纳法，证明这个性质。

首先，易知零矩阵和第一个单位矩阵满足这个性质。因此，我们只需证明，如果B(n-1)和B(n-2)满足这个性质，则B(n)也满足这个性质。也就是需要证明：
B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=0
将刚才的矩阵递推关系加上参数y并重写为：B(n,x,y)=B(n-1,x-1,y)⊕B(n-1,x,y)⊕B(n-1,x+1,y)⊕B(n-2,x,y)
于是，对于B(n)，我们将递推关系代入这个式子，有；
B(n,x-1,y)⊕B(n,x+1,y)⊕B(n,x,y-1)⊕B(n,x,y+1)=
(B(n-1,x-1-1,y)⊕B(n-1,x-1,y)⊕B(n-1,x+1-1,y)⊕B(n-2,x-1,y)) ⊕
(B(n-1,x-1+1,y)⊕B(n-1,x+1,y)⊕B(n-1,x+1+1,y)⊕B(n-2,x+1,y)) ⊕
(B(n-1,x-1,y-1)⊕B(n-1,x,y-1)⊕B(n-1,x+1,y-1)⊕B(n-2,x,y-1)) ⊕
(B(n-1,x-1,y+1)⊕B(n-1,x,y+1)⊕B(n-1,x+1,y+1)⊕B(n-2,x,y+1))
重新排列顺序（也就是生成矩阵章节将y和n掉换），得到：
(B(n-1,x-1-1,y)⊕B(n-1,x-1+1,y)⊕B(n-1,x-1,y-1)⊕B(n-1,x-1,y+1)) ⊕
(B(n-1,x-1,y)⊕B(n-1,x+1,y)⊕B(n-1,x,y-1)⊕B(n-1,x,y+1)) ⊕
(B(n-1,x+1-1,y)⊕B(n-1,x+1+1,y)⊕B(n-1,x+1,y-1)⊕B(n-1,x+1,y+1)) ⊕
(B(n-2,x-1,y)⊕B(n-2,x+1,y))⊕B(n-2,x,y-1)⊕B(n-2,x,y+1))
不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此式子可以化为：
0⊕0⊕0⊕0=0。

因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出下面的行：
B(x,y)=B(x-1,y-1)⊕B(x-1,y+1)⊕B(x-2,y)
通过这种方法，我们无需对每个y都生成矩阵B，只需计算这些B矩阵的第一行，得到B(n)的第一行，即可求得完整的矩阵B(n)。

——————————————————————

对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。

在讲O(n^2)的算法之前，需要介绍一个非常重要的矩阵F/多项式f(x)
这个矩阵F满足特性：F(y,x)=F(y-1,x-1)⊕F(y-2,x)
对应多项式f(x)就是之前提到的OEIS中的Fibonacci多项式：
f(n, x)=x · f(n-1, x) + f(n-2, x)
这个多项式是这个算法的核心，之后会多次用到。
f(n,x)就是χ(x)
F={f(0),f(1)...f(n-1)}

为了实现这个算法，我们需要把B(n)拆分成多项式p(H)
也就是：B=p(H):=p0​I⊕p1​H⊕p2​H2⊕⋯.
从而通过这个式子求X：
BX=Y⟺p(H)X=Y.

刚才提到的多项式f(x)和矩阵邻接矩阵H有关。
向量乘以这个多项式的第n行相当于对向量乘以H^n（往两边扩散）。：
f(n,H)*v=H^n*v




我理解：

b 100010

b	F
1	1
0	01
0	101
0	0001
1	10101
0	010001
0	1000101

p=1 + 10101= 001010

下面的表达对不对？以下四个式子之间的关系是什么？如何互相推导？

1. 多项式f(x)和矩阵邻接矩阵H有关，满足：
f(n, x)=x · f(n-1, x) + f(n-2, x)
F(y,x)=F(y-1,x-1)⊕F(y-2,x)
这里的矩阵F就是把每一个多项式f(n)的系数提取出来，写在第n行。

2. 向量乘以多项式的第n行相当于对向量乘以H^n（往两边扩散）。：
f(n,H)*v=H^n*v

3. 算法里p=B(n) * F，这里B(n)=b是矩阵第一行
p=b * F，这里b和p是行向量，F是刚才的矩阵。

4. 我们有数学公式：B(n)=p(H):=p0​I⊕p1​H⊕p2​H2⊕⋯.
第一行就是：b=p=p01*f(0)+p1*f(1)+p2*f(2)=p*F

