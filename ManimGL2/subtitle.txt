00:00:29.233 在上集视频的《首行叠加法》中，有小伙伴对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。
00:00:40.433 我们用B代表按钮，L代表灯，⊕（加）代表叠加，¬（非）代表翻转。
00:00:47.533 n代表从上到下第n行按钮或灯。因为我们是一行行进行推导的，n也代表第n次推导。
00:00:57.233 x代表从左到右第x列按钮。我们将灯表示为第一行的某几个列的按钮的叠加。这里的x不局限于第一行。
00:01:08.933 y代表从左到右第y列灯。这里的公式对任意第y个灯都满足，所以省去了y。
00:01:18.733 在这里，粉色原点是用按钮表示按钮，淡蓝色方块是用按钮表示灯。
00:01:26.533 而在上集视频中，因为最终目标是将灯用按钮表示，因此省去了按钮表示按钮，粉色原点直接是按钮表示灯。
00:01:36.933 让我们举一个具体的例子。在5×5的格子中，我们将按钮和灯编号为1—25。
00:01:45.133 在《叠加法》中，我们将灯表示为所有按钮的叠加。例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
00:01:58.567 通过这种方法，我们得到了25个未知数的一次方程组。我们将其写成增广矩阵，也就是按钮矩阵和翻转向量，即灯向量的形式。
00:02:11.767 而在《首行叠加法》中，我们需要把灯表示为第一行按钮的叠加。
00:02:18.200 这里的五个矩阵，分别代表第y列是由第一行的哪几个按钮叠加的。
00:02:24.800 由于按法是动态的，当第二行按钮还未被按下时，L1=B1⊕B2，即第一个灯L1是由第一行的第一、第二个按钮B1,B2叠加的。
00:02:38.000 然后，B6=¬L1=¬(B1⊕B2)，即第六个按钮B6是第一个灯L1的翻转。因此，第二行按钮B6和第一行灯L1的叠加状态是相同的。
00:02:52.700 只不过B6是L1的翻转。而旁边的翻转向量，代表的就是按钮或灯有没有翻转。
00:03:02.100 例如，当第一个向量的第一个灯L1亮起时，表示L1除了由刚才说的按钮叠加外，还需要翻转才是正确的状态。
00:03:12.700 同理，B7=¬L2=¬(B1⊕B2⊕B3)，即第七个按钮B7是第二个灯L2的翻转。同样，第二行的按钮B7和第一行灯L2的叠加状态是相同的。
00:03:28.400 这里，我们将第一个按钮B1的状态补全，将B1用第一行的按钮叠加时，有B1=B1。
00:03:37.300 接下来我们来看第六个灯。L6=B1⊕B6⊕B7=B1⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)=B1⊕B3。
00:03:50.100 又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕¬(B1⊕B2)⊕¬(B1⊕B2⊕B3)⊕¬(B2⊕B3⊕B4)=¬B4。
00:04:03.700 这样不断递推，我们可以将任意L表示为B1—B5的叠加。加上翻转后，得到完整的矩阵。
00:04:14.700 现在，如果我们把序号1—25用坐标x,y表示，则按钮和灯可写为以上公式。让我们以L7(2)=L(2,2,2)为例。
00:04:28.167 这里，我们的矩阵同时满足另一个性质，让我们称之为十字偶校验约束。
00:04:35.267 某个元素的左右两个矩阵的对应位置的元素，和元素所在矩阵左右两个元素的叠加后为零。
00:04:43.667 这也就是上集视频中《优化生成矩阵》章节中的性质，之后会给出证明。
00:04:51.467 通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。
00:05:00.467 因此，我们可以在公式中去除y。于是，灯可以表示为当前矩阵的上左中右的按钮的叠加。
00:05:09.867 又因为，后一行的按钮是前一行灯的翻转，而后一行的灯是上左中右的灯的翻转的叠加。
00:05:19.567 因此，如果把翻转¬提取出来，便有了一开始的推导公式。
00:05:25.667 也就是，按钮是前一行的左中右的按钮和上上行的按钮的叠加。以及，灯是前一行的左中右的按钮和上上行的灯的叠加。
00:05:37.567 可以注意到，按钮和灯的递推公式具有相同的形式，这是因为前一行灯就是后一行按钮。
00:05:46.667 因为最终需要推导的是灯，因此灯是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮也是5行。
00:05:57.867 对于翻转的情况，则可以单独列出来，以类似的方法推导，写成公式Y。
00:06:04.967 即后一行的翻转是前一行左中右和上上行叠加后的翻转。
00:06:11.567 可以注意到，这里的公式Y和公式B的推导公式是类似的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号¬。
00:06:23.667 1. 使用零向量：第一次翻转发生在从一到二行的推导过程中，在此之前没有发生过翻转，因此Y的第一行是全零。
00:06:35.767 2. 翻转符号¬必须存在：每次推导都需要翻转，因此不可省略。而前者将这个翻转取出来了，因此不用翻转符号¬。
00:06:48.367 3. 不使用x而使用y：翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
00:07:02.000 事实上，按钮矩阵也可以用另一种更直观的方法推得。
00:07:08.100 首先，在第一个矩阵中，我们点击第一行第一个按钮。然后，点击第二行的按钮，尽量消去第一行的灯。
00:07:18.100 接着按第三行按钮，消去第二行的灯。不断递推，直到最后一行。
00:07:25.500 最终，最后一行按钮和灯的状态，和前面推得的矩阵是一样的。
00:07:32.700 同样，在第二个矩阵点击第一行第二个按钮，然后递推，也可以得到第二个矩阵最后一行按钮和灯的状态。
00:07:42.900 通过这个方法，我们可以得到所有矩阵最后一行的状态。
00:07:50.333 另外，翻转向量也可以用相似的方法推得。
00:07:55.433 我们把所有灯全部点亮，然后用刚才的方法尝试把所有灯消去，同样可以得到翻转向量最后一行的状态。
00:08:05.467 我们把这种方法称作余数矩阵法，和首行叠加法的原理本质上是相同的，有兴趣的小伙伴可以自行证明。
00:08:19.467 在《生成优化矩阵》章节中，我们将矩阵的行重排。其实是调换了n和y的位置，使原来从左到右的第y个矩阵变为了第n个矩阵。
00:08:32.900 这n个矩阵都满足十字偶校验约束，即上下左右四个格子叠加为零，因此这里的公式省去了n。
00:08:42.800 这里和之前的情况是一样的，只不过n和y调换了，因此位置发生了变化。
00:08:50.600 这是一个十分重要的性质。使用这个性质，可以由第一个灯直接推导后面的灯。
00:08:58.200 在之后的O(n²)算法中，其本质也是用这个性质进行的优化。
00:09:05.300 下面让我们用数学归纳法，证明这个性质。
00:09:10.400 由于右边的按钮矩阵就是左边的灯矩阵，为了方便，我们就只看按钮矩阵。
00:09:18.600 首先，我们假定前两个矩阵B(n-1)和B(n-2)满足这个性质，现在来证明B(n)也满足这个性质。
00:09:29.300 将刚才的矩阵递推关系加上参数y并重写。
00:09:34.700 对于B(n)，我们将式子竖着写成四项，然后将递推关系代入这个式子。
00:09:41.900 代入后的式子包含16项。现在重新排列项目顺序，将y和n调换，类似《优化生成矩阵》章节中的调换操作。
00:09:53.500 不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此整个式子化为了零。
00:10:08.000 现在，我们只需要证明最左边的两个矩阵也满足这个性质即可。第一个矩阵是单位矩阵，显然满足这个性质。
00:10:18.600 第二个矩阵可以表示为左边两个矩阵的叠加。由于单位矩阵左边没有矩阵，因此相当于叠加了一个零矩阵。
00:10:28.700 由于零矩阵显然满足这个性质，因此第二个矩阵也满足这个性质。
00:10:35.800 因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出后续的行，求得完整的矩阵B(n)。
00:10:49.300 为了实现O(n²)的算法，我们也需要用到类似的方法，尽量不去对整个矩阵进行操作，而是通过第一行来求逆或求解。
00:11:01.367 我们以n=7为例。这里的B就是前面提到的按钮矩阵B(n)，而y就是翻转向量的最后一行，即B(n)的增广向量。
00:11:13.733 我们的目标是：对于Bx=y，在已知B的第一行和y的情况下求x。
00:11:22.667 如果将n在不同情况下的B的第一行写在一起，矩阵长这样，记为B'。
00:11:29.900 注意，这里的B'矩阵不是刚才说的当n确定时的完整的矩阵B，而是B(n)的第一行拼接起来的结果。
00:11:40.100 另外，这里从n=0开始一共递推n次，最后一个1不包含在矩阵B的第一行内。例如n=7时，第一行为1011011，最后一个1省去。
