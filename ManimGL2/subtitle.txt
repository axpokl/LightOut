00:00:00.000 有了b*F=p之后，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
00:00:02.600 这是因为我们已经将问题从BX=Y转为了p(H)=Y。由此，在前面说到的生成矩阵也只需要计算第一行b。
00:00:05.200 由于在不同n的情况下计算b的方式是一样的，我们可以把n-1情况下算出的b，直接用于计算n的情况。
00:00:09.000 这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
00:00:11.600 同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
00:00:14.200 如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
00:00:18.000 为了求出p=b*F，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
00:00:20.600 因为矩阵F是有递推规律的，理论上使用FFT等算法，可以把乘法优化到O(n*log(n))。
00:00:23.200 现在我们已求得了p，并将原始问题转换为了p(H)X=Y。那这又有什么用呢？
00:00:25.800 试想一下，如果有一个多项式q(x)，满足q(x)*p(x)=1 mod f(x)。
00:00:28.700 这里的f(x)就是前面提到的多项式f(n,x)。那么，将原始两边同时乘以q(H)，便有：X=q(H)*Y。
00:00:31.600 这样，我们就能立刻求出X。
00:00:34.200 让我把这样的多项式q(x)我们称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？
00:00:36.800 这里，我们同样将q(x)的系数写为向量q，然后扩展欧几里得算法来求取q：
00:00:39.400 我们使用辗转相减法，将p(x)右移，使最高系数对齐，然后叠加到f(x)上。
00:00:42.000 如果叠加后的f(x)的最高次数小于p(x)，则将f(x)和p(x)互换，然后再次进行操作。
00:00:44.600 同时，我们定义一个单位多项式e(x)和零多项式o(x)，在对f(x)和p(x)操作的时候对e(x)和o(x)做同样操作。
00:00:47.200 重复这样操作。最终f(x)会被叠加到零，而剩下的p(x)则为两个多项式的最大公因子，记为g(x)。
00:00:49.800 同时，最后剩下的o(x)则是p(x)的逆，也就是q(x)。
00:00:52.400 将q(x)写成矩阵Q。注意，这里的矩阵不是后面提到的完整的逆矩阵Q，而是多个q(x)拼接起来。
