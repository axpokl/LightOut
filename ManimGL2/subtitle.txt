00:00:01.400 对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。
00:00:04.600 这里，让我以我们以n=7为例。这里的B就是前面提到的按钮矩阵B，而Y就是翻转矩阵Y的最后一行。
00:00:07.800 我们的目标是，对于BX=Y，在已知B的第一行和Y的情况下求X。
00:00:12.500 如果将n在不同情况下B的第一行写在一起，这样的B矩阵长这样。
00:00:16.600 注意，这里的B矩阵不是刚才说的当n确定时的完整的B矩阵，而是B(n)的第一行拼接起来。
00:00:19.800 另外，这里从n=0开始一共递推n次，第n列的1不包含在B矩阵的第一行内。例如n=5时，第一行为01101，最后一个1省去。
00:00:24.100 把Y的第一行写在一起是这样的。
00:00:28.500 为了实现这个目标，我们需要首先将B进行分解。这里，让我首先介绍一个非常重要的矩阵H。
00:00:30.000 对于H的每一个元素，如果x和y的差为一则为一，否则为零。
00:00:32.600 如果将向量v乘以该矩阵，等同于将向量v的每个元素向左右扩散后叠加。
00:00:39.700 这是因为矩阵的对应行就是向量每个元素左右扩散的结果。
00:00:44.100 如果将多个H相乘，也就是H^n，则其首行H^n(0)从单位矩阵n=0开始，看起来像是这样的。
00:00:47.300 我们把这个下三角矩阵记为K，即Krylov矩阵或扩散基矩阵。也就是说，对于K的第n行，有K(n)=H^n(0)。
00:00:50.200 这里下一行是上一行乘以H，也就是上一行左右扩散的叠加。因此对于K的每个元素，有以上公式。
00:00:55.500 不难发现，《首行叠加法》中的各个B矩阵，可以使用H表示为以上公式。
00:00:57.300 例如，B(0)=H^0，B(1)=H^0+H^1，B(2)=H^2
00:01:00.800 将其系数用多项式c(n,x)表达，则有和B矩阵类似的表达式。同时，将系数c写成矩阵的形式，记为C。
00:01:04.900 注意，这里的乘以H的操作在系数上代表右移而不是左右扩散，因此表达式中只有x-1而没有x+1。
00:01:07.500 这个C矩阵和后面提到的F矩阵息息相关。
00:01:11.900 现在，定义多项式p(x)。我们的目标是把B拆分成H^n。
00:01:14.800 将矩阵H代入多项式p(x)，得到p(H)，并用其表示矩阵B。
00:01:17.700 这样，原始求X的问题就变为了p(H)X=Y。
00:01:20.600 现在，我们需要把多项式p(H)的系数计算出来。这个系数构成的向量我们记为p。
00:01:23.500 为了简化运算，我们只关心矩阵第一行B(0)，记为b。根据刚才的定义，我们可以得到b=p*K。
00:01:27.900 为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1。为了方便我们记为F，又称反Krylov矩阵或解耦矩阵。
00:01:31.700 这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵F也满足类似的性质。
00:01:34.900 有兴趣的小伙伴可以试着证明一下，使用这两个性质构造的矩阵K和F，然后证明互为逆矩阵。
00:01:39.300 于是，我们便有：b*F=p*K*F=p。这样我们便求出了p。
00:01:51.500 将多项式p(x)写成矩阵的形式，记为P。
00:01:55.600 这里说明一下，矩阵F的每行对应多项式f(n,x)，也就是上一集视频《解的数量》章节中提到的OEIS中的Fibonacci多项式。
00:01:58.500 此外，刚才递推得到的C矩阵对应多项式c(n,x)，其实也就是这里提到的f(n,x+1)。
00:02:01.400 这是因为B(n)矩阵也可以写为以上形式。这里的H⊕I等价于x+1。
00:02:04.300 同时，上一集视频提到的公式r'(n)，可以表示为多项式f和c的最大公因子的最高次幂。
00:02:05.200 这里，gcd表示最大公因子，我们将其记为多项式g(x)。
00:02:08.100 deg表示最高次幂，其等价于矩阵B丢失的秩，也就是n-r。这个g(x)和n-r在后续算法中也会提到。
00:02:10.700 可以发现，如果B是可逆的，则g(x)=1，n=r，r’=0。否则，r'的值决定了解的数量，即2^r'。
00:02:14.800 将g(x)写成矩阵的形式，记为G。
00:02:19.800 有了b*F=p之后，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
00:02:22.400 这是因为我们已经将问题从BX=Y转为了p(H)=Y。由此，在前面说到的生成矩阵也只需要计算第一行b。
00:02:25.000 由于在不同n的情况下计算b的方式是一样的，我们可以把n-1情况下算出的b，直接用于计算n的情况。
00:02:28.800 这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
00:02:31.400 同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
00:02:34.000 如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
00:02:37.800 为了求出p=b*F，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
00:02:48.300 因为矩阵F是有递推规律的，理论上使用FFT等算法，可以把乘法优化到O(n*log(n))。
00:02:53.900 现在我们已求得了p，并将原始问题转换为了p(H)X=Y。那这又有什么用呢？
00:02:57.100 试想一下，如果有一个多项式q(x)，满足q(x)*p(x)=1 mod f(x)。
00:03:00.000 这里的f(x)就是前面提到的多项式f(n,x)。那么，将原始两边同时乘以q(H)，便有：X=q(H)*Y。
00:03:02.900 这样，我们就能立刻求出X。
00:03:12.600 让我把这样的多项式q(x)我们称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？
00:03:15.200 这里，我们同样将q(x)的系数写为向量q，然后扩展欧几里得算法来求取q：
00:03:17.800 我们使用辗转相减法，将p(x)右移，使最高系数对齐，然后叠加到f(x)上。
00:03:20.400 如果叠加后的f(x)的最高次数小于p(x)，则将f(x)和p(x)互换，然后再次进行操作。
00:03:23.000 同时，我们定义一个单位多项式e(x)和零多项式o(x)，在对f(x)和p(x)操作的时候对e(x)和o(x)做同样操作。
00:03:25.600 重复这样操作。最终f(x)会被叠加到零，而剩下的p(x)则为两个多项式的最大公因子，记为g(x)。
00:03:28.200 同时，最后剩下的o(x)则是p(x)的逆，也就是q(x)。
00:03:30.800 将q(x)写成矩阵Q。注意，这里的矩阵不是后面提到的完整的逆矩阵Q，而是多个q(x)拼接起来。
00:03:35.200 这里，由于我们已求得q(x)。我们也可以利用这个式子来求X。
00:03:37.800 这里，我们可以从Y开始，不断将其和H相乘，使用左右扩散的办法计算下一个H^n*Y，然后和qn叠加，得到X。
00:03:40.400 通过这个办法，我们也可以在O(n^2)中求得X。
00:03:43.000 事实上，q(x)的系数也就是B的逆矩阵Q的第一行，并且可以证明B的逆矩阵Q也满足十字偶校验约束。
00:03:45.600 因此，可以通过递推公式，用逆矩阵第一行q(x)直接求出整个逆矩阵Q，然后再和Y相乘获得X。
00:03:48.200 不过，这整个求解的过程有一个问题，就是我们假设满足q(x)p(x)=1 mod f(x)的多项式q(x)存在。
00:03:50.800 如果矩阵B不可逆呢？例如当n=5的时候，g(x)不为1，q(x)不是p(x)的逆。或者说，满足q(x)p(x)=1 mod f(x)的q(x)不存在。
00:03:53.400 这种情况下，求得的q(x)和Q'不同，并且也不满足q(x)p(x)=1 mod f(x)。并且Q'也不满足十字偶校验约束，因此无法通过公式递推再相乘求解X。
00:03:56.000 n=5时的伪逆矩阵Q'和消元后的E'矩阵是这样的。
00:03:59.500 可以证明，Q'和E'具有这样的形式
00:04:02.100 这里，矩阵B的秩为r，例如n=5时r=3，并以rxr为界将矩阵分为四块。
00:04:04.700 B矩阵左上角rxr的子矩阵Br满秩，并且B的Q'的左上角rxr子矩阵Qr伪Br的逆。
00:04:07.300 Q'左下角和E'右上角的静默操作相同，并且其值等于Ur乘以Qr。
00:04:09.900 矩阵Q'和E'一定具有这样的形式。利用分块矩阵乘法，可以很容易证明这两个性质。有兴趣的观众可以自行证明。
00:04:12.500 可以发现，这里的q(x)并不是Q'的第一行，并且求得的X也不是原方程的解。
00:04:15.100 不难注意到，只有当矩阵B为可逆矩阵时，g(x)=1，并且g(x)的最高次幂为n-r=r'。那么对于不可逆的矩阵B，我们又有什么解决办法呢？
