00:00:00.000 现在，定义多项式p(x)。我们的目标是把B拆分成H^n。
00:00:02.900 将矩阵H代入多项式p(x)，得到p(H)，并用其表示矩阵B。
00:00:05.800 这样，原始求x的问题就变为了p(H)x=y。
00:00:08.700 现在，我们需要把多项式p(H)的系数计算出来。这个系数构成的向量我们记为p。
00:00:11.600 为了简化运算，我们只关心矩阵第一行B(0)，记为b。根据刚才的定义，我们可以得到b=K*p。
00:00:25.267 为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1。为了方便我们记为F，又称反Krylov矩阵或解耦矩阵。
00:00:29.067 这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵F也满足类似的性质。
00:00:35.967 有兴趣的小伙伴可以试着证明一下，使用这两个性质构造的矩阵K和F，证明S=K*F为单位矩阵I。
00:00:38.567 提示：矩阵S=K*F满足十字偶校验约束，因此有以上递推公式。
00:00:43.267 这里说明一下，矩阵F的每行对应多项式f(n,x)，也就是上一集视频《解的数量》章节中提到的OEIS中的Fibonacci多项式。
00:00:46.767 此外，刚才递推得到的C矩阵对应多项式c(n,x)，其实也就是这里提到的f(n,x+1)。
00:00:48.267 这个证明也不难，大家可以使用公式求出F和C的递推公式，或者由递推公式反推。
00:00:50.867 同时，B(n)矩阵也可以表示为以上形式。这里的H⊕I等价于x+1。
00:00:55.567 让我们继续求p。由于F和K互逆，我们有：F*b=F*K*p=p。这样我们便求出了p。
00:00:59.867 这里，为了和视频演示一致，由于b是竖着的，写为p=F*b，省去了转置符号。对于矩阵乘法运算来说，则有P=B''*F。
00:01:08.900 将多项式p(x)写成矩阵的形式，记为P。
00:01:13.300 有了b*F=p之后，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
00:01:22.233 这是因为我们已经将问题从Bx=y转为了p(H)=y。由此，在前面说到的生成矩阵也只需要计算第一行b。
00:01:28.133 由于在不同n的情况下计算b的方式是一样的，我们可以把n-1情况下算出的b，直接用于计算n的情况。
00:01:31.567 这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
00:01:35.967 同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
00:01:42.067 如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
00:01:45.867 为了求出p=F*b，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
00:01:53.400 因为矩阵F是有递推规律的，理论上使用FFT等算法，可以把乘法优化到O(n*log(n))。
00:01:56.100 事实上，这里计算p的时候，我们将B''的对角线去除了，有P=B''*F。假如我们保留B''的对角线，则有C=B'*F。
00:02:03.900 为了证明这一点，我们假定B'*F=C'，得出以上递推公式。由于C'的递推公式和C是相同的，因此这里的C'就是C，即C'=C=B'*F。
00:02:06.800 由于C=B'*F，因此P=C⊕F。我们可以用递推公式计算出C，和F叠加直接求得P，无需使用矩阵乘法。
00:02:09.700 同时，由于P=C⊕F，因此P也可以写成这个递推公式，从而无需B，C或F，直接在O(n)的时间内，由P自己推得。
00:02:13.500 现在，我们已求得了p，并将原始问题转换为了p(H)x=y。那这又有什么用呢？
