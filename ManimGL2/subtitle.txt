00:00:03.100 在上集视频的《首行叠加法》中，有观众对按钮和灯的递推仍有疑问。这次我们来讲清楚，这个递推公式是怎么来的。
00:00:08.300 我们用B代表按钮，L代表灯，⊕（加）代表叠加，~（非）代表翻转。
00:00:13.400 n代表从上到下第n行灯或按钮。因为我们是一行行进行推导的，n也代表第n次推导。
00:00:18.600 x代表从左到右第x列按钮。将灯表示为第一行的某几个列的按钮的叠加。这里的x不局限于第一行。
00:00:23.800 y代表从左到右第y列灯。这里的公式对任意第y个灯都满足，所以省去了y。
00:00:29.000 在这里，粉色原点是用按钮表示按钮，淡蓝色方块是用按钮表示灯。
00:00:36.800 而在上集视频中，因为最终目标是将灯用按钮表示，因此省去了按钮表示按钮，粉色原点直接为按钮表示灯。
00:00:44.100 让我们举一个具体的例子。在5x5的格子中，我们将灯和按钮编号为1-25。
00:00:47.300 在《叠加法》中，我们将灯表示为所有按钮的叠加。例如：L1=B1⊕B2⊕B6，L6=B1⊕B6⊕B7⊕B11。
00:01:00.033 通过这种方式我们得到了25元一次方程组。写成增广矩阵，也就是按钮矩阵加灯向量的形式。
00:01:08.133 而在《首行叠加法》中，我们需要把灯表示为第一行按钮的叠加。
00:01:11.567 这里的五个矩阵，分别代表第y列是由第一行的哪几个按钮叠加的。
00:01:16.167 由于按法是动态的，当第二行按钮还未被按下时，L1=B1⊕B2，即第一个灯L1由第一行的一、二个按钮，即B1,B2叠加的。
00:01:21.367 然后，B6=~L1=~(B1⊕B2)，即第六个按钮B6是第一个灯L1的翻转。因此，第二行按钮B6和第一行灯L1的叠加状态是相同的。
00:01:26.567 旁边的向量，代表的是按钮或灯有没有翻转。
00:01:31.467 例如，当第一个向量的第一个灯亮起时，表示第一个灯除了由刚才说的按钮叠加外，还需要再翻转才是正确的状态。
00:01:36.067 同理，B7=~L2=~(B1⊕B2⊕B3)，即第七个按钮B6是第二个灯L2的翻转。同样，第二行的按钮B7和第一行灯L2的叠加状态是相同的。
00:01:42.767 这里，我们将第一个按钮B1的状态补全，将B1用第一行的按钮叠加时，有B1=B1。
00:01:47.667 接下来我们来看第六个灯。L6=B1⊕B6⊕B7=B1⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)=B1⊕B3。
00:01:58.467 又比如，L7=B2⊕B6⊕B7⊕B8=B2⊕~(B1⊕B2)⊕~(B1⊕B2⊕B3)⊕~(B2⊕B3⊕B4)=~B4
00:02:15.567 这样不断递推，我们可以将任意L表示为某些B1到B5的叠加，再加上翻转。
00:02:24.967 现在，如果我们把序号1-25用坐标x,y表示，则灯和按钮矩阵可写为上述公式。让我们以L7(2)=L(2,2,2)为例。
00:02:31.433 这里，我们的矩阵同时满足另一个性质，称之为十字偶校验约束。
00:02:35.533 某个元素的左右两个矩阵的对应位置的元素，和元素所在矩阵左右两个元素的叠加后为零。
00:02:38.933 这就是之前视频中，《优化生成矩阵》章节中的性质，后面我会给予证明。
00:02:42.733 通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。
00:02:53.733 因此，我们可以在公式中去除y。去除y后，灯可以表示为当前矩阵的上左中右的按钮的叠加。
00:02:59.133 又因为，下一行的按钮是当前灯的翻转。
00:03:02.533 以及，下一行的灯是上左中右的灯的翻转的叠加。
00:03:05.433 如果把翻转~提取出来，便有了一开始的推导公式。
00:03:08.033 也就是，按钮是上一行的左中右按钮和上上行的按钮的叠加。
00:03:11.433 以及，灯是上一行的左中右按钮和上上行的灯的叠加。
00:03:18.033 可以注意到，按钮和灯的递推公式具有相同的形式，这是因为上一行灯就是下一行按钮。
00:03:20.633 因为最终需要推导的是灯矩阵，因此灯矩阵是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮矩阵也是5行。
00:03:25.833 对于翻转的情况，则可以单独列出来，以类似的方法推导，写成公式Y。
00:03:28.733 下一行的翻转是上一行左中右和上上行叠加后的翻转。
00:03:32.533 可以注意到，这里的公式Y和公式B的推导公式是类似的的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号~。
00:03:35.133 1. 使用零向量：第一次翻转发生在从一到二行的推导过程中，在此之前没有发生过翻转，因此Y的第一行是全零。
00:03:39.233 2. 翻转符号~必须存在：每次推导都需要翻转，因此不可省略。而前者将这个翻转取出来了，因此不用翻转符号~。
00:03:41.833 3. 不使用x而使用y：翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
00:03:49.467 事实上，按钮矩阵也可以用另一种更直观的方法推得。
00:03:52.067 首先，我们点击第一行的第一个按钮。然后，点击第二行的按钮，尽可能消去第一行的灯。
00:03:59.067 接着按第三行按钮，不断递推，直到最后一行。
00:04:06.467 那么，最后一行灯的状态，就是按钮矩阵的第一行。
00:04:09.667 同理，点击第二个按钮，然后递推。则最后一行灯就是按钮矩阵第二行。
00:04:15.867 通过这个方法，我们也得到整个按钮矩阵。
00:04:23.300 另外，灯向量也可以用相似的方法推得。
00:04:25.900 我们把所有灯全部点亮，然后用刚才的方法尝试把所有灯消去，最后一行灯的状态就是灯向量。
00:04:35.933 我们把这种方法称作余数矩阵法，和首行叠加法的原理本质上是相同的，有兴趣的观众小伙伴可以自行证明。
00:04:42.333 在《生成优化矩阵》章节中，我将矩阵的行重排。其实是调换了n和y的位置，使原来从左到右的第y个矩阵变为了第n个矩阵。
00:04:53.767 这n个矩阵都满足十字偶校验约束，即上下左右四个格子叠加为零，因此这里的公式省去了n。
00:04:56.667 这里和之前的情况是一样的，只不过n和y调换了，因此位置发生了变化。
00:05:00.467 这是一个十分重要的性质。通过这个性质，可以由第一个灯直接推导后面的灯。
00:05:03.067 在后面会说的O(n^2)算法中，其本质也是利用这个性质进行的优化。
00:05:05.667 下面让我用数学归纳法，证明这个性质。
00:05:08.267 由于右边的按钮矩阵就是左边的灯矩阵，为了方便，我们就只看按钮矩阵。
00:05:11.467 首先，我们假定前两个矩阵B(n-1)和B(n-2)满足这个性质，现在来证明则B(n)也满足这个性质。
00:05:15.167 将刚才的矩阵递推关系加上参数y并重写。
00:05:19.567 对于B(n)，我们将式子竖着写成四项，然后将递推关系代入这个式子。
00:05:25.767 代入后的式子包含16个项目。现在重新排列项目顺序，将y和n调换，类似《优化生成矩阵》章节中的调换操作。
00:05:37.367 不难发现，这四项属于B(n-1)或B(n-2)，并且元素之间的关系满足十字偶校验约束，因此整个式子化为了零。
00:05:46.867 现在，我们只需要证明最左边两个矩阵也满足这个性质即可。第一个矩阵是单位矩阵，显然满足这个性质。
00:05:54.467 第二个矩阵可以表示为左边两个矩阵的叠加。由于单位矩阵左边没有矩阵，因此相当于叠加了一个零矩阵。
00:05:58.567 由于零矩阵显然满足这个性质，因此第二个矩阵也满足这个性质。
00:06:02.667 因为B(n)有了这个性质，我们只需要知道B(n)的第一行，就能通过公式推导出下面的行，求得完整的矩阵B(n)。
00:06:12.567 对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。
00:06:15.767 这里，让我以我们以n=7为例。这里的B就是前面提到的按钮矩阵B，而y就是翻转矩阵Y的最后一行。
00:06:19.267 我们的目标是，对于Bx=y，在已知B的第一行和y的情况下求x。
00:06:30.000 如果将n在不同情况下B的第一行写在一起，这样的矩阵长这样，我们记为B'。
00:06:35.500 注意，这里的B'矩阵不是刚才说的当n确定时的完整的B矩阵，而是B(n)的第一行拼接起来。
00:06:38.700 另外，这里从n=0开始一共递推n次，最后一个1不包含在B矩阵的第一行内。例如n=7时，第一行为1011011，最后一个1省去。
00:06:40.700 改写后的矩阵记为B''=B'⊕I
00:06:44.800 把Y的第一行写在一起是这样的，记作Y'。
00:06:49.500 合并在一起后的Y'有上述递推公式。
00:06:53.600 为了实现这个目标，我们需要首先将B进行分解。这里，让我首先介绍一个非常重要的矩阵H，称为邻接矩阵。
00:06:55.400 对于H的每一个元素，如果x和y的差为一则为一，否则为零。
00:06:58.000 如果将向量v乘以该矩阵，等同于将向量v的每个元素向左右扩散后叠加。
00:07:03.833 这是因为矩阵的对应行就是向量每个元素左右扩散的结果。
00:07:08.533 不难发现，《首行叠加法》中的各个B矩阵，可以使用H表示为以上公式。
00:07:10.333 例如，B(0)=H^0，B(1)=H^0+H^1，B(2)=H^2
00:07:13.833 将其系数用多项式c(n,x)表达，则有和B矩阵类似的表达式。同时，将系数c写成矩阵的形式，记为C。
00:07:18.233 注意，这里的乘以H的操作在系数上代表右移而不是左右扩散，因此表达式中只有x-1而没有x+1。
00:07:20.833 这个C矩阵和后面提到的F矩阵息息相关。
00:07:25.533 现在，如果我们将多个H相乘，也就是H^n，则其首行H^n(0)从单位矩阵n=0开始，看起来像是这样的。
00:07:29.033 我们把这个下三角矩阵记为K，即Krylov矩阵或扩散基矩阵。也就是说，对于K的第n行，有K(n)=H^n(0)。
00:07:31.933 这里下一行是上一行乘以H，也就是上一行左右扩散的叠加。因此对于K的每个元素，有上述递推公式。
00:07:37.533 现在，定义多项式p(x)。我们的目标是把B拆分成H^n。
00:07:40.433 将矩阵H代入多项式p(x)，得到p(H)，并用其表示矩阵B。
00:07:43.333 这样，原始求x的问题就变为了p(H)x=y。
00:07:46.233 现在，我们需要把多项式p(H)的系数计算出来。这个系数构成的向量我们记为p。
00:07:49.133 为了简化运算，我们只关心矩阵第一行B(0)，记为b。根据刚才的定义，我们可以得到b=K*p。
00:08:03.000 为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1。为了方便我们记为F，又称反Krylov矩阵或解耦矩阵。
00:08:07.100 这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵F也满足类似的性质。
00:08:16.400 有兴趣的小伙伴可以试着证明一下，使用这两个性质构造的矩阵K和F，证明S=K*F为单位矩阵I。
00:08:19.000 提示：矩阵S=K*F满足十字偶校验约束，因此有以上递推公式。
00:08:23.700 这里说明一下，矩阵F的每行对应多项式f(n,x)，也就是上一集视频《解的数量》章节中提到的OEIS中的Fibonacci多项式。
00:08:27.500 此外，刚才递推得到的C矩阵对应多项式c(n,x)，其实也就是这里提到的f(n,x+1)。
00:08:29.000 这个证明也不难，大家可以使用公式求出F和C的递推公式，或者由递推公式反推。
00:08:31.600 同时，B(n)矩阵也可以表示为以上形式。这里的H⊕I等价于x+1。
00:08:36.900 让我们继续求p。由于F和K互逆，我们有：F*b=F*K*p=p。这样我们便求出了p。
00:08:41.500 这里，为了和视频演示一致，由于b是竖着的，写为p=F*b，省去了转置符号。对于矩阵乘法运算来说，则有P=B''*F。
00:08:50.233 将多项式p(x)写成矩阵的形式，记为P。
00:08:54.933 有了F*b=p之后，后续的计算我们都不需要用到完整的B，而只需要这个第一行b。
00:09:03.567 这是因为我们已经将问题从Bx=y转为了p(H)=y。由此，在前面说到的生成矩阵也只需要计算第一行b。
00:09:09.467 由于在不同n的情况下计算b的方式是一样的，我们可以把n-1情况下算出的b，直接用于计算n的情况。
00:09:13.200 这样，如果我们是从n=0开始计算的，我们只需要O(n)的时间复杂度便可求出b。
00:09:17.900 同样，计算K和F也是如此。因为每行之间有递推公式，如果从n=0开始计算，也可以在O(n)时间内求出。
00:09:24.900 如果需要直接计算特定n，可以用别的方式优化到O(n*log(n))。因为这里的算法不涉及这个优化，因此不再赘述。
00:09:29.000 为了求出p=F*b，我们需要将向量和矩阵相乘，一般情况下时间复杂度是O(n^2)。
00:09:36.533 因为矩阵F是有递推规律的，理论上使用FFT等算法，可以把乘法优化到O(n*log(n))。
00:09:39.233 事实上，这里计算p的时候，我们将B''的对角线去除了，有P=B''*F。假如我们保留B''的对角线，则有C=B'*F。
00:09:48.233 为了证明这一点，我们假定B'*F=C'，得出以上递推公式。由于C'的递推公式和C是相同的，因此这里的C'就是C，即C'=C=B'*F。
00:09:53.933 由于C=B'*F，因此P=C⊕F。我们可以用递推公式计算出C，和F叠加直接求得P，无需使用矩阵乘法。
00:09:56.833 同时，由于P=C⊕F，因此P也可以写成这个递推公式，从而无需B，C或F，直接在O(n)的时间内，由P自己推得。
00:09:59.733 这个证明较长，因此这里就不展示出来了。有兴趣的观众可以从C和F的递推公式进行证明。
00:10:03.233 现在，我们已求得了p，并将原始问题转换为了p(H)*x=y。那这又有什么用呢？
00:10:08.133 试想一下，如果有一个多项式q(x)，满足q(x)*p(x)=1 mod f(x)。
00:10:19.933 这里的f(x)就是前面提到的多项式f(n,x)。那么，将原始两边同时乘以q(H)，便有：x=q(H)*y。
00:10:23.633 这样，我们就能立刻求出x。
00:10:31.033 让我把这样的多项式q(x)我们称之为p(x)的逆多项式。那么，如何求出逆多项式q(x)呢？
00:10:34.533 我们可以使用扩展欧几里得算法，利用f(x)和p(x)来求取q(x)。
00:10:39.533 这里，我们同时定义一个零多项式o(x)和单位多项式e(x)，在对f(x)和p(x)操作的同时，对o(x)和e(x)做相同的操作。
00:10:42.133 我们使用辗转相减法，将p(x)右移，使其最高系数和f(x)对齐，然后叠加到f(x)上。
00:10:45.733 叠加后，如果f(x)的最高系数仍旧大于等于p(x)，则继续右移p(x)并叠加到f(x)上。
00:10:49.333 否则，当f(x)的最高系数小于p(x)时，将p(x)和f(x)互换。
00:10:52.933 重复这样操作，直到f(x)最终被叠加为零。
00:11:02.533 最后剩下的p(x)则为两个多项式的最大公因子，记为g(x)，同时，最后剩下的e(x)则为p(x)的逆，也就是q(x)。
00:11:08.067 将q(x)写成矩阵Q。注意，这里的矩阵不是后面提到的完整的逆矩阵Q'，而是多个q(x)拼接起来。
00:11:14.167 这里，由于我们已求得q(x)。我们也可以利用这个式子来求x。
00:11:17.067 这里，我们可以从Y开始，不断将其和H相乘，使用左右扩散的方法计算下一个H^n*y，然后和q(n)叠加，得到x。
00:11:25.700 另一方面，由于q(H)就是B的逆矩阵Q'，并且可以证明B的逆矩阵Q'也满足十字偶校验约束。
00:11:29.500 因此，可以利用K*q求出逆矩阵Q'的第一行再通过递推公式求得完整Q'，最后再和y相乘求得x。
00:11:34.500 两种方式求得的x是相同的，有兴趣的观众可以自行证明。
00:11:37.100 不过，这整个求解的过程有一个问题，那就是我们假设满足q(x)p(x)=1 mod f(x)的多项式q(x)存在。
00:11:39.700 如果这样的多项式q(x)不存在，我们又当如何呢？
00:11:45.800 在上一集视频《解的数量》章节中，我们提到公式r'(n)。
00:11:48.700 这里，gcd表示最大公因子。不难发现，这里的gcd(f,c)就是前面扩展欧几里得算法中的g(x)。
00:11:52.400 同时，由于F=C+P，因此gcd(f,c)和gcd(f,p)是相等的。
00:11:56.100 deg则表示最高次幂。r'代表矩阵B丢失的秩，也就是n-r。r'的值决定了解的数量，即2^r'。
00:11:58.700 可以发现，如果B是可逆的，则g(x)=1，r'=0，n=r-r'=r。
00:12:02.700 将g(x)写成矩阵的形式，记为G。
00:12:06.500 不难注意到，只有当矩阵B为可逆矩阵时，g(x)=1，并且g(x)的最高次幂为n-r=r'。
00:12:10.600 例如，当n=5时的时候，高斯消元后的B的伪逆矩阵Q'和单元矩阵E'矩阵是这样的。
00:12:15.300 这里，矩阵B不可逆，其秩为r=3。我们以rxr为界将矩阵分为四块，则有这些结论。
00:12:18.900 1. B矩阵左上角rxr的子矩阵满秩，并且为和Q'左上角rxr子矩阵互为逆矩阵。
00:12:22.700 2. Q'右下角和E'左上角为单位矩阵，Q'右上角和E'下方为零。
00:12:28.133 3. Q'左下角Wr和E'右上角的静默操作相同，并且其值等于Q'左上角乘B右上角，或者B左下角乘以Q'左上角。
00:12:34.200 这些性质可以通过分块矩阵乘法，结合高斯消元和矩阵B的对称性得出，有兴趣的观众可以自行证明。
00:12:38.000 可以发现，Q'不满足十字偶校验约束，因而无法通过公式递推求得。并且使用Q'第一行求得的x也不是原方程的解。
00:12:46.733 如果我们令Q'第一行为q(x)，并且和p(x)相乘，得到的g(x)不为1，最高次幂为4。
00:12:58.833 另一方面，如果我们直接使用扩展欧几里得法，通过p(x)和f(x)进行求解，得到的g(x)也不为1。
00:13:08.533 将求得的q(x)和p(x)相乘，得到刚才求得的g(x)，其最高次幂为2。
00:13:18.733 这里，我们计算q(H)*y，发现求得的x也不是解。
00:13:27.767 两种方法求得的q(x)和g(x)都不相同，g(x)都不为1，并且q(H)*y=x也都不是解。
00:13:33.967 因此，如果g(x)不为1，则q(x)不满足q(x)p(x)=1 mod f(x)。或者说，满足q(x)p(x)=1 mod f(x)的q(x)不存在。
00:13:37.167 那么对于不可逆的矩阵B，我们又有什么方法解决呢？
00:13:44.467 在刚才的《首行求逆法》中，我们有这些公式。
00:13:47.967 现在，我们定义多项式q'(x)，满足q'(x)*p(x)=g(x) mod f(x)。
00:13:51.367 其中，g(x)也就是刚才提到的最大公因子，q'(x)就是刚才求得的q(x)。
00:13:54.267 由于原本求得的x已不是最终解而是部分解，我们将其重命名为z，即z=q'(H)*y。
00:13:58.467 同时，我们定义q'(x)的逆多项式p'(x)，即q'(x)*p'(x)=1 mod f(x)。
00:14:01.367 我们不难推出以下结论。为了方便表示，我将mod f(x)的部分省去。
00:14:07.067 整理后，我们可以得到这些式子。
00:14:19.667 这里，如果g(x)=1，则会有以上式子。
00:14:26.167 前面使用的扩展欧几里得法中，我们已求得q'(x)和g(x)。因此，接下来只需要使用g(x)和z求得x即可。
00:14:29.067 前者，我们有公式z=q'(H)y。我们不断把y和H叠加，然后利用向量乘以矩阵的方式求得z。
00:14:32.467 现在，我们有公式z=g(H)x。由于需要求得的是x，需要用反向叠加的方式来求得。
00:14:37.567 以n=5为例，我们首先需要使用类似生成B矩阵的方法，生成g(H)，记为矩阵D。其秩与B矩阵相同。
00:14:40.167 1. 创建n个单位向量，也就是D矩阵的第一行。这里和B矩阵相同，一共有n个向量。
00:14:42.267 2. 使用H矩阵，将每个D矩阵第一行扩散到下面的行。
00:14:44.867 3. 根据多项式g(x)，将每个D矩阵的对应行叠加起来，叠加完的行共同构成一个新的D矩阵。
00:15:00.900 可以发现，这里的步骤和首行叠加法类似，共有n个矩阵要生成，时间复杂度是O(n^3)。
00:15:03.500 不过，聪明的你一定能猜到，通过《生成矩阵法》调换矩阵的行以后，这些矩阵也都满足十字偶校验约束。
00:15:12.400 因此。我们同样只需要生成第一个矩阵，然后递推就行。
00:15:19.900 生成第一个矩阵的过程中，每行乘以H矩阵的结果，就是刚才的K矩阵。
00:15:21.700 因此，只需要将g(x)和K直接相乘，即可得到第一个矩阵的最后一行，即D矩阵的第一行。
00:15:29.033 然后，我们就可以使用十字偶校验约束的递推关系，求得之后的行。
00:15:36.733 由于D矩阵是由H矩阵生成的，具有这些性质。这里，r'=n-r=deg(g(x))。n=5，r=3，r'=2。
00:15:39.633 1. 后r行，第n行最左边的n-r'-1个元素为0。
00:15:43.133 2. 后r行，第n行第n-r'的元素为1。
00:15:46.333 3. 后r行，线性无关，即任意一行都不能由别的行叠加。
00:15:49.833 4. 前r'行，任意一行都可以由后r行叠加。
00:15:53.333 这些性质都不难证明。由于视频时长有限，有兴趣的观众朋友可以自行证明。
00:15:56.533 现在，我们有z=D*x=g(H)x。
00:15:59.933 接下来，我们只需要将z拆解成不同D行的叠加，就能表式出x。
00:16:04.667 由于D矩阵后3行线性无关，因此我们只需要将后3行叠加起来即可。
00:16:07.867 让我们观察z的第1个元素和D的后三行。在D的后3行种中，只有第3行的第1个元素为1。
00:16:11.067 因此，如果z的第1个元素为1，我们需要将第3行叠加上去，并标记X的第3个元素为1。
00:16:13.667 幸运的是，z的第1个元素为0，因此我们可以跳过这一步骤。
00:16:16.867 我们再看z的第2个元素，该元素为1。因此，我们需要将第4行叠加到z上，同时标记X的第4个元素为1。
00:16:20.067 现在，z的第2个元素被消去，变成了00111。我们接着看z的第3个元素。
00:16:24.367 由于z的第3个元素变为了1，我们需要叠加D的第5行并标记x的第5个元素。
00:16:27.567 这次，z被彻底消去变为了零，而x变为了00011。
00:16:31.867 由此，我们通过依次叠加D的后3行，将z的元素依次消去。同时，将叠加的行标记为1，也就是最终的x。
00:16:35.367 不难发现这里求得的x是一个特解。
00:16:37.967 由于前r'行可以表示为后r行的线性叠加，因此我们可以在操作y之前，先将其和前r'的任意行叠加，然后再求解。
00:16:40.867 由于前r'行共有2^r'种，因此求得的解也有2^r'种。
00:16:44.067 另一方面，由于D矩阵满足十字偶校验约束，表现出高度的对称性。其中，行和列的坐标可以互换。
00:16:47.867 因此，我们可以同样只叠加前r行，从右往左进行消元。由于效果是相同的，这里不再赘述。
00:16:58.667 细心的观众会发现，其实这两个式子有相同的形式。
00:17:01.567 既然我们可以在第二个式子用反向消元法求x，为什么不能用相同的方法在第一个式子求x呢？
00:17:16.833 事实上，使用反向求逆法求得的x并不可行。
00:17:17.433 这是因为D矩阵是由g(H)生成的，具有满足带状上三角的可回代结构，满足前面说到的四个性质。
00:17:20.333 而B=p'(H)D破坏了这一结构，不满足这些性质。这里，因为D=g(H)不满秩，因此p'(H)不唯一。
00:17:24.033 不过，当g=1时，这个种解法是可行的。尽管这个方法首先需要求出完整的B矩阵。
00:17:26.933 同时，因为B矩阵不是三角结构，还需标记每行首个i的位置来选择。因此，直接计算q(H)*Y会更加方便。
00:17:30.433 最终，我们通过欧几里得法和反向消元法，完成了Bx=y的求解，实现了点灯游戏在O(n^2)时间复杂度的算法。
00:17:39.033 向量和矩阵的乘法，欧几里得算法，以及K矩阵的生成，理论上通过卷积，FFT或牛顿迭代法是有可能优化到O(n*log(n))的。
00:17:41.633 考虑到UP主《信号与系统》、《数字信号处理》、《数值分析》等课程较差，暂时就不研究了。有兴趣的小伙伴可自行研究并留言。
00:17:44.233 如果对视频中的内容有疑问，觉得视频内容表述不清，或者发现视频中的任何错误，也请大家多多留言和指证。谢谢大家观看！
