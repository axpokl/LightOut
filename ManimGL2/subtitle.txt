00:00:04.000 对于O(n^2)的算法，我们也是使用类似的方法，尽可能的不去对完整矩阵进行操作，而是通过第一行来求逆或求解。
00:00:07.200 这里，让我以我们以n=7为例。这里的B就是前面提到的按钮矩阵B，而y就是翻转矩阵Y的最后一行。
00:00:10.700 我们的目标是，对于Bx=y，在已知B的第一行和Y的情况下求x。
00:00:23.000 如果将n在不同情况下B的第一行写在一起，这样的B矩阵长这样。
00:00:28.200 注意，这里的B矩阵不是刚才说的当n确定时的完整的B矩阵，而是B(n)的第一行拼接起来。
00:00:31.400 另外，这里从n=0开始一共递推n次，最后一个1不包含在B矩阵的第一行内。例如n=7时，第一行为1011011，最后一个1省去。
00:00:36.000 把Y的第一行写在一起是这样的。
00:00:40.400 为了实现这个目标，我们需要首先将B进行分解。这里，让我首先介绍一个非常重要的矩阵H。
00:00:42.200 对于H的每一个元素，如果x和y的差为一则为一，否则为零。
00:00:44.800 如果将向量v乘以该矩阵，等同于将向量v的每个元素向左右扩散后叠加。
00:00:51.900 这是因为矩阵的对应行就是向量每个元素左右扩散的结果。
00:00:56.600 不难发现，《首行叠加法》中的各个B矩阵，可以使用H表示为以上公式。
00:00:58.400 例如，B(0)=H^0，B(1)=H^0+H^1，B(2)=H^2
00:01:01.900 将其系数用多项式c(n,x)表达，则有和B矩阵类似的表达式。同时，将系数c写成矩阵的形式，记为C。
00:01:06.000 注意，这里的乘以H的操作在系数上代表右移而不是左右扩散，因此表达式中只有x-1而没有x+1。
00:01:08.600 这个C矩阵和后面提到的F矩阵息息相关。
00:01:13.000 现在，如果我们将多个H相乘，也就是H^n，则其首行H^n(0)从单位矩阵n=0开始，看起来像是这样的。
00:01:16.200 我们把这个下三角矩阵记为K，即Krylov矩阵或扩散基矩阵。也就是说，对于K的第n行，有K(n)=H^n(0)。
00:01:19.100 这里下一行是上一行乘以H，也就是上一行左右扩散的叠加。因此对于K的每个元素，有以上公式。
00:01:24.400 现在，定义多项式p(x)。我们的目标是把B拆分成H^n。
00:01:27.300 将矩阵H代入多项式p(x)，得到p(H)，并用其表示矩阵B。
00:01:30.200 这样，原始求X的问题就变为了p(H)X=Y。
00:01:33.100 现在，我们需要把多项式p(H)的系数计算出来。这个系数构成的向量我们记为p。
00:01:36.000 为了简化运算，我们只关心矩阵第一行B(0)，记为b。根据刚才的定义，我们可以得到b=K*p。
00:01:53.100 为了求得p，我们可以将两边同时乘以K的逆矩阵K^-1。为了方便我们记为F，又称反Krylov矩阵或解耦矩阵。
00:01:56.900 这个矩阵F也是下三角矩阵，并且和矩阵K看上去差不多，不过并不相同。事实上，这个矩阵F也满足类似的性质。
00:02:03.800 有兴趣的小伙伴可以试着证明一下，使用这两个性质构造的矩阵K和F，然后证明互为逆矩阵。
00:02:07.900 于是，我们便有：F*b=F*K*p=p。这样我们便求出了p。
00:02:21.500 将多项式p(x)写成矩阵的形式，记为P。
00:02:25.900 这里说明一下，矩阵F的每行对应多项式f(n,x)，也就是上一集视频《解的数量》章节中提到的OEIS中的Fibonacci多项式。
00:02:28.800 此外，刚才递推得到的C矩阵对应多项式c(n,x)，其实也就是这里提到的f(n,x+1)。
00:02:31.700 这是因为B(n)矩阵也可以写为以上形式。这里的H⊕I等价于x+1。
00:02:34.600 同时，上一集视频提到的公式r'(n)，可以表示为多项式f和c的最大公因子的最高次幂。
00:02:35.500 这里，gcd表示最大公因子，我们将其记为多项式g(x)。
00:02:38.400 deg表示最高次幂，其等价于矩阵B丢失的秩，也就是n-r。这个g(x)和n-r在后续算法中也会提到。
00:02:41.000 可以发现，如果B是可逆的，则g(x)=1，n=r，r’=0。否则，r'的值决定了解的数量，即2^r'。
00:02:45.100 将g(x)写成矩阵的形式，记为G。
