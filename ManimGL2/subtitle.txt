00:00:00.000 现在，如果我们把序号1-25用坐标x,y表示，则灯和按钮矩阵可写为上述公式。
00:00:00.000 现在，如果我们把序号1-25用坐标x,y表示，则灯和按钮矩阵可写为上述公式。
00:00:02.900 这里，我们的矩阵同时满足另一个性质，我称之为十字偶校验约束。
00:00:05.800 某个元素的左右两个矩阵的对应位置的元素，和这个元素上下两个元素的叠加后为零。
00:00:09.400 这就是之前视频优化生成矩阵章节中的性质，后面我会给予证明。
00:00:02.900 这里，我们的矩阵同时满足另一个性质，我称之为十字偶校验约束。
00:00:10.000 通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。
00:00:13.600 因此，我们可以在公式中去除y。也就是说，灯为当前矩阵的上左中右按钮的叠加。
00:00:05.800 某个元素的左右两个矩阵的对应位置的元素，和这个元素上下两个元素的叠加后为零。
00:00:19.200 又因为，下一行按钮是当前灯翻转。
00:00:22.800 以及，下一行灯是上左中右灯翻转的叠加。
00:00:25.700 如果把翻转~提取出来，便有了一开始的推导公式。
00:00:26.300 也就是，按钮是上一行左中右按钮和上上行按钮叠加。
00:00:09.400 这就是之前视频优化生成矩阵章节中的性质，后面我会给予证明。
00:00:29.900 以及，灯是上一行左中右按钮和上上行灯叠加。
00:00:10.000 通过这个性质，递推公式可化为只根据当前矩阵的元素来叠加，无需依赖于左右矩阵。
00:00:35.500 可以注意到，按钮和灯的递推公式具有相同的形式，这是因为上一行灯就是下一行按钮。
00:00:36.100 因为最终需要推导的是灯矩阵，因此灯矩阵是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮矩阵也是5行。
00:00:37.300 对于翻转的情况，则可以单独列出来，以类似的方法推导，写成Y公式：
00:00:38.200 下一行的翻转是上一行左中右和上上行叠加后的翻转。
00:00:38.800 可以注意到，这里的公式Y和B的推导公式是类似的的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号~。
00:00:39.400 1. 使用零向量：第一次翻转发生在从一到二行的迭代过程中，在此之前没有发生过翻转，因此Y的第一行就不是10000而是00000了。
00:00:40.000 2. 翻转符号~必须存在：每次迭代都需要翻转，因此不可省略。而前者将这个翻转取出来了，不用翻转符号~。
00:00:13.600 因此，我们可以在公式中去除y。也就是说，灯为当前矩阵的上左中右按钮的叠加。
00:00:40.600 3. 不使用x而使用y：翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
00:00:19.200 又因为，下一行按钮是当前灯翻转。
00:00:22.800 以及，下一行灯是上左中右灯翻转的叠加。
00:00:25.700 如果把翻转~提取出来，便有了一开始的推导公式。
00:00:26.300 也就是，按钮是上一行左中右按钮和上上行按钮叠加。
00:00:29.900 以及，灯是上一行左中右按钮和上上行灯叠加。
00:00:35.500 可以注意到，按钮和灯的递推公式具有相同的形式，这是因为上一行灯就是下一行按钮。
00:00:36.100 因为最终需要推导的是灯矩阵，因此灯矩阵是从按钮的第一行推导5行。因为最后一次推导的是灯，因此按钮矩阵也是5行。
00:00:37.300 对于翻转的情况，则可以单独列出来，以类似的方法推导，写成Y公式：
00:00:38.200 下一行的翻转是上一行左中右和上上行叠加后的翻转。
00:00:38.800 可以注意到，这里的公式Y和B的推导公式是类似的的。只不过，Y是从零向量开始推导的，并且不能省略翻转符号~。
00:00:39.400 1. 使用零向量：第一次翻转发生在从一到二行的迭代过程中，在此之前没有发生过翻转，因此Y的第一行就不是10000而是00000了。
00:00:40.000 2. 翻转符号~必须存在：每次迭代都需要翻转，因此不可省略。而前者将这个翻转取出来了，不用翻转符号~。
00:00:40.600 3. 不使用x而使用y：翻转是前面所有按钮的翻转叠加后提取出来的，代表的是灯的翻转，而不是某个按钮的翻转。
